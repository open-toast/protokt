/*
 * Copyright (c) 2023 Toast, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/protobuf/struct.proto
package com.toasttab.protokt

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtEnum
import com.toasttab.protokt.rt.KtEnumDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.copyMap
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.finishMap
import com.toasttab.protokt.rt.sizeof
import com.toasttab.protokt.rt.sizeofMap
import kotlin.Any
import kotlin.Boolean
import kotlin.Double
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableList
import kotlin.collections.MutableMap

/**
 * `Struct` represents a structured data value, consisting of fields which map to dynamically typed
 * values. In some languages, `Struct` might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an object. The details of that representation
 * are described together with the proto support for the language.
 *
 *  The JSON representation for `Struct` is JSON object.
 */
sealed class NullValue(
    override val `value`: Int,
    override val name: String,
) : KtEnum() {
    /**
     * Unordered map of dynamically typed values.
     */
    object NULL_VALUE : NullValue(0, "NULL_VALUE")

    class UNRECOGNIZED(
        `value`: Int,
    ) : NullValue(value, "UNRECOGNIZED")

    companion object Deserializer : KtEnumDeserializer<NullValue> {
        override fun from(`value`: Int): NullValue = when (value) {
            0 -> NULL_VALUE
            else -> UNRECOGNIZED(value)
        }
    }
}

/**
 * `Struct` represents a structured data value, consisting of fields which map to dynamically typed
 * values. In some languages, `Struct` might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an object. The details of that representation
 * are described together with the proto support for the language.
 *
 *  The JSON representation for `Struct` is JSON object.
 */
@KtGeneratedMessage("google.protobuf.Struct")
class Struct private constructor(
    /**
     * Unordered map of dynamically typed values.
     */
    val fields: Map<String, Value>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (fields.isNotEmpty()) {
            result += sizeofMap(fields, Tag(1)) { k, v -> FieldsEntry.sizeof(k, v)}
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (fields.isNotEmpty()) {
            fields.entries.forEach { serializer.write(Tag(10)).write(FieldsEntry(it.key, it.value))
            }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Struct &&
            other.fields == fields &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + fields.hashCode()
        return result
    }

    override fun toString(): String = "Struct(" +
            "fields=$fields" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: StructDsl.() -> Unit): Struct = Struct.Deserializer {
        fields = this@Struct.fields
        unknownFields = this@Struct.unknownFields
        dsl()
    }

    class StructDsl {
        var fields: Map<String, Value> = emptyMap()
            set(newValue) {
                field = copyMap(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Struct = Struct(finishMap(fields),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<Struct>, (StructDsl.() -> Unit) -> Struct
    {
        override fun deserialize(deserializer: KtMessageDeserializer): Struct {
            var fields : MutableMap<String, Value>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Struct(finishMap(fields),
                        UnknownFieldSet.from(unknownFields))
                    10 -> fields = (fields ?: mutableMapOf()).apply {
                        deserializer.readRepeated(false) {

                            deserializer.readMessage(com.toasttab.protokt.Struct.FieldsEntry)
                                .let { put(
                                    it.key,
                                    it.value
                                ) }
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: StructDsl.() -> Unit): Struct =
            StructDsl().apply(dsl).build()
    }

    private class FieldsEntry(
        val key: String,
        val `value`: Value,
    ) : KtMessage {
        override val messageSize: Int
            get() = sizeof(key, value)

        override fun serialize(serializer: KtMessageSerializer) {
            serializer.write(Tag(10)).write(key)

            serializer.write(Tag(18)).write(value)
        }

        companion object Deserializer : KtDeserializer<FieldsEntry> {
            fun sizeof(key: String, `value`: Value) =
                com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(value)

            override fun deserialize(deserializer: KtMessageDeserializer): FieldsEntry {
                var key = ""
                var value: com.toasttab.protokt.Value? = null

                while (true) {
                    when (deserializer.readTag()) {
                        0 -> return FieldsEntry(key, value ?: com.toasttab.protokt.Value {})
                        10 -> key = deserializer.readString()
                        18 -> value = deserializer.readMessage(com.toasttab.protokt.Value)
                    }
                }
            }
        }
    }
}

/**
 * `Value` represents a dynamically typed value which can be either null, a number, a string, a
 * boolean, a recursive struct value, or a list of values. A producer of value is expected to set one
 * of these variants. Absence of any variant indicates an error.
 *
 *  The JSON representation for `Value` is JSON value.
 */
@KtGeneratedMessage("google.protobuf.Value")
class Value private constructor(
    /**
     * The kind of value.
     */
    val kind: Kind?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        when (kind) {
            is Value.Kind.NullValue -> {
                result += sizeof(Tag(1)) + sizeof(kind.nullValue)}
            is Value.Kind.NumberValue -> {
                result += sizeof(Tag(2)) + sizeof(kind.numberValue)}
            is Value.Kind.StringValue -> {
                result += sizeof(Tag(3)) + sizeof(kind.stringValue)}
            is Value.Kind.BoolValue -> {
                result += sizeof(Tag(4)) + sizeof(kind.boolValue)}
            is Value.Kind.StructValue -> {
                result += sizeof(Tag(5)) + sizeof(kind.structValue)}
            is Value.Kind.ListValue -> {
                result += sizeof(Tag(6)) + sizeof(kind.listValue)}
            null -> Unit
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        when (kind) {
            is Value.Kind.NullValue -> {
                serializer.write(Tag(8)).write(kind.nullValue)
            }
            is Value.Kind.NumberValue -> {
                serializer.write(Tag(17)).write(kind.numberValue)
            }
            is Value.Kind.StringValue -> {
                serializer.write(Tag(26)).write(kind.stringValue)
            }
            is Value.Kind.BoolValue -> {
                serializer.write(Tag(32)).write(kind.boolValue)
            }
            is Value.Kind.StructValue -> {
                serializer.write(Tag(42)).write(kind.structValue)
            }
            is Value.Kind.ListValue -> {
                serializer.write(Tag(50)).write(kind.listValue)
            }
            null -> Unit
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Value &&
            other.kind == kind &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + kind.hashCode()
        return result
    }

    override fun toString(): String = "Value(" +
            "kind=$kind" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ValueDsl.() -> Unit): Value = Value.Deserializer {
        kind = this@Value.kind
        unknownFields = this@Value.unknownFields
        dsl()
    }

    sealed class Kind {
        /**
         * Represents a null value.
         */
        data class NullValue(
            val nullValue: com.toasttab.protokt.NullValue,
        ) : Kind()

        /**
         * Represents a double value.
         */
        data class NumberValue(
            val numberValue: Double,
        ) : Kind()

        /**
         * Represents a string value.
         */
        data class StringValue(
            val stringValue: String,
        ) : Kind()

        /**
         * Represents a boolean value.
         */
        data class BoolValue(
            val boolValue: Boolean,
        ) : Kind()

        /**
         * Represents a structured value.
         */
        data class StructValue(
            val structValue: Struct,
        ) : Kind()

        /**
         * Represents a repeated `Value`.
         */
        data class ListValue(
            val listValue: com.toasttab.protokt.ListValue,
        ) : Kind()
    }

    class ValueDsl {
        var kind: Kind? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Value = Value(kind,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<Value>, (ValueDsl.() -> Unit) -> Value {
        override fun deserialize(deserializer: KtMessageDeserializer): Value {
            var kind : Kind? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Value(kind,
                        UnknownFieldSet.from(unknownFields))
                    8 -> kind =
                        Kind.NullValue(deserializer.readEnum(com.toasttab.protokt.NullValue))
                    17 -> kind = Kind.NumberValue(deserializer.readDouble())
                    26 -> kind = Kind.StringValue(deserializer.readString())
                    32 -> kind = Kind.BoolValue(deserializer.readBool())
                    42 -> kind =
                        Kind.StructValue(deserializer.readMessage(com.toasttab.protokt.Struct))
                    50 -> kind =
                        Kind.ListValue(deserializer.readMessage(com.toasttab.protokt.ListValue))
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ValueDsl.() -> Unit): Value = ValueDsl().apply(dsl).build()
    }
}

/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 *  The JSON representation for `ListValue` is JSON array.
 */
@KtGeneratedMessage("google.protobuf.ListValue")
class ListValue private constructor(
    /**
     * Repeated field of dynamically typed values.
     */
    val values: List<Value>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (values.isNotEmpty()) {
            result += (sizeof(Tag(1)) * values.size) + values.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (values.isNotEmpty()) {
            values.forEach { serializer.write(Tag(10)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ListValue &&
            other.values == values &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + values.hashCode()
        return result
    }

    override fun toString(): String = "ListValue(" +
            "values=$values" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ListValueDsl.() -> Unit): ListValue = ListValue.Deserializer {
        values = this@ListValue.values
        unknownFields = this@ListValue.unknownFields
        dsl()
    }

    class ListValueDsl {
        var values: List<Value> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ListValue = ListValue(finishList(values),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<ListValue>,
            (ListValueDsl.() -> Unit) -> ListValue {
        override fun deserialize(deserializer: KtMessageDeserializer): ListValue {
            var values : MutableList<Value>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ListValue(finishList(values),
                        UnknownFieldSet.from(unknownFields))
                    10 -> values = (values ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {
                            add(deserializer.readMessage(com.toasttab.protokt.Value))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ListValueDsl.() -> Unit): ListValue =
            ListValueDsl().apply(dsl).build()
    }
}
