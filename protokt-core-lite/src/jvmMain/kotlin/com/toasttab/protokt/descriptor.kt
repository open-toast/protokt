/*
 * Copyright (c) 2023 Toast, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/protobuf/descriptor.proto
package com.toasttab.protokt

import com.toasttab.protokt.rt.Bytes
import com.toasttab.protokt.rt.Int32
import com.toasttab.protokt.rt.Int64
import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtEnum
import com.toasttab.protokt.rt.KtEnumDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UInt32
import com.toasttab.protokt.rt.UInt64
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.Double
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * The protocol compiler can output a FileDescriptorSet containing the .proto files it parses.
 */
@KtGeneratedMessage("google.protobuf.FileDescriptorSet")
class FileDescriptorSet private constructor(
    val `file`: List<FileDescriptorProto>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (file.isNotEmpty()) {
            result += (sizeof(Tag(1)) * file.size) + file.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (file.isNotEmpty()) {
            file.forEach { serializer.write(Tag(10)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is FileDescriptorSet &&
            other.file == file &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + file.hashCode()
        return result
    }

    override fun toString(): String = "FileDescriptorSet(" +
            "file=$file" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: FileDescriptorSetDsl.() -> Unit): FileDescriptorSet =
        FileDescriptorSet.Deserializer {
            file = this@FileDescriptorSet.file
            unknownFields = this@FileDescriptorSet.unknownFields
            dsl()
        }

    class FileDescriptorSetDsl {
        var `file`: List<FileDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): FileDescriptorSet = FileDescriptorSet(finishList(file),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<FileDescriptorSet>,
            (FileDescriptorSetDsl.() -> Unit) -> FileDescriptorSet {
        override fun deserialize(deserializer: KtMessageDeserializer): FileDescriptorSet {
            var file : MutableList<FileDescriptorProto>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return FileDescriptorSet(finishList(file),
                        UnknownFieldSet.from(unknownFields))
                    10 -> file = (file ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.FileDescriptorProto))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: FileDescriptorSetDsl.() -> Unit): FileDescriptorSet =
            FileDescriptorSetDsl().apply(dsl).build()
    }
}

/**
 * Describes a complete .proto file.
 */
@KtGeneratedMessage("google.protobuf.FileDescriptorProto")
class FileDescriptorProto private constructor(
    val name: String?,
    val `package`: String?,
    /**
     * Names of files imported by this file.
     */
    val dependency: List<String>,
    /**
     * All top-level definitions in this file.
     */
    val messageType: List<DescriptorProto>,
    val enumType: List<EnumDescriptorProto>,
    val service: List<ServiceDescriptorProto>,
    val extension: List<FieldDescriptorProto>,
    val options: FileOptions?,
    /**
     * This field contains optional information about the original source code. You may safely
     * remove this entire field without harming runtime functionality of the descriptors -- the
     * information is needed only by development tools.
     */
    val sourceCodeInfo: SourceCodeInfo?,
    /**
     * Indexes of the public imported files in the dependency list above.
     */
    val publicDependency: List<Int>,
    /**
     * Indexes of the weak imported files in the dependency list. For Google-internal migration
     * only. Do not use.
     */
    val weakDependency: List<Int>,
    /**
     * The syntax of the proto file. The supported values are "proto2" and "proto3".
     */
    val syntax: String?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (`package` != null) {
            result += sizeof(Tag(2)) + sizeof(`package`)
        }
        if (dependency.isNotEmpty()) {
            result += (sizeof(Tag(3)) * dependency.size) + dependency.sumOf { sizeof(it) }
        }
        if (messageType.isNotEmpty()) {
            result += (sizeof(Tag(4)) * messageType.size) + messageType.sumOf { sizeof(it) }
        }
        if (enumType.isNotEmpty()) {
            result += (sizeof(Tag(5)) * enumType.size) + enumType.sumOf { sizeof(it) }
        }
        if (service.isNotEmpty()) {
            result += (sizeof(Tag(6)) * service.size) + service.sumOf { sizeof(it) }
        }
        if (extension.isNotEmpty()) {
            result += (sizeof(Tag(7)) * extension.size) + extension.sumOf { sizeof(it) }
        }
        if (options != null) {
            result += sizeof(Tag(8)) + sizeof(options)
        }
        if (sourceCodeInfo != null) {
            result += sizeof(Tag(9)) + sizeof(sourceCodeInfo)
        }
        if (publicDependency.isNotEmpty()) {
            result += (sizeof(Tag(10)) * publicDependency.size) + publicDependency.sumOf {
                sizeof(Int32(it)) }
        }
        if (weakDependency.isNotEmpty()) {
            result += (sizeof(Tag(11)) * weakDependency.size) + weakDependency.sumOf {
                sizeof(Int32(it)) }
        }
        if (syntax != null) {
            result += sizeof(Tag(12)) + sizeof(syntax)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (`package` != null) {
            serializer.write(Tag(18)).write(`package`)
        }
        if (dependency.isNotEmpty()) {
            dependency.forEach { serializer.write(Tag(26)).write(it) }
        }
        if (messageType.isNotEmpty()) {
            messageType.forEach { serializer.write(Tag(34)).write(it) }
        }
        if (enumType.isNotEmpty()) {
            enumType.forEach { serializer.write(Tag(42)).write(it) }
        }
        if (service.isNotEmpty()) {
            service.forEach { serializer.write(Tag(50)).write(it) }
        }
        if (extension.isNotEmpty()) {
            extension.forEach { serializer.write(Tag(58)).write(it) }
        }
        if (options != null) {
            serializer.write(Tag(66)).write(options)
        }
        if (sourceCodeInfo != null) {
            serializer.write(Tag(74)).write(sourceCodeInfo)
        }
        if (publicDependency.isNotEmpty()) {
            publicDependency.forEach { serializer.write(Tag(80)).write(Int32(it)) }
        }
        if (weakDependency.isNotEmpty()) {
            weakDependency.forEach { serializer.write(Tag(88)).write(Int32(it)) }
        }
        if (syntax != null) {
            serializer.write(Tag(98)).write(syntax)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is FileDescriptorProto &&
            other.name == name &&
            other.`package` == `package` &&
            other.dependency == dependency &&
            other.messageType == messageType &&
            other.enumType == enumType &&
            other.service == service &&
            other.extension == extension &&
            other.options == options &&
            other.sourceCodeInfo == sourceCodeInfo &&
            other.publicDependency == publicDependency &&
            other.weakDependency == weakDependency &&
            other.syntax == syntax &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + `package`.hashCode()
        result = 31 * result + dependency.hashCode()
        result = 31 * result + messageType.hashCode()
        result = 31 * result + enumType.hashCode()
        result = 31 * result + service.hashCode()
        result = 31 * result + extension.hashCode()
        result = 31 * result + options.hashCode()
        result = 31 * result + sourceCodeInfo.hashCode()
        result = 31 * result + publicDependency.hashCode()
        result = 31 * result + weakDependency.hashCode()
        result = 31 * result + syntax.hashCode()
        return result
    }

    override fun toString(): String = "FileDescriptorProto(" +
            "name=$name, " +
            "`package`=$`package`, " +
            "dependency=$dependency, " +
            "messageType=$messageType, " +
            "enumType=$enumType, " +
            "service=$service, " +
            "extension=$extension, " +
            "options=$options, " +
            "sourceCodeInfo=$sourceCodeInfo, " +
            "publicDependency=$publicDependency, " +
            "weakDependency=$weakDependency, " +
            "syntax=$syntax" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: FileDescriptorProtoDsl.() -> Unit): FileDescriptorProto =
        FileDescriptorProto.Deserializer {
            name = this@FileDescriptorProto.name
            `package` = this@FileDescriptorProto.`package`
            dependency = this@FileDescriptorProto.dependency
            messageType = this@FileDescriptorProto.messageType
            enumType = this@FileDescriptorProto.enumType
            service = this@FileDescriptorProto.service
            extension = this@FileDescriptorProto.extension
            options = this@FileDescriptorProto.options
            sourceCodeInfo = this@FileDescriptorProto.sourceCodeInfo
            publicDependency = this@FileDescriptorProto.publicDependency
            weakDependency = this@FileDescriptorProto.weakDependency
            syntax = this@FileDescriptorProto.syntax
            unknownFields = this@FileDescriptorProto.unknownFields
            dsl()
        }

    class FileDescriptorProtoDsl {
        var name: String? = null

        var `package`: String? = null

        var dependency: List<String> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var messageType: List<DescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var enumType: List<EnumDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var service: List<ServiceDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var extension: List<FieldDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var options: FileOptions? = null

        var sourceCodeInfo: SourceCodeInfo? = null

        var publicDependency: List<Int> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var weakDependency: List<Int> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var syntax: String? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): FileDescriptorProto = FileDescriptorProto(name,
            `package`,
            finishList(dependency),
            finishList(messageType),
            finishList(enumType),
            finishList(service),
            finishList(extension),
            options,
            sourceCodeInfo,
            finishList(publicDependency),
            finishList(weakDependency),
            syntax,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<FileDescriptorProto>,
            (FileDescriptorProtoDsl.() -> Unit) -> FileDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer): FileDescriptorProto {
            var name : String? = null
            var `package` : String? = null
            var dependency : MutableList<String>? = null
            var messageType : MutableList<DescriptorProto>? = null
            var enumType : MutableList<EnumDescriptorProto>? = null
            var service : MutableList<ServiceDescriptorProto>? = null
            var extension : MutableList<FieldDescriptorProto>? = null
            var options : FileOptions? = null
            var sourceCodeInfo : SourceCodeInfo? = null
            var publicDependency : MutableList<Int>? = null
            var weakDependency : MutableList<Int>? = null
            var syntax : String? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return FileDescriptorProto(name,
                        `package`,
                        finishList(dependency),
                        finishList(messageType),
                        finishList(enumType),
                        finishList(service),
                        finishList(extension),
                        options,
                        sourceCodeInfo,
                        finishList(publicDependency),
                        finishList(weakDependency),
                        syntax,
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> `package` = deserializer.readString()
                    26 -> dependency = (dependency ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {
                            add(deserializer.readString())
                        }
                    }
                    34 -> messageType = (messageType ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.DescriptorProto))
                        }
                    }
                    42 -> enumType = (enumType ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.EnumDescriptorProto))
                        }
                    }
                    50 -> service = (service ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.ServiceDescriptorProto))
                        }
                    }
                    58 -> extension = (extension ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.FieldDescriptorProto))
                        }
                    }
                    66 -> options = deserializer.readMessage(com.toasttab.protokt.FileOptions)
                    74 -> sourceCodeInfo =
                        deserializer.readMessage(com.toasttab.protokt.SourceCodeInfo)
                    80 -> publicDependency = (publicDependency ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {
                            add(deserializer.readInt32())
                        }
                    }
                    82 -> publicDependency = (publicDependency ?: mutableListOf()).apply {
                        deserializer.readRepeated(true) {
                            add(deserializer.readInt32())
                        }
                    }
                    88 -> weakDependency = (weakDependency ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {
                            add(deserializer.readInt32())
                        }
                    }
                    90 -> weakDependency = (weakDependency ?: mutableListOf()).apply {
                        deserializer.readRepeated(true) {
                            add(deserializer.readInt32())
                        }
                    }
                    98 -> syntax = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: FileDescriptorProtoDsl.() -> Unit): FileDescriptorProto =
            FileDescriptorProtoDsl().apply(dsl).build()
    }
}

/**
 * Describes a message type.
 */
@KtGeneratedMessage("google.protobuf.DescriptorProto")
class DescriptorProto private constructor(
    val name: String?,
    val `field`: List<FieldDescriptorProto>,
    val nestedType: List<DescriptorProto>,
    val enumType: List<EnumDescriptorProto>,
    val extensionRange: List<ExtensionRange>,
    val extension: List<FieldDescriptorProto>,
    val options: MessageOptions?,
    val oneofDecl: List<OneofDescriptorProto>,
    val reservedRange: List<ReservedRange>,
    /**
     * Reserved field names, which may not be used by fields in the same message. A given name may
     * only be reserved once.
     */
    val reservedName: List<String>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (field.isNotEmpty()) {
            result += (sizeof(Tag(2)) * field.size) + field.sumOf { sizeof(it) }
        }
        if (nestedType.isNotEmpty()) {
            result += (sizeof(Tag(3)) * nestedType.size) + nestedType.sumOf { sizeof(it) }
        }
        if (enumType.isNotEmpty()) {
            result += (sizeof(Tag(4)) * enumType.size) + enumType.sumOf { sizeof(it) }
        }
        if (extensionRange.isNotEmpty()) {
            result += (sizeof(Tag(5)) * extensionRange.size) + extensionRange.sumOf { sizeof(it) }
        }
        if (extension.isNotEmpty()) {
            result += (sizeof(Tag(6)) * extension.size) + extension.sumOf { sizeof(it) }
        }
        if (options != null) {
            result += sizeof(Tag(7)) + sizeof(options)
        }
        if (oneofDecl.isNotEmpty()) {
            result += (sizeof(Tag(8)) * oneofDecl.size) + oneofDecl.sumOf { sizeof(it) }
        }
        if (reservedRange.isNotEmpty()) {
            result += (sizeof(Tag(9)) * reservedRange.size) + reservedRange.sumOf { sizeof(it) }
        }
        if (reservedName.isNotEmpty()) {
            result += (sizeof(Tag(10)) * reservedName.size) + reservedName.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (field.isNotEmpty()) {
            field.forEach { serializer.write(Tag(18)).write(it) }
        }
        if (nestedType.isNotEmpty()) {
            nestedType.forEach { serializer.write(Tag(26)).write(it) }
        }
        if (enumType.isNotEmpty()) {
            enumType.forEach { serializer.write(Tag(34)).write(it) }
        }
        if (extensionRange.isNotEmpty()) {
            extensionRange.forEach { serializer.write(Tag(42)).write(it) }
        }
        if (extension.isNotEmpty()) {
            extension.forEach { serializer.write(Tag(50)).write(it) }
        }
        if (options != null) {
            serializer.write(Tag(58)).write(options)
        }
        if (oneofDecl.isNotEmpty()) {
            oneofDecl.forEach { serializer.write(Tag(66)).write(it) }
        }
        if (reservedRange.isNotEmpty()) {
            reservedRange.forEach { serializer.write(Tag(74)).write(it) }
        }
        if (reservedName.isNotEmpty()) {
            reservedName.forEach { serializer.write(Tag(82)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is DescriptorProto &&
            other.name == name &&
            other.field == field &&
            other.nestedType == nestedType &&
            other.enumType == enumType &&
            other.extensionRange == extensionRange &&
            other.extension == extension &&
            other.options == options &&
            other.oneofDecl == oneofDecl &&
            other.reservedRange == reservedRange &&
            other.reservedName == reservedName &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + field.hashCode()
        result = 31 * result + nestedType.hashCode()
        result = 31 * result + enumType.hashCode()
        result = 31 * result + extensionRange.hashCode()
        result = 31 * result + extension.hashCode()
        result = 31 * result + options.hashCode()
        result = 31 * result + oneofDecl.hashCode()
        result = 31 * result + reservedRange.hashCode()
        result = 31 * result + reservedName.hashCode()
        return result
    }

    override fun toString(): String = "DescriptorProto(" +
            "name=$name, " +
            "field=$field, " +
            "nestedType=$nestedType, " +
            "enumType=$enumType, " +
            "extensionRange=$extensionRange, " +
            "extension=$extension, " +
            "options=$options, " +
            "oneofDecl=$oneofDecl, " +
            "reservedRange=$reservedRange, " +
            "reservedName=$reservedName" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: DescriptorProtoDsl.() -> Unit): DescriptorProto =
        DescriptorProto.Deserializer {
            name = this@DescriptorProto.name
            field = this@DescriptorProto.field
            nestedType = this@DescriptorProto.nestedType
            enumType = this@DescriptorProto.enumType
            extensionRange = this@DescriptorProto.extensionRange
            extension = this@DescriptorProto.extension
            options = this@DescriptorProto.options
            oneofDecl = this@DescriptorProto.oneofDecl
            reservedRange = this@DescriptorProto.reservedRange
            reservedName = this@DescriptorProto.reservedName
            unknownFields = this@DescriptorProto.unknownFields
            dsl()
        }

    class DescriptorProtoDsl {
        var name: String? = null

        var `field`: List<FieldDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var nestedType: List<DescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var enumType: List<EnumDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var extensionRange: List<ExtensionRange> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var extension: List<FieldDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var options: MessageOptions? = null

        var oneofDecl: List<OneofDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var reservedRange: List<ReservedRange> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var reservedName: List<String> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): DescriptorProto = DescriptorProto(name,
            finishList(field),
            finishList(nestedType),
            finishList(enumType),
            finishList(extensionRange),
            finishList(extension),
            options,
            finishList(oneofDecl),
            finishList(reservedRange),
            finishList(reservedName),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<DescriptorProto>,
            (DescriptorProtoDsl.() -> Unit) -> DescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer): DescriptorProto {
            var name : String? = null
            var field : MutableList<FieldDescriptorProto>? = null
            var nestedType : MutableList<DescriptorProto>? = null
            var enumType : MutableList<EnumDescriptorProto>? = null
            var extensionRange : MutableList<ExtensionRange>? = null
            var extension : MutableList<FieldDescriptorProto>? = null
            var options : MessageOptions? = null
            var oneofDecl : MutableList<OneofDescriptorProto>? = null
            var reservedRange : MutableList<ReservedRange>? = null
            var reservedName : MutableList<String>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return DescriptorProto(name,
                        finishList(field),
                        finishList(nestedType),
                        finishList(enumType),
                        finishList(extensionRange),
                        finishList(extension),
                        options,
                        finishList(oneofDecl),
                        finishList(reservedRange),
                        finishList(reservedName),
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> field = (field ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.FieldDescriptorProto))
                        }
                    }
                    26 -> nestedType = (nestedType ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.DescriptorProto))
                        }
                    }
                    34 -> enumType = (enumType ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.EnumDescriptorProto))
                        }
                    }
                    42 -> extensionRange = (extensionRange ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.DescriptorProto.ExtensionRange))
                        }
                    }
                    50 -> extension = (extension ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.FieldDescriptorProto))
                        }
                    }
                    58 -> options = deserializer.readMessage(com.toasttab.protokt.MessageOptions)
                    66 -> oneofDecl = (oneofDecl ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.OneofDescriptorProto))
                        }
                    }
                    74 -> reservedRange = (reservedRange ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.DescriptorProto.ReservedRange))
                        }
                    }
                    82 -> reservedName = (reservedName ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {
                            add(deserializer.readString())
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: DescriptorProtoDsl.() -> Unit): DescriptorProto =
            DescriptorProtoDsl().apply(dsl).build()
    }

    @KtGeneratedMessage("google.protobuf.ExtensionRange")
    class ExtensionRange private constructor(
        val start: Int?,
        val end: Int?,
        val options: ExtensionRangeOptions?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (start != null) {
                result += sizeof(Tag(1)) + sizeof(Int32(start))
            }
            if (end != null) {
                result += sizeof(Tag(2)) + sizeof(Int32(end))
            }
            if (options != null) {
                result += sizeof(Tag(3)) + sizeof(options)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (start != null) {
                serializer.write(Tag(8)).write(Int32(start))
            }
            if (end != null) {
                serializer.write(Tag(16)).write(Int32(end))
            }
            if (options != null) {
                serializer.write(Tag(26)).write(options)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is ExtensionRange &&
                other.start == start &&
                other.end == end &&
                other.options == options &&
                other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + start.hashCode()
            result = 31 * result + end.hashCode()
            result = 31 * result + options.hashCode()
            return result
        }

        override fun toString(): String = "ExtensionRange(" +
                "start=$start, " +
                "end=$end, " +
                "options=$options" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: ExtensionRangeDsl.() -> Unit): ExtensionRange =
            ExtensionRange.Deserializer {
                start = this@ExtensionRange.start
                end = this@ExtensionRange.end
                options = this@ExtensionRange.options
                unknownFields = this@ExtensionRange.unknownFields
                dsl()
            }

        class ExtensionRangeDsl {
            var start: Int? = null

            var end: Int? = null

            var options: ExtensionRangeOptions? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): ExtensionRange = ExtensionRange(start,
                end,
                options,
                unknownFields)
        }

        companion object Deserializer : KtDeserializer<ExtensionRange>,
                (ExtensionRangeDsl.() -> Unit) -> ExtensionRange {
            override fun deserialize(deserializer: KtMessageDeserializer): ExtensionRange {
                var start : Int? = null
                var end : Int? = null
                var options : ExtensionRangeOptions? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return ExtensionRange(start,
                            end,
                            options,
                            UnknownFieldSet.from(unknownFields))
                        8 -> start = deserializer.readInt32()
                        16 -> end = deserializer.readInt32()
                        26 -> options =
                            deserializer.readMessage(com.toasttab.protokt.ExtensionRangeOptions)
                        else -> unknownFields = (unknownFields ?:
                        UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                        }
                    }
                }
            }

            override fun invoke(dsl: ExtensionRangeDsl.() -> Unit): ExtensionRange =
                ExtensionRangeDsl().apply(dsl).build()
        }
    }

    /**
     * Range of reserved tag numbers. Reserved tag numbers may not be used by fields or extension
     * ranges in the same message. Reserved ranges may not overlap.
     */
    @KtGeneratedMessage("google.protobuf.ReservedRange")
    class ReservedRange private constructor(
        val start: Int?,
        val end: Int?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (start != null) {
                result += sizeof(Tag(1)) + sizeof(Int32(start))
            }
            if (end != null) {
                result += sizeof(Tag(2)) + sizeof(Int32(end))
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (start != null) {
                serializer.write(Tag(8)).write(Int32(start))
            }
            if (end != null) {
                serializer.write(Tag(16)).write(Int32(end))
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is ReservedRange &&
                other.start == start &&
                other.end == end &&
                other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + start.hashCode()
            result = 31 * result + end.hashCode()
            return result
        }

        override fun toString(): String = "ReservedRange(" +
                "start=$start, " +
                "end=$end" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: ReservedRangeDsl.() -> Unit): ReservedRange =
            ReservedRange.Deserializer {
                start = this@ReservedRange.start
                end = this@ReservedRange.end
                unknownFields = this@ReservedRange.unknownFields
                dsl()
            }

        class ReservedRangeDsl {
            var start: Int? = null

            var end: Int? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): ReservedRange = ReservedRange(start,
                end,
                unknownFields)
        }

        companion object Deserializer : KtDeserializer<ReservedRange>,
                (ReservedRangeDsl.() -> Unit) -> ReservedRange {
            override fun deserialize(deserializer: KtMessageDeserializer): ReservedRange {
                var start : Int? = null
                var end : Int? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return ReservedRange(start,
                            end,
                            UnknownFieldSet.from(unknownFields))
                        8 -> start = deserializer.readInt32()
                        16 -> end = deserializer.readInt32()
                        else -> unknownFields = (unknownFields ?:
                        UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                        }
                    }
                }
            }

            override fun invoke(dsl: ReservedRangeDsl.() -> Unit): ReservedRange =
                ReservedRangeDsl().apply(dsl).build()
        }
    }
}

@KtGeneratedMessage("google.protobuf.ExtensionRangeOptions")
class ExtensionRangeOptions private constructor(
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ExtensionRangeOptions &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "ExtensionRangeOptions(" +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ExtensionRangeOptionsDsl.() -> Unit): ExtensionRangeOptions =
        ExtensionRangeOptions.Deserializer {
            uninterpretedOption = this@ExtensionRangeOptions.uninterpretedOption
            unknownFields = this@ExtensionRangeOptions.unknownFields
            dsl()
        }

    class ExtensionRangeOptionsDsl {
        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ExtensionRangeOptions =
            ExtensionRangeOptions(finishList(uninterpretedOption),
                unknownFields)
    }

    companion object Deserializer : KtDeserializer<ExtensionRangeOptions>,
            (ExtensionRangeOptionsDsl.() -> Unit) -> ExtensionRangeOptions {
        override fun deserialize(deserializer: KtMessageDeserializer):
                ExtensionRangeOptions {
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ExtensionRangeOptions(finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ExtensionRangeOptionsDsl.() -> Unit): ExtensionRangeOptions
                = ExtensionRangeOptionsDsl().apply(dsl).build()
    }
}

/**
 * Describes a field within a message.
 */
@KtGeneratedMessage("google.protobuf.FieldDescriptorProto")
class FieldDescriptorProto private constructor(
    val name: String?,
    /**
     * For extensions, this is the name of the type being extended.  It is resolved in the same
     * manner as type_name.
     */
    val extendee: String?,
    val number: Int?,
    val label: Label?,
    /**
     * If type_name is set, this need not be set.  If both this and type_name are set, this must be
     * one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     */
    val type: Type?,
    /**
     * For message and enum types, this is the name of the type.  If the name starts with a '.', it
     * is fully-qualified.  Otherwise, C++-like scoping rules are used to find the type (i.e. first the
     * nested types within this message are searched, then within the parent, on up to the root
     * namespace).
     */
    val typeName: String?,
    /**
     * For numeric types, contains the original text representation of the value. For booleans,
     * "true" or "false". For strings, contains the default text contents (not escaped in any way). For
     * bytes, contains the C escaped value.  All bytes >= 128 are escaped.
     */
    val defaultValue: String?,
    val options: FieldOptions?,
    /**
     * If set, gives the index of a oneof in the containing type's oneof_decl list.  This field is a
     * member of that oneof.
     */
    val oneofIndex: Int?,
    /**
     * JSON name of this field. The value is set by protocol compiler. If the user has set a
     * "json_name" option on this field, that option's value will be used. Otherwise, it's deduced from
     * the field's name by converting it to camelCase.
     */
    val jsonName: String?,
    /**
     * If true, this is a proto3 "optional". When a proto3 field is optional, it tracks presence
     * regardless of field type.
     *
     *  When proto3_optional is true, this field must be belong to a oneof to signal to old proto3
     * clients that presence is tracked for this field. This oneof is known as a "synthetic" oneof, and
     * this field must be its sole member (each proto3 optional field gets its own synthetic oneof).
     * Synthetic oneofs exist in the descriptor only, and do not generate any API. Synthetic oneofs
     * must be ordered after all "real" oneofs.
     *
     *  For message fields, proto3_optional doesn't create any semantic change, since non-repeated
     * message fields always track presence. However it still indicates the semantic detail of whether
     * the user wrote "optional" or not. This can be useful for round-tripping the .proto file. For
     * consistency we give message fields a synthetic oneof also, even though it is not required to
     * track presence. This is especially important because the parser can't tell if a field is a
     * message or an enum, so it must always create a synthetic oneof.
     *
     *  Proto2 optional fields do not set this flag, because they already indicate optional with
     * `LABEL_OPTIONAL`.
     */
    val proto3Optional: Boolean?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (extendee != null) {
            result += sizeof(Tag(2)) + sizeof(extendee)
        }
        if (number != null) {
            result += sizeof(Tag(3)) + sizeof(Int32(number))
        }
        if (label != null) {
            result += sizeof(Tag(4)) + sizeof(label)
        }
        if (type != null) {
            result += sizeof(Tag(5)) + sizeof(type)
        }
        if (typeName != null) {
            result += sizeof(Tag(6)) + sizeof(typeName)
        }
        if (defaultValue != null) {
            result += sizeof(Tag(7)) + sizeof(defaultValue)
        }
        if (options != null) {
            result += sizeof(Tag(8)) + sizeof(options)
        }
        if (oneofIndex != null) {
            result += sizeof(Tag(9)) + sizeof(Int32(oneofIndex))
        }
        if (jsonName != null) {
            result += sizeof(Tag(10)) + sizeof(jsonName)
        }
        if (proto3Optional != null) {
            result += sizeof(Tag(17)) + sizeof(proto3Optional)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (extendee != null) {
            serializer.write(Tag(18)).write(extendee)
        }
        if (number != null) {
            serializer.write(Tag(24)).write(Int32(number))
        }
        if (label != null) {
            serializer.write(Tag(32)).write(label)
        }
        if (type != null) {
            serializer.write(Tag(40)).write(type)
        }
        if (typeName != null) {
            serializer.write(Tag(50)).write(typeName)
        }
        if (defaultValue != null) {
            serializer.write(Tag(58)).write(defaultValue)
        }
        if (options != null) {
            serializer.write(Tag(66)).write(options)
        }
        if (oneofIndex != null) {
            serializer.write(Tag(72)).write(Int32(oneofIndex))
        }
        if (jsonName != null) {
            serializer.write(Tag(82)).write(jsonName)
        }
        if (proto3Optional != null) {
            serializer.write(Tag(136)).write(proto3Optional)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is FieldDescriptorProto &&
            other.name == name &&
            other.extendee == extendee &&
            other.number == number &&
            other.label == label &&
            other.type == type &&
            other.typeName == typeName &&
            other.defaultValue == defaultValue &&
            other.options == options &&
            other.oneofIndex == oneofIndex &&
            other.jsonName == jsonName &&
            other.proto3Optional == proto3Optional &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + extendee.hashCode()
        result = 31 * result + number.hashCode()
        result = 31 * result + label.hashCode()
        result = 31 * result + type.hashCode()
        result = 31 * result + typeName.hashCode()
        result = 31 * result + defaultValue.hashCode()
        result = 31 * result + options.hashCode()
        result = 31 * result + oneofIndex.hashCode()
        result = 31 * result + jsonName.hashCode()
        result = 31 * result + proto3Optional.hashCode()
        return result
    }

    override fun toString(): String = "FieldDescriptorProto(" +
            "name=$name, " +
            "extendee=$extendee, " +
            "number=$number, " +
            "label=$label, " +
            "type=$type, " +
            "typeName=$typeName, " +
            "defaultValue=$defaultValue, " +
            "options=$options, " +
            "oneofIndex=$oneofIndex, " +
            "jsonName=$jsonName, " +
            "proto3Optional=$proto3Optional" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: FieldDescriptorProtoDsl.() -> Unit): FieldDescriptorProto =
        FieldDescriptorProto.Deserializer {
            name = this@FieldDescriptorProto.name
            extendee = this@FieldDescriptorProto.extendee
            number = this@FieldDescriptorProto.number
            label = this@FieldDescriptorProto.label
            type = this@FieldDescriptorProto.type
            typeName = this@FieldDescriptorProto.typeName
            defaultValue = this@FieldDescriptorProto.defaultValue
            options = this@FieldDescriptorProto.options
            oneofIndex = this@FieldDescriptorProto.oneofIndex
            jsonName = this@FieldDescriptorProto.jsonName
            proto3Optional = this@FieldDescriptorProto.proto3Optional
            unknownFields = this@FieldDescriptorProto.unknownFields
            dsl()
        }

    class FieldDescriptorProtoDsl {
        var name: String? = null

        var extendee: String? = null

        var number: Int? = null

        var label: Label? = null

        var type: Type? = null

        var typeName: String? = null

        var defaultValue: String? = null

        var options: FieldOptions? = null

        var oneofIndex: Int? = null

        var jsonName: String? = null

        var proto3Optional: Boolean? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): FieldDescriptorProto = FieldDescriptorProto(name,
            extendee,
            number,
            label,
            type,
            typeName,
            defaultValue,
            options,
            oneofIndex,
            jsonName,
            proto3Optional,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<FieldDescriptorProto>,
            (FieldDescriptorProtoDsl.() -> Unit) -> FieldDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer): FieldDescriptorProto {
            var name : String? = null
            var extendee : String? = null
            var number : Int? = null
            var label : Label? = null
            var type : Type? = null
            var typeName : String? = null
            var defaultValue : String? = null
            var options : FieldOptions? = null
            var oneofIndex : Int? = null
            var jsonName : String? = null
            var proto3Optional : Boolean? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return FieldDescriptorProto(name,
                        extendee,
                        number,
                        label,
                        type,
                        typeName,
                        defaultValue,
                        options,
                        oneofIndex,
                        jsonName,
                        proto3Optional,
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> extendee = deserializer.readString()
                    24 -> number = deserializer.readInt32()
                    32 -> label =
                        deserializer.readEnum(com.toasttab.protokt.FieldDescriptorProto.Label)
                    40 -> type =
                        deserializer.readEnum(com.toasttab.protokt.FieldDescriptorProto.Type)
                    50 -> typeName = deserializer.readString()
                    58 -> defaultValue = deserializer.readString()
                    66 -> options = deserializer.readMessage(com.toasttab.protokt.FieldOptions)
                    72 -> oneofIndex = deserializer.readInt32()
                    82 -> jsonName = deserializer.readString()
                    136 -> proto3Optional = deserializer.readBool()
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: FieldDescriptorProtoDsl.() -> Unit): FieldDescriptorProto =
            FieldDescriptorProtoDsl().apply(dsl).build()
    }

    sealed class Type(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        /**
         * 0 is reserved for errors. Order is weird for historical reasons.
         */
        object DOUBLE : Type(1, "DOUBLE")

        object FLOAT : Type(2, "FLOAT")

        /**
         * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if negative values
         * are likely.
         */
        object INT64 : Type(3, "INT64")

        object UINT64 : Type(4, "UINT64")

        /**
         * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if negative values
         * are likely.
         */
        object INT32 : Type(5, "INT32")

        object FIXED64 : Type(6, "FIXED64")

        object FIXED32 : Type(7, "FIXED32")

        object BOOL : Type(8, "BOOL")

        object STRING : Type(9, "STRING")

        /**
         * Tag-delimited aggregate. Group type is deprecated and not supported in proto3. However,
         * Proto3 implementations should still be able to parse the group wire format and treat group
         * fields as unknown fields.
         */
        object GROUP : Type(10, "GROUP")

        object MESSAGE : Type(11, "MESSAGE")

        /**
         * New in version 2.
         */
        object BYTES : Type(12, "BYTES")

        object UINT32 : Type(13, "UINT32")

        object ENUM : Type(14, "ENUM")

        object SFIXED32 : Type(15, "SFIXED32")

        object SFIXED64 : Type(16, "SFIXED64")

        object SINT32 : Type(17, "SINT32")

        object SINT64 : Type(18, "SINT64")

        class UNRECOGNIZED(
            `value`: Int,
        ) : Type(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<Type> {
            override fun from(`value`: Int): Type = when (value) {
                1 -> DOUBLE
                2 -> FLOAT
                3 -> INT64
                4 -> UINT64
                5 -> INT32
                6 -> FIXED64
                7 -> FIXED32
                8 -> BOOL
                9 -> STRING
                10 -> GROUP
                11 -> MESSAGE
                12 -> BYTES
                13 -> UINT32
                14 -> ENUM
                15 -> SFIXED32
                16 -> SFIXED64
                17 -> SINT32
                18 -> SINT64
                else -> UNRECOGNIZED(value)
            }
        }
    }

    sealed class Label(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        /**
         * 0 is reserved for errors
         */
        object OPTIONAL : Label(1, "OPTIONAL")

        object REQUIRED : Label(2, "REQUIRED")

        object REPEATED : Label(3, "REPEATED")

        class UNRECOGNIZED(
            `value`: Int,
        ) : Label(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<Label> {
            override fun from(`value`: Int): Label = when (value) {
                1 -> OPTIONAL
                2 -> REQUIRED
                3 -> REPEATED
                else -> UNRECOGNIZED(value)
            }
        }
    }
}

/**
 * Describes a oneof.
 */
@KtGeneratedMessage("google.protobuf.OneofDescriptorProto")
class OneofDescriptorProto private constructor(
    val name: String?,
    val options: OneofOptions?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (options != null) {
            result += sizeof(Tag(2)) + sizeof(options)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (options != null) {
            serializer.write(Tag(18)).write(options)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is OneofDescriptorProto &&
            other.name == name &&
            other.options == options &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + options.hashCode()
        return result
    }

    override fun toString(): String = "OneofDescriptorProto(" +
            "name=$name, " +
            "options=$options" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: OneofDescriptorProtoDsl.() -> Unit): OneofDescriptorProto =
        OneofDescriptorProto.Deserializer {
            name = this@OneofDescriptorProto.name
            options = this@OneofDescriptorProto.options
            unknownFields = this@OneofDescriptorProto.unknownFields
            dsl()
        }

    class OneofDescriptorProtoDsl {
        var name: String? = null

        var options: OneofOptions? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): OneofDescriptorProto = OneofDescriptorProto(name,
            options,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<OneofDescriptorProto>,
            (OneofDescriptorProtoDsl.() -> Unit) -> OneofDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer): OneofDescriptorProto {
            var name : String? = null
            var options : OneofOptions? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return OneofDescriptorProto(name,
                        options,
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> options = deserializer.readMessage(com.toasttab.protokt.OneofOptions)
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: OneofDescriptorProtoDsl.() -> Unit): OneofDescriptorProto =
            OneofDescriptorProtoDsl().apply(dsl).build()
    }
}

/**
 * Describes an enum type.
 */
@KtGeneratedMessage("google.protobuf.EnumDescriptorProto")
class EnumDescriptorProto private constructor(
    val name: String?,
    val `value`: List<EnumValueDescriptorProto>,
    val options: EnumOptions?,
    /**
     * Range of reserved numeric values. Reserved numeric values may not be used by enum values in
     * the same enum declaration. Reserved ranges may not overlap.
     */
    val reservedRange: List<EnumReservedRange>,
    /**
     * Reserved enum value names, which may not be reused. A given name may only be reserved once.
     */
    val reservedName: List<String>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (value.isNotEmpty()) {
            result += (sizeof(Tag(2)) * value.size) + value.sumOf { sizeof(it) }
        }
        if (options != null) {
            result += sizeof(Tag(3)) + sizeof(options)
        }
        if (reservedRange.isNotEmpty()) {
            result += (sizeof(Tag(4)) * reservedRange.size) + reservedRange.sumOf { sizeof(it) }
        }
        if (reservedName.isNotEmpty()) {
            result += (sizeof(Tag(5)) * reservedName.size) + reservedName.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (value.isNotEmpty()) {
            value.forEach { serializer.write(Tag(18)).write(it) }
        }
        if (options != null) {
            serializer.write(Tag(26)).write(options)
        }
        if (reservedRange.isNotEmpty()) {
            reservedRange.forEach { serializer.write(Tag(34)).write(it) }
        }
        if (reservedName.isNotEmpty()) {
            reservedName.forEach { serializer.write(Tag(42)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is EnumDescriptorProto &&
            other.name == name &&
            other.value == value &&
            other.options == options &&
            other.reservedRange == reservedRange &&
            other.reservedName == reservedName &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + value.hashCode()
        result = 31 * result + options.hashCode()
        result = 31 * result + reservedRange.hashCode()
        result = 31 * result + reservedName.hashCode()
        return result
    }

    override fun toString(): String = "EnumDescriptorProto(" +
            "name=$name, " +
            "value=$value, " +
            "options=$options, " +
            "reservedRange=$reservedRange, " +
            "reservedName=$reservedName" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: EnumDescriptorProtoDsl.() -> Unit): EnumDescriptorProto =
        EnumDescriptorProto.Deserializer {
            name = this@EnumDescriptorProto.name
            value = this@EnumDescriptorProto.value
            options = this@EnumDescriptorProto.options
            reservedRange = this@EnumDescriptorProto.reservedRange
            reservedName = this@EnumDescriptorProto.reservedName
            unknownFields = this@EnumDescriptorProto.unknownFields
            dsl()
        }

    class EnumDescriptorProtoDsl {
        var name: String? = null

        var `value`: List<EnumValueDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var options: EnumOptions? = null

        var reservedRange: List<EnumReservedRange> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var reservedName: List<String> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): EnumDescriptorProto = EnumDescriptorProto(name,
            finishList(value),
            options,
            finishList(reservedRange),
            finishList(reservedName),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<EnumDescriptorProto>,
            (EnumDescriptorProtoDsl.() -> Unit) -> EnumDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer): EnumDescriptorProto {
            var name : String? = null
            var value : MutableList<EnumValueDescriptorProto>? = null
            var options : EnumOptions? = null
            var reservedRange : MutableList<EnumReservedRange>? = null
            var reservedName : MutableList<String>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return EnumDescriptorProto(name,
                        finishList(value),
                        options,
                        finishList(reservedRange),
                        finishList(reservedName),
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> value = (value ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.EnumValueDescriptorProto))
                        }
                    }
                    26 -> options = deserializer.readMessage(com.toasttab.protokt.EnumOptions)
                    34 -> reservedRange = (reservedRange ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.EnumDescriptorProto.EnumReservedRange))
                        }
                    }
                    42 -> reservedName = (reservedName ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {
                            add(deserializer.readString())
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: EnumDescriptorProtoDsl.() -> Unit): EnumDescriptorProto =
            EnumDescriptorProtoDsl().apply(dsl).build()
    }

    /**
     * Range of reserved numeric values. Reserved values may not be used by entries in the same
     * enum. Reserved ranges may not overlap.
     *
     *  Note that this is distinct from DescriptorProto.ReservedRange in that it is inclusive such
     * that it can appropriately represent the entire int32 domain.
     */
    @KtGeneratedMessage("google.protobuf.EnumReservedRange")
    class EnumReservedRange private constructor(
        val start: Int?,
        val end: Int?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (start != null) {
                result += sizeof(Tag(1)) + sizeof(Int32(start))
            }
            if (end != null) {
                result += sizeof(Tag(2)) + sizeof(Int32(end))
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (start != null) {
                serializer.write(Tag(8)).write(Int32(start))
            }
            if (end != null) {
                serializer.write(Tag(16)).write(Int32(end))
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is EnumReservedRange &&
                other.start == start &&
                other.end == end &&
                other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + start.hashCode()
            result = 31 * result + end.hashCode()
            return result
        }

        override fun toString(): String = "EnumReservedRange(" +
                "start=$start, " +
                "end=$end" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: EnumReservedRangeDsl.() -> Unit): EnumReservedRange =
            EnumReservedRange.Deserializer {
                start = this@EnumReservedRange.start
                end = this@EnumReservedRange.end
                unknownFields = this@EnumReservedRange.unknownFields
                dsl()
            }

        class EnumReservedRangeDsl {
            var start: Int? = null

            var end: Int? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): EnumReservedRange = EnumReservedRange(start,
                end,
                unknownFields)
        }

        companion object Deserializer : KtDeserializer<EnumReservedRange>,
                (EnumReservedRangeDsl.() -> Unit) -> EnumReservedRange {
            override fun deserialize(deserializer: KtMessageDeserializer):
                    EnumReservedRange {
                var start : Int? = null
                var end : Int? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return EnumReservedRange(start,
                            end,
                            UnknownFieldSet.from(unknownFields))
                        8 -> start = deserializer.readInt32()
                        16 -> end = deserializer.readInt32()
                        else -> unknownFields = (unknownFields ?:
                        UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                        }
                    }
                }
            }

            override fun invoke(dsl: EnumReservedRangeDsl.() -> Unit): EnumReservedRange =
                EnumReservedRangeDsl().apply(dsl).build()
        }
    }
}

/**
 * Describes a value within an enum.
 */
@KtGeneratedMessage("google.protobuf.EnumValueDescriptorProto")
class EnumValueDescriptorProto private constructor(
    val name: String?,
    val number: Int?,
    val options: EnumValueOptions?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (number != null) {
            result += sizeof(Tag(2)) + sizeof(Int32(number))
        }
        if (options != null) {
            result += sizeof(Tag(3)) + sizeof(options)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (number != null) {
            serializer.write(Tag(16)).write(Int32(number))
        }
        if (options != null) {
            serializer.write(Tag(26)).write(options)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is EnumValueDescriptorProto &&
            other.name == name &&
            other.number == number &&
            other.options == options &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + number.hashCode()
        result = 31 * result + options.hashCode()
        return result
    }

    override fun toString(): String = "EnumValueDescriptorProto(" +
            "name=$name, " +
            "number=$number, " +
            "options=$options" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: EnumValueDescriptorProtoDsl.() -> Unit): EnumValueDescriptorProto =
        EnumValueDescriptorProto.Deserializer {
            name = this@EnumValueDescriptorProto.name
            number = this@EnumValueDescriptorProto.number
            options = this@EnumValueDescriptorProto.options
            unknownFields = this@EnumValueDescriptorProto.unknownFields
            dsl()
        }

    class EnumValueDescriptorProtoDsl {
        var name: String? = null

        var number: Int? = null

        var options: EnumValueOptions? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): EnumValueDescriptorProto = EnumValueDescriptorProto(name,
            number,
            options,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<EnumValueDescriptorProto>,
            (EnumValueDescriptorProtoDsl.() -> Unit) -> EnumValueDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer):
                EnumValueDescriptorProto {
            var name : String? = null
            var number : Int? = null
            var options : EnumValueOptions? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return EnumValueDescriptorProto(name,
                        number,
                        options,
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    16 -> number = deserializer.readInt32()
                    26 -> options = deserializer.readMessage(com.toasttab.protokt.EnumValueOptions)
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: EnumValueDescriptorProtoDsl.() -> Unit):
                EnumValueDescriptorProto = EnumValueDescriptorProtoDsl().apply(dsl).build()
    }
}

/**
 * Describes a service.
 */
@KtGeneratedMessage("google.protobuf.ServiceDescriptorProto")
class ServiceDescriptorProto private constructor(
    val name: String?,
    val method: List<MethodDescriptorProto>,
    val options: ServiceOptions?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (method.isNotEmpty()) {
            result += (sizeof(Tag(2)) * method.size) + method.sumOf { sizeof(it) }
        }
        if (options != null) {
            result += sizeof(Tag(3)) + sizeof(options)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (method.isNotEmpty()) {
            method.forEach { serializer.write(Tag(18)).write(it) }
        }
        if (options != null) {
            serializer.write(Tag(26)).write(options)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ServiceDescriptorProto &&
            other.name == name &&
            other.method == method &&
            other.options == options &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + method.hashCode()
        result = 31 * result + options.hashCode()
        return result
    }

    override fun toString(): String = "ServiceDescriptorProto(" +
            "name=$name, " +
            "method=$method, " +
            "options=$options" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ServiceDescriptorProtoDsl.() -> Unit): ServiceDescriptorProto =
        ServiceDescriptorProto.Deserializer {
            name = this@ServiceDescriptorProto.name
            method = this@ServiceDescriptorProto.method
            options = this@ServiceDescriptorProto.options
            unknownFields = this@ServiceDescriptorProto.unknownFields
            dsl()
        }

    class ServiceDescriptorProtoDsl {
        var name: String? = null

        var method: List<MethodDescriptorProto> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var options: ServiceOptions? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ServiceDescriptorProto = ServiceDescriptorProto(name,
            finishList(method),
            options,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<ServiceDescriptorProto>,
            (ServiceDescriptorProtoDsl.() -> Unit) -> ServiceDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer):
                ServiceDescriptorProto {
            var name : String? = null
            var method : MutableList<MethodDescriptorProto>? = null
            var options : ServiceOptions? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ServiceDescriptorProto(name,
                        finishList(method),
                        options,
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> method = (method ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.MethodDescriptorProto))
                        }
                    }
                    26 -> options = deserializer.readMessage(com.toasttab.protokt.ServiceOptions)
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ServiceDescriptorProtoDsl.() -> Unit):
                ServiceDescriptorProto = ServiceDescriptorProtoDsl().apply(dsl).build()
    }
}

/**
 * Describes a method of a service.
 */
@KtGeneratedMessage("google.protobuf.MethodDescriptorProto")
class MethodDescriptorProto private constructor(
    val name: String?,
    /**
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     */
    val inputType: String?,
    val outputType: String?,
    val options: MethodOptions?,
    /**
     * Identifies if client streams multiple client messages
     */
    val clientStreaming: Boolean?,
    /**
     * Identifies if server streams multiple server messages
     */
    val serverStreaming: Boolean?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name != null) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (inputType != null) {
            result += sizeof(Tag(2)) + sizeof(inputType)
        }
        if (outputType != null) {
            result += sizeof(Tag(3)) + sizeof(outputType)
        }
        if (options != null) {
            result += sizeof(Tag(4)) + sizeof(options)
        }
        if (clientStreaming != null) {
            result += sizeof(Tag(5)) + sizeof(clientStreaming)
        }
        if (serverStreaming != null) {
            result += sizeof(Tag(6)) + sizeof(serverStreaming)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name != null) {
            serializer.write(Tag(10)).write(name)
        }
        if (inputType != null) {
            serializer.write(Tag(18)).write(inputType)
        }
        if (outputType != null) {
            serializer.write(Tag(26)).write(outputType)
        }
        if (options != null) {
            serializer.write(Tag(34)).write(options)
        }
        if (clientStreaming != null) {
            serializer.write(Tag(40)).write(clientStreaming)
        }
        if (serverStreaming != null) {
            serializer.write(Tag(48)).write(serverStreaming)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is MethodDescriptorProto &&
            other.name == name &&
            other.inputType == inputType &&
            other.outputType == outputType &&
            other.options == options &&
            other.clientStreaming == clientStreaming &&
            other.serverStreaming == serverStreaming &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + inputType.hashCode()
        result = 31 * result + outputType.hashCode()
        result = 31 * result + options.hashCode()
        result = 31 * result + clientStreaming.hashCode()
        result = 31 * result + serverStreaming.hashCode()
        return result
    }

    override fun toString(): String = "MethodDescriptorProto(" +
            "name=$name, " +
            "inputType=$inputType, " +
            "outputType=$outputType, " +
            "options=$options, " +
            "clientStreaming=$clientStreaming, " +
            "serverStreaming=$serverStreaming" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: MethodDescriptorProtoDsl.() -> Unit): MethodDescriptorProto =
        MethodDescriptorProto.Deserializer {
            name = this@MethodDescriptorProto.name
            inputType = this@MethodDescriptorProto.inputType
            outputType = this@MethodDescriptorProto.outputType
            options = this@MethodDescriptorProto.options
            clientStreaming = this@MethodDescriptorProto.clientStreaming
            serverStreaming = this@MethodDescriptorProto.serverStreaming
            unknownFields = this@MethodDescriptorProto.unknownFields
            dsl()
        }

    class MethodDescriptorProtoDsl {
        var name: String? = null

        var inputType: String? = null

        var outputType: String? = null

        var options: MethodOptions? = null

        var clientStreaming: Boolean? = null

        var serverStreaming: Boolean? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): MethodDescriptorProto = MethodDescriptorProto(name,
            inputType,
            outputType,
            options,
            clientStreaming,
            serverStreaming,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<MethodDescriptorProto>,
            (MethodDescriptorProtoDsl.() -> Unit) -> MethodDescriptorProto {
        override fun deserialize(deserializer: KtMessageDeserializer):
                MethodDescriptorProto {
            var name : String? = null
            var inputType : String? = null
            var outputType : String? = null
            var options : MethodOptions? = null
            var clientStreaming : Boolean? = null
            var serverStreaming : Boolean? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return MethodDescriptorProto(name,
                        inputType,
                        outputType,
                        options,
                        clientStreaming,
                        serverStreaming,
                        UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> inputType = deserializer.readString()
                    26 -> outputType = deserializer.readString()
                    34 -> options = deserializer.readMessage(com.toasttab.protokt.MethodOptions)
                    40 -> clientStreaming = deserializer.readBool()
                    48 -> serverStreaming = deserializer.readBool()
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: MethodDescriptorProtoDsl.() -> Unit): MethodDescriptorProto
                = MethodDescriptorProtoDsl().apply(dsl).build()
    }
}

@KtGeneratedMessage("google.protobuf.FileOptions")
@Suppress("DEPRECATION")
class FileOptions private constructor(
    /**
     * Sets the Java package where classes generated from this .proto will be placed.  By default,
     * the proto package is used, but this is often inappropriate because proto packages do not
     * normally start with backwards domain names.
     */
    val javaPackage: String?,
    /**
     * Controls the name of the wrapper Java class generated for the .proto file. That class will
     * always contain the .proto file's getDescriptor() method as well as any top-level extensions
     * defined in the .proto file. If java_multiple_files is disabled, then all the other classes from
     * the .proto file will be nested inside the single wrapper outer class.
     */
    val javaOuterClassname: String?,
    val optimizeFor: OptimizeMode?,
    /**
     * If enabled, then the Java code generator will generate a separate .java file for each
     * top-level message, enum, and service defined in the .proto file.  Thus, these types will *not*
     * be nested inside the wrapper class named by java_outer_classname.  However, the wrapper class
     * will still be generated to contain the file's getDescriptor() method as well as any top-level
     * extensions defined in the file.
     */
    val javaMultipleFiles: Boolean?,
    /**
     * Sets the Go package where structs generated from this .proto will be placed. If omitted, the
     * Go package will be derived from the following:   - The basename of the package import path, if
     * provided.   - Otherwise, the package statement in the .proto file, if present.   - Otherwise,
     * the basename of the .proto file, without extension.
     */
    val goPackage: String?,
    /**
     * Should generic services be generated in each language?  "Generic" services are not specific
     * to any particular RPC system.  They are generated by the main code generators in each language
     * (without additional plugins). Generic services were the only kind of service generation
     * supported by early versions of google.protobuf.
     *
     *  Generic services are now considered deprecated in favor of using plugins that generate code
     * specific to your particular RPC system.  Therefore, these default to false.  Old code which
     * depends on generic services should explicitly set them to true.
     */
    val ccGenericServices: Boolean?,
    val javaGenericServices: Boolean?,
    val pyGenericServices: Boolean?,
    /**
     * This option does nothing.
     */
    @Deprecated("deprecated in proto")
    val javaGenerateEqualsAndHash: Boolean?,
    /**
     * Is this file deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for everything in the file, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating files.
     */
    val deprecated: Boolean?,
    /**
     * If set true, then the Java2 code generator will generate code that throws an exception
     * whenever an attempt is made to assign a non-UTF-8 byte sequence to a string field. Message
     * reflection will do the same. However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     */
    val javaStringCheckUtf8: Boolean?,
    /**
     * Enables the use of arenas for the proto messages in this file. This applies only to generated
     * classes for C++.
     */
    val ccEnableArenas: Boolean?,
    /**
     * Sets the objective c class prefix which is prepended to all objective c generated classes
     * from this .proto. There is no default.
     */
    val objcClassPrefix: String?,
    /**
     * Namespace for generated classes; defaults to the package.
     */
    val csharpNamespace: String?,
    /**
     * By default Swift generators will take the proto package and CamelCase it replacing '.' with
     * underscore and use that to prefix the types/symbols defined. When this options is provided, they
     * will use this value instead to prefix the types/symbols defined.
     */
    val swiftPrefix: String?,
    /**
     * Sets the php class prefix which is prepended to all php generated classes from this .proto.
     * Default is empty.
     */
    val phpClassPrefix: String?,
    /**
     * Use this option to change the namespace of php generated classes. Default is empty. When this
     * option is empty, the package name will be used for determining the namespace.
     */
    val phpNamespace: String?,
    val phpGenericServices: Boolean?,
    /**
     * Use this option to change the namespace of php generated metadata classes. Default is empty.
     * When this option is empty, the proto file name will be used for determining the namespace.
     */
    val phpMetadataNamespace: String?,
    /**
     * Use this option to change the package of ruby generated classes. Default is empty. When this
     * option is not set, the package name will be used for determining the ruby package.
     */
    val rubyPackage: String?,
    /**
     * The parser stores options it doesn't recognize here. See the documentation for the "Options"
     * section above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (javaPackage != null) {
            result += sizeof(Tag(1)) + sizeof(javaPackage)
        }
        if (javaOuterClassname != null) {
            result += sizeof(Tag(8)) + sizeof(javaOuterClassname)
        }
        if (optimizeFor != null) {
            result += sizeof(Tag(9)) + sizeof(optimizeFor)
        }
        if (javaMultipleFiles != null) {
            result += sizeof(Tag(10)) + sizeof(javaMultipleFiles)
        }
        if (goPackage != null) {
            result += sizeof(Tag(11)) + sizeof(goPackage)
        }
        if (ccGenericServices != null) {
            result += sizeof(Tag(16)) + sizeof(ccGenericServices)
        }
        if (javaGenericServices != null) {
            result += sizeof(Tag(17)) + sizeof(javaGenericServices)
        }
        if (pyGenericServices != null) {
            result += sizeof(Tag(18)) + sizeof(pyGenericServices)
        }
        if (javaGenerateEqualsAndHash != null) {
            result += sizeof(Tag(20)) + sizeof(javaGenerateEqualsAndHash)
        }
        if (deprecated != null) {
            result += sizeof(Tag(23)) + sizeof(deprecated)
        }
        if (javaStringCheckUtf8 != null) {
            result += sizeof(Tag(27)) + sizeof(javaStringCheckUtf8)
        }
        if (ccEnableArenas != null) {
            result += sizeof(Tag(31)) + sizeof(ccEnableArenas)
        }
        if (objcClassPrefix != null) {
            result += sizeof(Tag(36)) + sizeof(objcClassPrefix)
        }
        if (csharpNamespace != null) {
            result += sizeof(Tag(37)) + sizeof(csharpNamespace)
        }
        if (swiftPrefix != null) {
            result += sizeof(Tag(39)) + sizeof(swiftPrefix)
        }
        if (phpClassPrefix != null) {
            result += sizeof(Tag(40)) + sizeof(phpClassPrefix)
        }
        if (phpNamespace != null) {
            result += sizeof(Tag(41)) + sizeof(phpNamespace)
        }
        if (phpGenericServices != null) {
            result += sizeof(Tag(42)) + sizeof(phpGenericServices)
        }
        if (phpMetadataNamespace != null) {
            result += sizeof(Tag(44)) + sizeof(phpMetadataNamespace)
        }
        if (rubyPackage != null) {
            result += sizeof(Tag(45)) + sizeof(rubyPackage)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (javaPackage != null) {
            serializer.write(Tag(10)).write(javaPackage)
        }
        if (javaOuterClassname != null) {
            serializer.write(Tag(66)).write(javaOuterClassname)
        }
        if (optimizeFor != null) {
            serializer.write(Tag(72)).write(optimizeFor)
        }
        if (javaMultipleFiles != null) {
            serializer.write(Tag(80)).write(javaMultipleFiles)
        }
        if (goPackage != null) {
            serializer.write(Tag(90)).write(goPackage)
        }
        if (ccGenericServices != null) {
            serializer.write(Tag(128)).write(ccGenericServices)
        }
        if (javaGenericServices != null) {
            serializer.write(Tag(136)).write(javaGenericServices)
        }
        if (pyGenericServices != null) {
            serializer.write(Tag(144)).write(pyGenericServices)
        }
        if (javaGenerateEqualsAndHash != null) {
            serializer.write(Tag(160)).write(javaGenerateEqualsAndHash)
        }
        if (deprecated != null) {
            serializer.write(Tag(184)).write(deprecated)
        }
        if (javaStringCheckUtf8 != null) {
            serializer.write(Tag(216)).write(javaStringCheckUtf8)
        }
        if (ccEnableArenas != null) {
            serializer.write(Tag(248)).write(ccEnableArenas)
        }
        if (objcClassPrefix != null) {
            serializer.write(Tag(290)).write(objcClassPrefix)
        }
        if (csharpNamespace != null) {
            serializer.write(Tag(298)).write(csharpNamespace)
        }
        if (swiftPrefix != null) {
            serializer.write(Tag(314)).write(swiftPrefix)
        }
        if (phpClassPrefix != null) {
            serializer.write(Tag(322)).write(phpClassPrefix)
        }
        if (phpNamespace != null) {
            serializer.write(Tag(330)).write(phpNamespace)
        }
        if (phpGenericServices != null) {
            serializer.write(Tag(336)).write(phpGenericServices)
        }
        if (phpMetadataNamespace != null) {
            serializer.write(Tag(354)).write(phpMetadataNamespace)
        }
        if (rubyPackage != null) {
            serializer.write(Tag(362)).write(rubyPackage)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is FileOptions &&
            other.javaPackage == javaPackage &&
            other.javaOuterClassname == javaOuterClassname &&
            other.optimizeFor == optimizeFor &&
            other.javaMultipleFiles == javaMultipleFiles &&
            other.goPackage == goPackage &&
            other.ccGenericServices == ccGenericServices &&
            other.javaGenericServices == javaGenericServices &&
            other.pyGenericServices == pyGenericServices &&
            other.javaGenerateEqualsAndHash == javaGenerateEqualsAndHash &&
            other.deprecated == deprecated &&
            other.javaStringCheckUtf8 == javaStringCheckUtf8 &&
            other.ccEnableArenas == ccEnableArenas &&
            other.objcClassPrefix == objcClassPrefix &&
            other.csharpNamespace == csharpNamespace &&
            other.swiftPrefix == swiftPrefix &&
            other.phpClassPrefix == phpClassPrefix &&
            other.phpNamespace == phpNamespace &&
            other.phpGenericServices == phpGenericServices &&
            other.phpMetadataNamespace == phpMetadataNamespace &&
            other.rubyPackage == rubyPackage &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + javaPackage.hashCode()
        result = 31 * result + javaOuterClassname.hashCode()
        result = 31 * result + optimizeFor.hashCode()
        result = 31 * result + javaMultipleFiles.hashCode()
        result = 31 * result + goPackage.hashCode()
        result = 31 * result + ccGenericServices.hashCode()
        result = 31 * result + javaGenericServices.hashCode()
        result = 31 * result + pyGenericServices.hashCode()
        result = 31 * result + javaGenerateEqualsAndHash.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + javaStringCheckUtf8.hashCode()
        result = 31 * result + ccEnableArenas.hashCode()
        result = 31 * result + objcClassPrefix.hashCode()
        result = 31 * result + csharpNamespace.hashCode()
        result = 31 * result + swiftPrefix.hashCode()
        result = 31 * result + phpClassPrefix.hashCode()
        result = 31 * result + phpNamespace.hashCode()
        result = 31 * result + phpGenericServices.hashCode()
        result = 31 * result + phpMetadataNamespace.hashCode()
        result = 31 * result + rubyPackage.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "FileOptions(" +
            "javaPackage=$javaPackage, " +
            "javaOuterClassname=$javaOuterClassname, " +
            "optimizeFor=$optimizeFor, " +
            "javaMultipleFiles=$javaMultipleFiles, " +
            "goPackage=$goPackage, " +
            "ccGenericServices=$ccGenericServices, " +
            "javaGenericServices=$javaGenericServices, " +
            "pyGenericServices=$pyGenericServices, " +
            "javaGenerateEqualsAndHash=$javaGenerateEqualsAndHash, " +
            "deprecated=$deprecated, " +
            "javaStringCheckUtf8=$javaStringCheckUtf8, " +
            "ccEnableArenas=$ccEnableArenas, " +
            "objcClassPrefix=$objcClassPrefix, " +
            "csharpNamespace=$csharpNamespace, " +
            "swiftPrefix=$swiftPrefix, " +
            "phpClassPrefix=$phpClassPrefix, " +
            "phpNamespace=$phpNamespace, " +
            "phpGenericServices=$phpGenericServices, " +
            "phpMetadataNamespace=$phpMetadataNamespace, " +
            "rubyPackage=$rubyPackage, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: FileOptionsDsl.() -> Unit): FileOptions = FileOptions.Deserializer {
        javaPackage = this@FileOptions.javaPackage
        javaOuterClassname = this@FileOptions.javaOuterClassname
        optimizeFor = this@FileOptions.optimizeFor
        javaMultipleFiles = this@FileOptions.javaMultipleFiles
        goPackage = this@FileOptions.goPackage
        ccGenericServices = this@FileOptions.ccGenericServices
        javaGenericServices = this@FileOptions.javaGenericServices
        pyGenericServices = this@FileOptions.pyGenericServices
        javaGenerateEqualsAndHash = this@FileOptions.javaGenerateEqualsAndHash
        deprecated = this@FileOptions.deprecated
        javaStringCheckUtf8 = this@FileOptions.javaStringCheckUtf8
        ccEnableArenas = this@FileOptions.ccEnableArenas
        objcClassPrefix = this@FileOptions.objcClassPrefix
        csharpNamespace = this@FileOptions.csharpNamespace
        swiftPrefix = this@FileOptions.swiftPrefix
        phpClassPrefix = this@FileOptions.phpClassPrefix
        phpNamespace = this@FileOptions.phpNamespace
        phpGenericServices = this@FileOptions.phpGenericServices
        phpMetadataNamespace = this@FileOptions.phpMetadataNamespace
        rubyPackage = this@FileOptions.rubyPackage
        uninterpretedOption = this@FileOptions.uninterpretedOption
        unknownFields = this@FileOptions.unknownFields
        dsl()
    }

    class FileOptionsDsl {
        var javaPackage: String? = null

        var javaOuterClassname: String? = null

        var optimizeFor: OptimizeMode? = null

        var javaMultipleFiles: Boolean? = null

        var goPackage: String? = null

        var ccGenericServices: Boolean? = null

        var javaGenericServices: Boolean? = null

        var pyGenericServices: Boolean? = null

        @Deprecated("deprecated in proto")
        var javaGenerateEqualsAndHash: Boolean? = null

        var deprecated: Boolean? = null

        var javaStringCheckUtf8: Boolean? = null

        var ccEnableArenas: Boolean? = null

        var objcClassPrefix: String? = null

        var csharpNamespace: String? = null

        var swiftPrefix: String? = null

        var phpClassPrefix: String? = null

        var phpNamespace: String? = null

        var phpGenericServices: Boolean? = null

        var phpMetadataNamespace: String? = null

        var rubyPackage: String? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): FileOptions = FileOptions(javaPackage,
            javaOuterClassname,
            optimizeFor,
            javaMultipleFiles,
            goPackage,
            ccGenericServices,
            javaGenericServices,
            pyGenericServices,
            javaGenerateEqualsAndHash,
            deprecated,
            javaStringCheckUtf8,
            ccEnableArenas,
            objcClassPrefix,
            csharpNamespace,
            swiftPrefix,
            phpClassPrefix,
            phpNamespace,
            phpGenericServices,
            phpMetadataNamespace,
            rubyPackage,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<FileOptions>,
            (FileOptionsDsl.() -> Unit) -> FileOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): FileOptions {
            var javaPackage : String? = null
            var javaOuterClassname : String? = null
            var optimizeFor : OptimizeMode? = null
            var javaMultipleFiles : Boolean? = null
            var goPackage : String? = null
            var ccGenericServices : Boolean? = null
            var javaGenericServices : Boolean? = null
            var pyGenericServices : Boolean? = null
            var javaGenerateEqualsAndHash : Boolean? = null
            var deprecated : Boolean? = null
            var javaStringCheckUtf8 : Boolean? = null
            var ccEnableArenas : Boolean? = null
            var objcClassPrefix : String? = null
            var csharpNamespace : String? = null
            var swiftPrefix : String? = null
            var phpClassPrefix : String? = null
            var phpNamespace : String? = null
            var phpGenericServices : Boolean? = null
            var phpMetadataNamespace : String? = null
            var rubyPackage : String? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return FileOptions(javaPackage,
                        javaOuterClassname,
                        optimizeFor,
                        javaMultipleFiles,
                        goPackage,
                        ccGenericServices,
                        javaGenericServices,
                        pyGenericServices,
                        javaGenerateEqualsAndHash,
                        deprecated,
                        javaStringCheckUtf8,
                        ccEnableArenas,
                        objcClassPrefix,
                        csharpNamespace,
                        swiftPrefix,
                        phpClassPrefix,
                        phpNamespace,
                        phpGenericServices,
                        phpMetadataNamespace,
                        rubyPackage,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    10 -> javaPackage = deserializer.readString()
                    66 -> javaOuterClassname = deserializer.readString()
                    72 -> optimizeFor =
                        deserializer.readEnum(com.toasttab.protokt.FileOptions.OptimizeMode)
                    80 -> javaMultipleFiles = deserializer.readBool()
                    90 -> goPackage = deserializer.readString()
                    128 -> ccGenericServices = deserializer.readBool()
                    136 -> javaGenericServices = deserializer.readBool()
                    144 -> pyGenericServices = deserializer.readBool()
                    160 -> javaGenerateEqualsAndHash = deserializer.readBool()
                    184 -> deprecated = deserializer.readBool()
                    216 -> javaStringCheckUtf8 = deserializer.readBool()
                    248 -> ccEnableArenas = deserializer.readBool()
                    290 -> objcClassPrefix = deserializer.readString()
                    298 -> csharpNamespace = deserializer.readString()
                    314 -> swiftPrefix = deserializer.readString()
                    322 -> phpClassPrefix = deserializer.readString()
                    330 -> phpNamespace = deserializer.readString()
                    336 -> phpGenericServices = deserializer.readBool()
                    354 -> phpMetadataNamespace = deserializer.readString()
                    362 -> rubyPackage = deserializer.readString()
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: FileOptionsDsl.() -> Unit): FileOptions =
            FileOptionsDsl().apply(dsl).build()
    }

    /**
     * Generated classes can be optimized for speed or code size.
     */
    sealed class OptimizeMode(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        object SPEED : OptimizeMode(1, "SPEED")

        /**
         * etc.
         */
        object CODE_SIZE : OptimizeMode(2, "CODE_SIZE")

        object LITE_RUNTIME : OptimizeMode(3, "LITE_RUNTIME")

        class UNRECOGNIZED(
            `value`: Int,
        ) : OptimizeMode(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<OptimizeMode> {
            override fun from(`value`: Int): OptimizeMode = when (value) {
                1 -> SPEED
                2 -> CODE_SIZE
                3 -> LITE_RUNTIME
                else -> UNRECOGNIZED(value)
            }
        }
    }
}

@KtGeneratedMessage("google.protobuf.MessageOptions")
class MessageOptions private constructor(
    /**
     * Set true to use the old proto1 MessageSet wire format for extensions. This is provided for
     * backwards-compatibility with the MessageSet wire format.  You should not use this for any other
     * reason:  It's less efficient, has fewer features, and is more complicated.
     *
     *  The message must be defined exactly as follows:   message Foo {     option
     * message_set_wire_format = true;     extensions 4 to max;   } Note that the message cannot have
     * any defined fields; MessageSets only have extensions.
     *
     *  All extensions of your type must be singular messages; e.g. they cannot be int32s, enums, or
     * repeated messages.
     *
     *  Because this is an option, the above two restrictions are not enforced by the protocol
     * compiler.
     */
    val messageSetWireFormat: Boolean?,
    /**
     * Disables the generation of the standard "descriptor()" accessor, which can conflict with a
     * field of the same name.  This is meant to make migration from proto1 easier; new code should
     * avoid fields named "descriptor".
     */
    val noStandardDescriptorAccessor: Boolean?,
    /**
     * Is this message deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for the message, or it will be completely ignored; in the very least, this is a
     * formalization for deprecating messages.
     */
    val deprecated: Boolean?,
    /**
     * Whether the message is an automatically generated map entry type for the maps field.
     *
     *  For maps fields:     map<KeyType, ValueType> map_field = 1; The parsed descriptor looks
     * like:     message MapFieldEntry {         option map_entry = true;         optional KeyType key
     * = 1;         optional ValueType value = 2;     }     repeated MapFieldEntry map_field = 1;
     *
     *  Implementations may choose not to generate the map_entry=true message, but use a native map
     * in the target language to hold the keys and values. The reflection APIs in such implementations
     * still need to work as if the field is a repeated message field.
     *
     *  NOTE: Do not set the option in .proto files. Always use the maps syntax instead. The option
     * should only be implicitly set by the proto compiler parser.
     */
    val mapEntry: Boolean?,
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (messageSetWireFormat != null) {
            result += sizeof(Tag(1)) + sizeof(messageSetWireFormat)
        }
        if (noStandardDescriptorAccessor != null) {
            result += sizeof(Tag(2)) + sizeof(noStandardDescriptorAccessor)
        }
        if (deprecated != null) {
            result += sizeof(Tag(3)) + sizeof(deprecated)
        }
        if (mapEntry != null) {
            result += sizeof(Tag(7)) + sizeof(mapEntry)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (messageSetWireFormat != null) {
            serializer.write(Tag(8)).write(messageSetWireFormat)
        }
        if (noStandardDescriptorAccessor != null) {
            serializer.write(Tag(16)).write(noStandardDescriptorAccessor)
        }
        if (deprecated != null) {
            serializer.write(Tag(24)).write(deprecated)
        }
        if (mapEntry != null) {
            serializer.write(Tag(56)).write(mapEntry)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is MessageOptions &&
            other.messageSetWireFormat == messageSetWireFormat &&
            other.noStandardDescriptorAccessor == noStandardDescriptorAccessor &&
            other.deprecated == deprecated &&
            other.mapEntry == mapEntry &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + messageSetWireFormat.hashCode()
        result = 31 * result + noStandardDescriptorAccessor.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + mapEntry.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "MessageOptions(" +
            "messageSetWireFormat=$messageSetWireFormat, " +
            "noStandardDescriptorAccessor=$noStandardDescriptorAccessor, " +
            "deprecated=$deprecated, " +
            "mapEntry=$mapEntry, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: MessageOptionsDsl.() -> Unit): MessageOptions =
        MessageOptions.Deserializer {
            messageSetWireFormat = this@MessageOptions.messageSetWireFormat
            noStandardDescriptorAccessor = this@MessageOptions.noStandardDescriptorAccessor
            deprecated = this@MessageOptions.deprecated
            mapEntry = this@MessageOptions.mapEntry
            uninterpretedOption = this@MessageOptions.uninterpretedOption
            unknownFields = this@MessageOptions.unknownFields
            dsl()
        }

    class MessageOptionsDsl {
        var messageSetWireFormat: Boolean? = null

        var noStandardDescriptorAccessor: Boolean? = null

        var deprecated: Boolean? = null

        var mapEntry: Boolean? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): MessageOptions = MessageOptions(messageSetWireFormat,
            noStandardDescriptorAccessor,
            deprecated,
            mapEntry,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<MessageOptions>,
            (MessageOptionsDsl.() -> Unit) -> MessageOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): MessageOptions {
            var messageSetWireFormat : Boolean? = null
            var noStandardDescriptorAccessor : Boolean? = null
            var deprecated : Boolean? = null
            var mapEntry : Boolean? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return MessageOptions(messageSetWireFormat,
                        noStandardDescriptorAccessor,
                        deprecated,
                        mapEntry,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    8 -> messageSetWireFormat = deserializer.readBool()
                    16 -> noStandardDescriptorAccessor = deserializer.readBool()
                    24 -> deprecated = deserializer.readBool()
                    56 -> mapEntry = deserializer.readBool()
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: MessageOptionsDsl.() -> Unit): MessageOptions =
            MessageOptionsDsl().apply(dsl).build()
    }
}

@KtGeneratedMessage("google.protobuf.FieldOptions")
class FieldOptions private constructor(
    /**
     * The ctype option instructs the C++ code generator to use a different representation of the
     * field than it normally would.  See the specific options below.  This option is not yet
     * implemented in the open source release -- sorry, we'll try to include it in a future version!
     */
    val ctype: CType?,
    /**
     * The packed option can be enabled for repeated primitive fields to enable a more efficient
     * representation on the wire. Rather than repeatedly writing the tag and type for each element,
     * the entire array is encoded as a single length-delimited blob. In proto3, only explicit setting
     * it to false will avoid using packed encoding.
     */
    val packed: Boolean?,
    /**
     * Is this field deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for accessors, or it will be completely ignored; in the very least, this is a
     * formalization for deprecating fields.
     */
    val deprecated: Boolean?,
    /**
     * Should this field be parsed lazily?  Lazy applies only to message-type fields.  It means that
     * when the outer message is initially parsed, the inner message's contents will not be parsed but
     * instead stored in encoded form.  The inner message will actually be parsed when it is first
     * accessed.
     *
     *  This is only a hint.  Implementations are free to choose whether to use eager or lazy
     * parsing regardless of the value of this option.  However, setting this option true suggests that
     * the protocol author believes that using lazy parsing on this field is worth the additional
     * bookkeeping overhead typically needed to implement it.
     *
     *  This option does not affect the public interface of any generated code; all method
     * signatures remain the same.  Furthermore, thread-safety of the interface is not affected by this
     * option; const methods remain safe to call from multiple threads concurrently, while non-const
     * methods continue to require exclusive access.
     *
     *
     *
     *  Note that implementations may choose not to check required fields within a lazy sub-message.
     *  That is, calling IsInitialized() on the outer message may return true even if the inner message
     * has missing required fields. This is necessary because otherwise the inner message would have to
     * be parsed in order to perform the check, defeating the purpose of lazy parsing.  An
     * implementation which chooses not to check required fields must be consistent about it.  That is,
     * for any particular sub-message, the implementation must either *always* check its required
     * fields, or *never* check its required fields, regardless of whether or not the message has been
     * parsed.
     *
     *  As of 2021, lazy does no correctness checks on the byte stream during parsing.  This may
     * lead to crashes if and when an invalid byte stream is finally parsed upon access.
     *
     *  TODO(b/211906113):  Enable validation on lazy fields.
     */
    val lazy: Boolean?,
    /**
     * The jstype option determines the JavaScript type used for values of the field.  The option is
     * permitted only for 64 bit integral and fixed types (int64, uint64, sint64, fixed64, sfixed64).
     * A field with jstype JS_STRING is represented as JavaScript string, which avoids loss of
     * precision that can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to use the JavaScript
     * "number" type.  The behavior of the default option JS_NORMAL is implementation dependent.
     *
     *  This option is an enum to permit additional types to be added, e.g. goog.math.Integer.
     */
    val jstype: JSType?,
    /**
     * For Google-internal migration only. Do not use.
     */
    val weak: Boolean?,
    /**
     * unverified_lazy does no correctness checks on the byte stream. This should only be used where
     * lazy with verification is prohibitive for performance reasons.
     */
    val unverifiedLazy: Boolean?,
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (ctype != null) {
            result += sizeof(Tag(1)) + sizeof(ctype)
        }
        if (packed != null) {
            result += sizeof(Tag(2)) + sizeof(packed)
        }
        if (deprecated != null) {
            result += sizeof(Tag(3)) + sizeof(deprecated)
        }
        if (lazy != null) {
            result += sizeof(Tag(5)) + sizeof(lazy)
        }
        if (jstype != null) {
            result += sizeof(Tag(6)) + sizeof(jstype)
        }
        if (weak != null) {
            result += sizeof(Tag(10)) + sizeof(weak)
        }
        if (unverifiedLazy != null) {
            result += sizeof(Tag(15)) + sizeof(unverifiedLazy)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (ctype != null) {
            serializer.write(Tag(8)).write(ctype)
        }
        if (packed != null) {
            serializer.write(Tag(16)).write(packed)
        }
        if (deprecated != null) {
            serializer.write(Tag(24)).write(deprecated)
        }
        if (lazy != null) {
            serializer.write(Tag(40)).write(lazy)
        }
        if (jstype != null) {
            serializer.write(Tag(48)).write(jstype)
        }
        if (weak != null) {
            serializer.write(Tag(80)).write(weak)
        }
        if (unverifiedLazy != null) {
            serializer.write(Tag(120)).write(unverifiedLazy)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is FieldOptions &&
            other.ctype == ctype &&
            other.packed == packed &&
            other.deprecated == deprecated &&
            other.lazy == lazy &&
            other.jstype == jstype &&
            other.weak == weak &&
            other.unverifiedLazy == unverifiedLazy &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + ctype.hashCode()
        result = 31 * result + packed.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + lazy.hashCode()
        result = 31 * result + jstype.hashCode()
        result = 31 * result + weak.hashCode()
        result = 31 * result + unverifiedLazy.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "FieldOptions(" +
            "ctype=$ctype, " +
            "packed=$packed, " +
            "deprecated=$deprecated, " +
            "lazy=$lazy, " +
            "jstype=$jstype, " +
            "weak=$weak, " +
            "unverifiedLazy=$unverifiedLazy, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: FieldOptionsDsl.() -> Unit): FieldOptions = FieldOptions.Deserializer {
        ctype = this@FieldOptions.ctype
        packed = this@FieldOptions.packed
        deprecated = this@FieldOptions.deprecated
        lazy = this@FieldOptions.lazy
        jstype = this@FieldOptions.jstype
        weak = this@FieldOptions.weak
        unverifiedLazy = this@FieldOptions.unverifiedLazy
        uninterpretedOption = this@FieldOptions.uninterpretedOption
        unknownFields = this@FieldOptions.unknownFields
        dsl()
    }

    class FieldOptionsDsl {
        var ctype: CType? = null

        var packed: Boolean? = null

        var deprecated: Boolean? = null

        var lazy: Boolean? = null

        var jstype: JSType? = null

        var weak: Boolean? = null

        var unverifiedLazy: Boolean? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): FieldOptions = FieldOptions(ctype,
            packed,
            deprecated,
            lazy,
            jstype,
            weak,
            unverifiedLazy,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<FieldOptions>,
            (FieldOptionsDsl.() -> Unit) -> FieldOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): FieldOptions {
            var ctype : CType? = null
            var packed : Boolean? = null
            var deprecated : Boolean? = null
            var lazy : Boolean? = null
            var jstype : JSType? = null
            var weak : Boolean? = null
            var unverifiedLazy : Boolean? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return FieldOptions(ctype,
                        packed,
                        deprecated,
                        lazy,
                        jstype,
                        weak,
                        unverifiedLazy,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    8 -> ctype = deserializer.readEnum(com.toasttab.protokt.FieldOptions.CType)
                    16 -> packed = deserializer.readBool()
                    24 -> deprecated = deserializer.readBool()
                    40 -> lazy = deserializer.readBool()
                    48 -> jstype = deserializer.readEnum(com.toasttab.protokt.FieldOptions.JSType)
                    80 -> weak = deserializer.readBool()
                    120 -> unverifiedLazy = deserializer.readBool()
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: FieldOptionsDsl.() -> Unit): FieldOptions =
            FieldOptionsDsl().apply(dsl).build()
    }

    sealed class CType(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        /**
         * Default mode.
         */
        object STRING : CType(0, "STRING")

        object CORD : CType(1, "CORD")

        object STRING_PIECE : CType(2, "STRING_PIECE")

        class UNRECOGNIZED(
            `value`: Int,
        ) : CType(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<CType> {
            override fun from(`value`: Int): CType = when (value) {
                0 -> STRING
                1 -> CORD
                2 -> STRING_PIECE
                else -> UNRECOGNIZED(value)
            }
        }
    }

    sealed class JSType(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        /**
         * Use the default type.
         */
        object JS_NORMAL : JSType(0, "JS_NORMAL")

        /**
         * Use JavaScript strings.
         */
        object JS_STRING : JSType(1, "JS_STRING")

        /**
         * Use JavaScript numbers.
         */
        object JS_NUMBER : JSType(2, "JS_NUMBER")

        class UNRECOGNIZED(
            `value`: Int,
        ) : JSType(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<JSType> {
            override fun from(`value`: Int): JSType = when (value) {
                0 -> JS_NORMAL
                1 -> JS_STRING
                2 -> JS_NUMBER
                else -> UNRECOGNIZED(value)
            }
        }
    }
}

@KtGeneratedMessage("google.protobuf.OneofOptions")
class OneofOptions private constructor(
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is OneofOptions &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "OneofOptions(" +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: OneofOptionsDsl.() -> Unit): OneofOptions = OneofOptions.Deserializer {
        uninterpretedOption = this@OneofOptions.uninterpretedOption
        unknownFields = this@OneofOptions.unknownFields
        dsl()
    }

    class OneofOptionsDsl {
        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): OneofOptions = OneofOptions(finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<OneofOptions>,
            (OneofOptionsDsl.() -> Unit) -> OneofOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): OneofOptions {
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return OneofOptions(finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: OneofOptionsDsl.() -> Unit): OneofOptions =
            OneofOptionsDsl().apply(dsl).build()
    }
}

@KtGeneratedMessage("google.protobuf.EnumOptions")
class EnumOptions private constructor(
    /**
     * Set this option to true to allow mapping different tag names to the same value.
     */
    val allowAlias: Boolean?,
    /**
     * Is this enum deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for the enum, or it will be completely ignored; in the very least, this is a
     * formalization for deprecating enums.
     */
    val deprecated: Boolean?,
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (allowAlias != null) {
            result += sizeof(Tag(2)) + sizeof(allowAlias)
        }
        if (deprecated != null) {
            result += sizeof(Tag(3)) + sizeof(deprecated)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (allowAlias != null) {
            serializer.write(Tag(16)).write(allowAlias)
        }
        if (deprecated != null) {
            serializer.write(Tag(24)).write(deprecated)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is EnumOptions &&
            other.allowAlias == allowAlias &&
            other.deprecated == deprecated &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + allowAlias.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "EnumOptions(" +
            "allowAlias=$allowAlias, " +
            "deprecated=$deprecated, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: EnumOptionsDsl.() -> Unit): EnumOptions = EnumOptions.Deserializer {
        allowAlias = this@EnumOptions.allowAlias
        deprecated = this@EnumOptions.deprecated
        uninterpretedOption = this@EnumOptions.uninterpretedOption
        unknownFields = this@EnumOptions.unknownFields
        dsl()
    }

    class EnumOptionsDsl {
        var allowAlias: Boolean? = null

        var deprecated: Boolean? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): EnumOptions = EnumOptions(allowAlias,
            deprecated,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<EnumOptions>,
            (EnumOptionsDsl.() -> Unit) -> EnumOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): EnumOptions {
            var allowAlias : Boolean? = null
            var deprecated : Boolean? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return EnumOptions(allowAlias,
                        deprecated,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    16 -> allowAlias = deserializer.readBool()
                    24 -> deprecated = deserializer.readBool()
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: EnumOptionsDsl.() -> Unit): EnumOptions =
            EnumOptionsDsl().apply(dsl).build()
    }
}

@KtGeneratedMessage("google.protobuf.EnumValueOptions")
class EnumValueOptions private constructor(
    /**
     * Is this enum value deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for the enum value, or it will be completely ignored; in the very least, this is a
     * formalization for deprecating enum values.
     */
    val deprecated: Boolean?,
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (deprecated != null) {
            result += sizeof(Tag(1)) + sizeof(deprecated)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (deprecated != null) {
            serializer.write(Tag(8)).write(deprecated)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is EnumValueOptions &&
            other.deprecated == deprecated &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "EnumValueOptions(" +
            "deprecated=$deprecated, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: EnumValueOptionsDsl.() -> Unit): EnumValueOptions =
        EnumValueOptions.Deserializer {
            deprecated = this@EnumValueOptions.deprecated
            uninterpretedOption = this@EnumValueOptions.uninterpretedOption
            unknownFields = this@EnumValueOptions.unknownFields
            dsl()
        }

    class EnumValueOptionsDsl {
        var deprecated: Boolean? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): EnumValueOptions = EnumValueOptions(deprecated,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<EnumValueOptions>,
            (EnumValueOptionsDsl.() -> Unit) -> EnumValueOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): EnumValueOptions {
            var deprecated : Boolean? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return EnumValueOptions(deprecated,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    8 -> deprecated = deserializer.readBool()
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: EnumValueOptionsDsl.() -> Unit): EnumValueOptions =
            EnumValueOptionsDsl().apply(dsl).build()
    }
}

@KtGeneratedMessage("google.protobuf.ServiceOptions")
class ServiceOptions private constructor(
    /**
     * Is this service deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for the service, or it will be completely ignored; in the very least, this is a
     * formalization for deprecating services.
     */
    val deprecated: Boolean?,
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (deprecated != null) {
            result += sizeof(Tag(33)) + sizeof(deprecated)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (deprecated != null) {
            serializer.write(Tag(264)).write(deprecated)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ServiceOptions &&
            other.deprecated == deprecated &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "ServiceOptions(" +
            "deprecated=$deprecated, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ServiceOptionsDsl.() -> Unit): ServiceOptions =
        ServiceOptions.Deserializer {
            deprecated = this@ServiceOptions.deprecated
            uninterpretedOption = this@ServiceOptions.uninterpretedOption
            unknownFields = this@ServiceOptions.unknownFields
            dsl()
        }

    class ServiceOptionsDsl {
        var deprecated: Boolean? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ServiceOptions = ServiceOptions(deprecated,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<ServiceOptions>,
            (ServiceOptionsDsl.() -> Unit) -> ServiceOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): ServiceOptions {
            var deprecated : Boolean? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ServiceOptions(deprecated,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    264 -> deprecated = deserializer.readBool()
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ServiceOptionsDsl.() -> Unit): ServiceOptions =
            ServiceOptionsDsl().apply(dsl).build()
    }
}

@KtGeneratedMessage("google.protobuf.MethodOptions")
class MethodOptions private constructor(
    /**
     * Is this method deprecated? Depending on the target platform, this can emit Deprecated
     * annotations for the method, or it will be completely ignored; in the very least, this is a
     * formalization for deprecating methods.
     */
    val deprecated: Boolean?,
    val idempotencyLevel: IdempotencyLevel?,
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
    val uninterpretedOption: List<UninterpretedOption>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (deprecated != null) {
            result += sizeof(Tag(33)) + sizeof(deprecated)
        }
        if (idempotencyLevel != null) {
            result += sizeof(Tag(34)) + sizeof(idempotencyLevel)
        }
        if (uninterpretedOption.isNotEmpty()) {
            result += (sizeof(Tag(999)) * uninterpretedOption.size) + uninterpretedOption.sumOf {
                sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (deprecated != null) {
            serializer.write(Tag(264)).write(deprecated)
        }
        if (idempotencyLevel != null) {
            serializer.write(Tag(272)).write(idempotencyLevel)
        }
        if (uninterpretedOption.isNotEmpty()) {
            uninterpretedOption.forEach { serializer.write(Tag(7994)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is MethodOptions &&
            other.deprecated == deprecated &&
            other.idempotencyLevel == idempotencyLevel &&
            other.uninterpretedOption == uninterpretedOption &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + deprecated.hashCode()
        result = 31 * result + idempotencyLevel.hashCode()
        result = 31 * result + uninterpretedOption.hashCode()
        return result
    }

    override fun toString(): String = "MethodOptions(" +
            "deprecated=$deprecated, " +
            "idempotencyLevel=$idempotencyLevel, " +
            "uninterpretedOption=$uninterpretedOption" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: MethodOptionsDsl.() -> Unit): MethodOptions = MethodOptions.Deserializer {
        deprecated = this@MethodOptions.deprecated
        idempotencyLevel = this@MethodOptions.idempotencyLevel
        uninterpretedOption = this@MethodOptions.uninterpretedOption
        unknownFields = this@MethodOptions.unknownFields
        dsl()
    }

    class MethodOptionsDsl {
        var deprecated: Boolean? = null

        var idempotencyLevel: IdempotencyLevel? = null

        var uninterpretedOption: List<UninterpretedOption> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): MethodOptions = MethodOptions(deprecated,
            idempotencyLevel,
            finishList(uninterpretedOption),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<MethodOptions>,
            (MethodOptionsDsl.() -> Unit) -> MethodOptions {
        override fun deserialize(deserializer: KtMessageDeserializer): MethodOptions {
            var deprecated : Boolean? = null
            var idempotencyLevel : IdempotencyLevel? = null
            var uninterpretedOption : MutableList<UninterpretedOption>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return MethodOptions(deprecated,
                        idempotencyLevel,
                        finishList(uninterpretedOption),
                        UnknownFieldSet.from(unknownFields))
                    264 -> deprecated = deserializer.readBool()
                    272 -> idempotencyLevel =
                        deserializer.readEnum(com.toasttab.protokt.MethodOptions.IdempotencyLevel)
                    7994 -> uninterpretedOption = (uninterpretedOption ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: MethodOptionsDsl.() -> Unit): MethodOptions =
            MethodOptionsDsl().apply(dsl).build()
    }

    /**
     * Is this method side-effect-free (or safe in HTTP parlance), or idempotent, or neither? HTTP
     * based RPC implementation may choose GET verb for safe methods, and PUT verb for idempotent
     * methods instead of the default POST.
     */
    sealed class IdempotencyLevel(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        object IDEMPOTENCY_UNKNOWN : IdempotencyLevel(0, "IDEMPOTENCY_UNKNOWN")

        object NO_SIDE_EFFECTS : IdempotencyLevel(1, "NO_SIDE_EFFECTS")

        object IDEMPOTENT : IdempotencyLevel(2, "IDEMPOTENT")

        class UNRECOGNIZED(
            `value`: Int,
        ) : IdempotencyLevel(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<IdempotencyLevel> {
            override fun from(`value`: Int): IdempotencyLevel = when (value) {
                0 -> IDEMPOTENCY_UNKNOWN
                1 -> NO_SIDE_EFFECTS
                2 -> IDEMPOTENT
                else -> UNRECOGNIZED(value)
            }
        }
    }
}

/**
 * A message representing a option the parser does not recognize. This only appears in options
 * protos created by the compiler::Parser class. DescriptorPool resolves these when building Descriptor
 * objects. Therefore, options protos in descriptor objects (e.g. returned by Descriptor::options(), or
 * produced by Descriptor::CopyTo()) will never have UninterpretedOptions in them.
 */
@KtGeneratedMessage("google.protobuf.UninterpretedOption")
class UninterpretedOption private constructor(
    val name: List<NamePart>,
    /**
     * The value of the uninterpreted option, in whatever type the tokenizer identified it as during
     * parsing. Exactly one of these should be set.
     */
    val identifierValue: String?,
    val positiveIntValue: Long?,
    val negativeIntValue: Long?,
    val doubleValue: Double?,
    val stringValue: Bytes?,
    val aggregateValue: String?,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name.isNotEmpty()) {
            result += (sizeof(Tag(2)) * name.size) + name.sumOf { sizeof(it) }
        }
        if (identifierValue != null) {
            result += sizeof(Tag(3)) + sizeof(identifierValue)
        }
        if (positiveIntValue != null) {
            result += sizeof(Tag(4)) + sizeof(UInt64(positiveIntValue))
        }
        if (negativeIntValue != null) {
            result += sizeof(Tag(5)) + sizeof(Int64(negativeIntValue))
        }
        if (doubleValue != null) {
            result += sizeof(Tag(6)) + sizeof(doubleValue)
        }
        if (stringValue != null) {
            result += sizeof(Tag(7)) + sizeof(stringValue)
        }
        if (aggregateValue != null) {
            result += sizeof(Tag(8)) + sizeof(aggregateValue)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name.isNotEmpty()) {
            name.forEach { serializer.write(Tag(18)).write(it) }
        }
        if (identifierValue != null) {
            serializer.write(Tag(26)).write(identifierValue)
        }
        if (positiveIntValue != null) {
            serializer.write(Tag(32)).write(UInt64(positiveIntValue))
        }
        if (negativeIntValue != null) {
            serializer.write(Tag(40)).write(Int64(negativeIntValue))
        }
        if (doubleValue != null) {
            serializer.write(Tag(49)).write(doubleValue)
        }
        if (stringValue != null) {
            serializer.write(Tag(58)).write(stringValue)
        }
        if (aggregateValue != null) {
            serializer.write(Tag(66)).write(aggregateValue)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is UninterpretedOption &&
            other.name == name &&
            other.identifierValue == identifierValue &&
            other.positiveIntValue == positiveIntValue &&
            other.negativeIntValue == negativeIntValue &&
            other.doubleValue == doubleValue &&
            other.stringValue == stringValue &&
            other.aggregateValue == aggregateValue &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + identifierValue.hashCode()
        result = 31 * result + positiveIntValue.hashCode()
        result = 31 * result + negativeIntValue.hashCode()
        result = 31 * result + doubleValue.hashCode()
        result = 31 * result + stringValue.hashCode()
        result = 31 * result + aggregateValue.hashCode()
        return result
    }

    override fun toString(): String = "UninterpretedOption(" +
            "name=$name, " +
            "identifierValue=$identifierValue, " +
            "positiveIntValue=$positiveIntValue, " +
            "negativeIntValue=$negativeIntValue, " +
            "doubleValue=$doubleValue, " +
            "stringValue=$stringValue, " +
            "aggregateValue=$aggregateValue" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: UninterpretedOptionDsl.() -> Unit): UninterpretedOption =
        UninterpretedOption.Deserializer {
            name = this@UninterpretedOption.name
            identifierValue = this@UninterpretedOption.identifierValue
            positiveIntValue = this@UninterpretedOption.positiveIntValue
            negativeIntValue = this@UninterpretedOption.negativeIntValue
            doubleValue = this@UninterpretedOption.doubleValue
            stringValue = this@UninterpretedOption.stringValue
            aggregateValue = this@UninterpretedOption.aggregateValue
            unknownFields = this@UninterpretedOption.unknownFields
            dsl()
        }

    class UninterpretedOptionDsl {
        var name: List<NamePart> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var identifierValue: String? = null

        var positiveIntValue: Long? = null

        var negativeIntValue: Long? = null

        var doubleValue: Double? = null

        var stringValue: Bytes? = null

        var aggregateValue: String? = null

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): UninterpretedOption = UninterpretedOption(finishList(name),
            identifierValue,
            positiveIntValue,
            negativeIntValue,
            doubleValue,
            stringValue,
            aggregateValue,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<UninterpretedOption>,
            (UninterpretedOptionDsl.() -> Unit) -> UninterpretedOption {
        override fun deserialize(deserializer: KtMessageDeserializer): UninterpretedOption {
            var name : MutableList<NamePart>? = null
            var identifierValue : String? = null
            var positiveIntValue : Long? = null
            var negativeIntValue : Long? = null
            var doubleValue : Double? = null
            var stringValue : Bytes? = null
            var aggregateValue : String? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return UninterpretedOption(finishList(name),
                        identifierValue,
                        positiveIntValue,
                        negativeIntValue,
                        doubleValue,
                        stringValue,
                        aggregateValue,
                        UnknownFieldSet.from(unknownFields))
                    18 -> name = (name ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.UninterpretedOption.NamePart))
                        }
                    }
                    26 -> identifierValue = deserializer.readString()
                    32 -> positiveIntValue = deserializer.readUInt64()
                    40 -> negativeIntValue = deserializer.readInt64()
                    49 -> doubleValue = deserializer.readDouble()
                    58 -> stringValue = deserializer.readBytes()
                    66 -> aggregateValue = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: UninterpretedOptionDsl.() -> Unit): UninterpretedOption =
            UninterpretedOptionDsl().apply(dsl).build()
    }

    /**
     * The name of the uninterpreted option.  Each string represents a segment in a dot-separated
     * name.  is_extension is true iff a segment represents an extension (denoted with parentheses in
     * options specs in .proto files). E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] }
     * represents "foo.(bar.baz).moo".
     */
    @KtGeneratedMessage("google.protobuf.NamePart")
    class NamePart private constructor(
        val namePart: String,
        val isExtension: Boolean,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (namePart.isNotEmpty()) {
                result += sizeof(Tag(1)) + sizeof(namePart)
            }
            if (isExtension) {
                result += sizeof(Tag(2)) + sizeof(isExtension)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (namePart.isNotEmpty()) {
                serializer.write(Tag(10)).write(namePart)
            }
            if (isExtension) {
                serializer.write(Tag(16)).write(isExtension)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is NamePart &&
                other.namePart == namePart &&
                other.isExtension == isExtension &&
                other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + namePart.hashCode()
            result = 31 * result + isExtension.hashCode()
            return result
        }

        override fun toString(): String = "NamePart(" +
                "namePart=$namePart, " +
                "isExtension=$isExtension" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: NamePartDsl.() -> Unit): NamePart = NamePart.Deserializer {
            namePart = this@NamePart.namePart
            isExtension = this@NamePart.isExtension
            unknownFields = this@NamePart.unknownFields
            dsl()
        }

        class NamePartDsl {
            var namePart: String = ""

            var isExtension: Boolean = false

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): NamePart = NamePart(namePart,
                isExtension,
                unknownFields)
        }

        companion object Deserializer : KtDeserializer<NamePart>,
                (NamePartDsl.() -> Unit) -> NamePart {
            override fun deserialize(deserializer: KtMessageDeserializer): NamePart {
                var namePart = ""
                var isExtension = false
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return NamePart(namePart,
                            isExtension,
                            UnknownFieldSet.from(unknownFields))
                        10 -> namePart = deserializer.readString()
                        16 -> isExtension = deserializer.readBool()
                        else -> unknownFields = (unknownFields ?:
                        UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                        }
                    }
                }
            }

            override fun invoke(dsl: NamePartDsl.() -> Unit): NamePart =
                NamePartDsl().apply(dsl).build()
        }
    }
}

/**
 * Encapsulates information about the original source file from which a FileDescriptorProto was
 * generated.
 */
@KtGeneratedMessage("google.protobuf.SourceCodeInfo")
class SourceCodeInfo private constructor(
    /**
     * A Location identifies a piece of source code in a .proto file which corresponds to a
     * particular definition.  This information is intended to be useful to IDEs, code indexers,
     * documentation generators, and similar tools.
     *
     *  For example, say we have a file like:   message Foo {     optional string foo = 1;   } Let's
     * look at just the field definition:   optional string foo = 1;   ^       ^^     ^^  ^  ^^^   a
     *    bc     de  f  ghi We have the following locations:   span   path               represents
     * [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.   [a,b)  [ 4, 0, 2, 0, 4 ]  The label
     * (optional).   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).   [e,f)  [ 4, 0, 2, 0, 1 ]  The name
     * (foo).   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     *
     *  Notes: - A location may refer to a repeated field itself (i.e. not to any   particular index
     * within it).  This is used whenever a set of elements are   logically enclosed in a single code
     * segment.  For example, an entire   extend block (possibly containing multiple extension
     * definitions) will   have an outer location whose path refers to the "extensions" repeated
     * field without an index. - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most   obvious example is the
     * "extend" block again -- there may be multiple   extend blocks in the same scope, each of which
     * will have the same path. - A location's span is not always a subset of its parent's span.  For
     * example, the "extendee" of an extension declaration appears at the   beginning of the "extend"
     * block and is shared by all extensions within   the block. - Just because a location's span is a
     * subset of some other location's span   does not mean that it is a descendant.  For example, a
     * "group" defines   both a type and a field in a single declaration.  Thus, the locations
     * corresponding to the type and field and their components will overlap. - Code which tries to
     * interpret locations should probably be designed to   ignore those that it doesn't understand, as
     * more types of locations could   be recorded in the future.
     */
    val location: List<Location>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (location.isNotEmpty()) {
            result += (sizeof(Tag(1)) * location.size) + location.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (location.isNotEmpty()) {
            location.forEach { serializer.write(Tag(10)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is SourceCodeInfo &&
            other.location == location &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + location.hashCode()
        return result
    }

    override fun toString(): String = "SourceCodeInfo(" +
            "location=$location" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: SourceCodeInfoDsl.() -> Unit): SourceCodeInfo =
        SourceCodeInfo.Deserializer {
            location = this@SourceCodeInfo.location
            unknownFields = this@SourceCodeInfo.unknownFields
            dsl()
        }

    class SourceCodeInfoDsl {
        var location: List<Location> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): SourceCodeInfo = SourceCodeInfo(finishList(location),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<SourceCodeInfo>,
            (SourceCodeInfoDsl.() -> Unit) -> SourceCodeInfo {
        override fun deserialize(deserializer: KtMessageDeserializer): SourceCodeInfo {
            var location : MutableList<Location>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return SourceCodeInfo(finishList(location),
                        UnknownFieldSet.from(unknownFields))
                    10 -> location = (location ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.SourceCodeInfo.Location))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: SourceCodeInfoDsl.() -> Unit): SourceCodeInfo =
            SourceCodeInfoDsl().apply(dsl).build()
    }

    @KtGeneratedMessage("google.protobuf.Location")
    class Location private constructor(
        /**
         * Identifies which part of the FileDescriptorProto was defined at this location.
         *
         *  Each element is a field number or an index.  They form a path from the root
         * FileDescriptorProto to the place where the definition occurs. For example, this path:   [ 4,
         * 3, 2, 7, 1 ] refers to:   file.message_type(3)  // 4, 3       .field(7)         // 2, 7
         *  .name()           // 1 This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4; and DescriptorProto.field has field number 2:
         * repeated FieldDescriptorProto field = 2; and FieldDescriptorProto.name has field number 1:
         * optional string name = 1;
         *
         *  Thus, the above path gives the location of a field name.  If we removed the last
         * element:   [ 4, 3, 2, 7 ] this path refers to the whole field declaration (from the
         * beginning of the label to the terminating semicolon).
         */
        val path: List<Int>,
        /**
         * Always has exactly three or four elements: start line, start column, end line (optional,
         * otherwise assumed same as start line), end column. These are packed into a single field for
         * efficiency.  Note that line and column numbers are zero-based -- typically you will want to
         * add 1 to each before displaying to a user.
         */
        val span: List<Int>,
        /**
         * If this SourceCodeInfo represents a complete declaration, these are any comments
         * appearing before and after the declaration which appear to be attached to the declaration.
         *
         *  A series of line comments appearing on consecutive lines, with no other tokens appearing
         * on those lines, will be treated as a single comment.
         *
         *  leading_detached_comments will keep paragraphs of comments that appear before (but not
         * connected to) the current element. Each paragraph, separated by empty lines, will be one
         * comment element in the repeated field.
         *
         *  Only the comment content is provided; comment markers (e.g. //) are stripped out.  For
         * block comments, leading whitespace and an asterisk will be stripped from the beginning of
         * each line other than the first. Newlines are included in the output.
         *
         *  Examples:
         *
         *    optional int32 foo = 1;  // Comment attached to foo.   // Comment attached to bar.
         * optional int32 bar = 2;
         *
         *    optional string baz = 3;   // Comment attached to baz.   // Another line attached to
         * baz.
         *
         *    // Comment attached to moo.   //   // Another line attached to moo.   optional double
         * moo = 4;
         *
         *    // Detached comment for corge. This is not leading or trailing comments   // to moo or
         * corge because there are blank lines separating it from   // both.
         *
         *    // Detached comment for corge paragraph 2.
         *
         *    optional string corge = 5;   &#47;* Block comment attached    * to corge.  Leading
         * asterisks    * will be removed. *&#47;   &#47;* Block comment attached to    * grault.
         * *&#47;   optional int32 grault = 6;
         *
         *    // ignored detached comments.
         */
        val leadingComments: String?,
        val trailingComments: String?,
        val leadingDetachedComments: List<String>,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (path.isNotEmpty()) {
                result += sizeof(Tag(1)) + path.sumOf { sizeof(com.toasttab.protokt.rt.Int32(it))
                }.let { it + sizeof(UInt32(it)) }
            }
            if (span.isNotEmpty()) {
                result += sizeof(Tag(2)) + span.sumOf { sizeof(com.toasttab.protokt.rt.Int32(it))
                }.let { it + sizeof(UInt32(it)) }
            }
            if (leadingComments != null) {
                result += sizeof(Tag(3)) + sizeof(leadingComments)
            }
            if (trailingComments != null) {
                result += sizeof(Tag(4)) + sizeof(trailingComments)
            }
            if (leadingDetachedComments.isNotEmpty()) {
                result += (sizeof(Tag(6)) * leadingDetachedComments.size) +
                        leadingDetachedComments.sumOf { sizeof(it) }
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (path.isNotEmpty()) {
                serializer.write(Tag(10)).write(UInt32(path.sumOf{sizeof(Int32(it))}))
                path.forEach { serializer.write(Int32(it)) }
            }
            if (span.isNotEmpty()) {
                serializer.write(Tag(18)).write(UInt32(span.sumOf{sizeof(Int32(it))}))
                span.forEach { serializer.write(Int32(it)) }
            }
            if (leadingComments != null) {
                serializer.write(Tag(26)).write(leadingComments)
            }
            if (trailingComments != null) {
                serializer.write(Tag(34)).write(trailingComments)
            }
            if (leadingDetachedComments.isNotEmpty()) {
                leadingDetachedComments.forEach { serializer.write(Tag(50)).write(it) }
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is Location &&
                other.path == path &&
                other.span == span &&
                other.leadingComments == leadingComments &&
                other.trailingComments == trailingComments &&
                other.leadingDetachedComments == leadingDetachedComments &&
                other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + path.hashCode()
            result = 31 * result + span.hashCode()
            result = 31 * result + leadingComments.hashCode()
            result = 31 * result + trailingComments.hashCode()
            result = 31 * result + leadingDetachedComments.hashCode()
            return result
        }

        override fun toString(): String = "Location(" +
                "path=$path, " +
                "span=$span, " +
                "leadingComments=$leadingComments, " +
                "trailingComments=$trailingComments, " +
                "leadingDetachedComments=$leadingDetachedComments" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: LocationDsl.() -> Unit): Location = Location.Deserializer {
            path = this@Location.path
            span = this@Location.span
            leadingComments = this@Location.leadingComments
            trailingComments = this@Location.trailingComments
            leadingDetachedComments = this@Location.leadingDetachedComments
            unknownFields = this@Location.unknownFields
            dsl()
        }

        class LocationDsl {
            var path: List<Int> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var span: List<Int> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var leadingComments: String? = null

            var trailingComments: String? = null

            var leadingDetachedComments: List<String> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Location = Location(finishList(path),
                finishList(span),
                leadingComments,
                trailingComments,
                finishList(leadingDetachedComments),
                unknownFields)
        }

        companion object Deserializer : KtDeserializer<Location>,
                (LocationDsl.() -> Unit) -> Location {
            override fun deserialize(deserializer: KtMessageDeserializer): Location {
                var path : MutableList<Int>? = null
                var span : MutableList<Int>? = null
                var leadingComments : String? = null
                var trailingComments : String? = null
                var leadingDetachedComments : MutableList<String>? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Location(finishList(path),
                            finishList(span),
                            leadingComments,
                            trailingComments,
                            finishList(leadingDetachedComments),
                            UnknownFieldSet.from(unknownFields))
                        8 -> path = (path ?: mutableListOf()).apply {
                            deserializer.readRepeated(false) {
                                add(deserializer.readInt32())
                            }
                        }
                        10 -> path = (path ?: mutableListOf()).apply {
                            deserializer.readRepeated(true) {
                                add(deserializer.readInt32())
                            }
                        }
                        16 -> span = (span ?: mutableListOf()).apply {
                            deserializer.readRepeated(false) {
                                add(deserializer.readInt32())
                            }
                        }
                        18 -> span = (span ?: mutableListOf()).apply {
                            deserializer.readRepeated(true) {
                                add(deserializer.readInt32())
                            }
                        }
                        26 -> leadingComments = deserializer.readString()
                        34 -> trailingComments = deserializer.readString()
                        50 -> leadingDetachedComments = (leadingDetachedComments ?:
                        mutableListOf()).apply {
                            deserializer.readRepeated(false) {
                                add(deserializer.readString())
                            }
                        }
                        else -> unknownFields = (unknownFields ?:
                        UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                        }
                    }
                }
            }

            override fun invoke(dsl: LocationDsl.() -> Unit): Location =
                LocationDsl().apply(dsl).build()
        }
    }
}

/**
 * Describes the relationship between generated code and its original source file. A
 * GeneratedCodeInfo message is associated with only one generated source file, but may contain
 * references to different source .proto files.
 */
@KtGeneratedMessage("google.protobuf.GeneratedCodeInfo")
class GeneratedCodeInfo private constructor(
    /**
     * An Annotation connects some span of text in generated code to an element of its generating
     * .proto file.
     */
    val `annotation`: List<Annotation>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (annotation.isNotEmpty()) {
            result += (sizeof(Tag(1)) * annotation.size) + annotation.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (annotation.isNotEmpty()) {
            annotation.forEach { serializer.write(Tag(10)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is GeneratedCodeInfo &&
            other.annotation == annotation &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + annotation.hashCode()
        return result
    }

    override fun toString(): String = "GeneratedCodeInfo(" +
            "annotation=$annotation" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: GeneratedCodeInfoDsl.() -> Unit): GeneratedCodeInfo =
        GeneratedCodeInfo.Deserializer {
            annotation = this@GeneratedCodeInfo.annotation
            unknownFields = this@GeneratedCodeInfo.unknownFields
            dsl()
        }

    class GeneratedCodeInfoDsl {
        var `annotation`: List<Annotation> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): GeneratedCodeInfo = GeneratedCodeInfo(finishList(annotation),
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<GeneratedCodeInfo>,
            (GeneratedCodeInfoDsl.() -> Unit) -> GeneratedCodeInfo {
        override fun deserialize(deserializer: KtMessageDeserializer): GeneratedCodeInfo {
            var annotation : MutableList<Annotation>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return GeneratedCodeInfo(finishList(annotation),
                        UnknownFieldSet.from(unknownFields))
                    10 -> annotation = (annotation ?: mutableListOf()).apply {
                        deserializer.readRepeated(false) {

                            add(deserializer.readMessage(com.toasttab.protokt.GeneratedCodeInfo.Annotation))
                        }
                    }
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: GeneratedCodeInfoDsl.() -> Unit): GeneratedCodeInfo =
            GeneratedCodeInfoDsl().apply(dsl).build()
    }

    @KtGeneratedMessage("google.protobuf.Annotation")
    class Annotation private constructor(
        /**
         * Identifies the element in the original source .proto file. This field is formatted the
         * same as SourceCodeInfo.Location.path.
         */
        val path: List<Int>,
        /**
         * Identifies the filesystem path to the original source .proto.
         */
        val sourceFile: String?,
        /**
         * Identifies the starting offset in bytes in the generated code that relates to the
         * identified object.
         */
        val begin: Int?,
        /**
         * Identifies the ending offset in bytes in the generated code that relates to the
         * identified offset. The end offset should be one past the last relevant byte (so the length
         * of the text = end - begin).
         */
        val end: Int?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (path.isNotEmpty()) {
                result += sizeof(Tag(1)) + path.sumOf { sizeof(com.toasttab.protokt.rt.Int32(it))
                }.let { it + sizeof(UInt32(it)) }
            }
            if (sourceFile != null) {
                result += sizeof(Tag(2)) + sizeof(sourceFile)
            }
            if (begin != null) {
                result += sizeof(Tag(3)) + sizeof(Int32(begin))
            }
            if (end != null) {
                result += sizeof(Tag(4)) + sizeof(Int32(end))
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (path.isNotEmpty()) {
                serializer.write(Tag(10)).write(UInt32(path.sumOf{sizeof(Int32(it))}))
                path.forEach { serializer.write(Int32(it)) }
            }
            if (sourceFile != null) {
                serializer.write(Tag(18)).write(sourceFile)
            }
            if (begin != null) {
                serializer.write(Tag(24)).write(Int32(begin))
            }
            if (end != null) {
                serializer.write(Tag(32)).write(Int32(end))
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is Annotation &&
                other.path == path &&
                other.sourceFile == sourceFile &&
                other.begin == begin &&
                other.end == end &&
                other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + path.hashCode()
            result = 31 * result + sourceFile.hashCode()
            result = 31 * result + begin.hashCode()
            result = 31 * result + end.hashCode()
            return result
        }

        override fun toString(): String = "Annotation(" +
                "path=$path, " +
                "sourceFile=$sourceFile, " +
                "begin=$begin, " +
                "end=$end" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: AnnotationDsl.() -> Unit): Annotation = Annotation.Deserializer {
            path = this@Annotation.path
            sourceFile = this@Annotation.sourceFile
            begin = this@Annotation.begin
            end = this@Annotation.end
            unknownFields = this@Annotation.unknownFields
            dsl()
        }

        class AnnotationDsl {
            var path: List<Int> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var sourceFile: String? = null

            var begin: Int? = null

            var end: Int? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Annotation = Annotation(finishList(path),
                sourceFile,
                begin,
                end,
                unknownFields)
        }

        companion object Deserializer : KtDeserializer<Annotation>,
                (AnnotationDsl.() -> Unit) -> Annotation {
            override fun deserialize(deserializer: KtMessageDeserializer): Annotation {
                var path : MutableList<Int>? = null
                var sourceFile : String? = null
                var begin : Int? = null
                var end : Int? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Annotation(finishList(path),
                            sourceFile,
                            begin,
                            end,
                            UnknownFieldSet.from(unknownFields))
                        8 -> path = (path ?: mutableListOf()).apply {
                            deserializer.readRepeated(false) {
                                add(deserializer.readInt32())
                            }
                        }
                        10 -> path = (path ?: mutableListOf()).apply {
                            deserializer.readRepeated(true) {
                                add(deserializer.readInt32())
                            }
                        }
                        18 -> sourceFile = deserializer.readString()
                        24 -> begin = deserializer.readInt32()
                        32 -> end = deserializer.readInt32()
                        else -> unknownFields = (unknownFields ?:
                        UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                        }
                    }
                }
            }

            override fun invoke(dsl: AnnotationDsl.() -> Unit): Annotation =
                AnnotationDsl().apply(dsl).build()
        }
    }
}
