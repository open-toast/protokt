/*
 * Copyright (c) 2023 Toast, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/protobuf/any.proto
package com.toasttab.protokt

import com.toasttab.protokt.rt.Bytes
import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.sizeof
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes
 * the type of the serialized message.
 *
 *  Protobuf library provides support to pack/unpack Any values in the form of utility functions or
 * additional generated methods of the Any type.
 *
 *  Example 1: Pack and unpack a message in C++.
 *
 *      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {
 *   ...     }
 *
 *  Example 2: Pack and unpack a message in Java.
 *
 *      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo =
 * any.unpack(Foo.class);     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):
 *  any.Unpack(foo)       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }
 *     ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }
 *
 *  The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully
 * qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield
 * type name "y.z".
 *
 *
 *
 *  JSON
 *
 *  The JSON representation of an `Any` value uses the regular representation of the deserialized,
 * embedded message, with an additional field `@type` which contains the type URL. Example:
 *
 *      package google.profile;     message Person {       string first_name = 1;       string
 * last_name = 2;     }
 *
 *      {       "@type": "type.googleapis.com/google.profile.Person",       "firstName": <string>,
 *     "lastName": <string>     }
 *
 *  If the embedded message type is well-known and has a custom JSON representation, that
 * representation will be embedded adding a field `value` which holds the custom JSON in addition to
 * the `@type` field. Example (for message [google.protobuf.Duration][]):
 *
 *      {       "@type": "type.googleapis.com/google.protobuf.Duration",       "value": "1.212s"
 * }
 */
@Deprecated("for backwards compatibility only")
@KtGeneratedMessage("google.protobuf.Any")
class Any private constructor(
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer
     * message. This string must contain at least one "/" character. The last segment of the URL's path
     * must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The
     * name should be in a canonical form (e.g., leading "." is not accepted).
     *
     *  In practice, teams usually precompile into the binary all types that they expect it to use
     * in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one
     * can optionally set up a type server that maps type URLs to message definitions as follows:
     *
     *  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a
     * [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are
     * allowed to cache lookup results based on the   URL, or have them precompiled into a binary to
     * avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types.
     * (Use versioned type names to manage   breaking changes.)
     *
     *  Note: this functionality is not currently available in the official protobuf release, and it
     * is not used for type URLs beginning with type.googleapis.com.
     *
     *  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation
     * specific semantics.
     */
    val typeUrl: String,
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     */
    val `value`: Bytes,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (typeUrl.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(typeUrl)
        }
        if (value.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(value)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (typeUrl.isNotEmpty()) {
            serializer.write(Tag(10)).write(typeUrl)
        }
        if (value.isNotEmpty()) {
            serializer.write(Tag(18)).write(value)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: kotlin.Any?): Boolean = other is Any &&
            other.typeUrl == typeUrl &&
            other.value == value &&
            other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + typeUrl.hashCode()
        result = 31 * result + value.hashCode()
        return result
    }

    override fun toString(): String = "Any(" +
            "typeUrl=$typeUrl, " +
            "value=$value" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AnyDsl.() -> Unit): Any = Any.Deserializer {
        typeUrl = this@Any.typeUrl
        value = this@Any.value
        unknownFields = this@Any.unknownFields
        dsl()
    }

    class AnyDsl {
        var typeUrl: String = ""

        var `value`: Bytes = Bytes.empty()

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Any = Any(typeUrl,
            value,
            unknownFields)
    }

    companion object Deserializer : KtDeserializer<Any>, (AnyDsl.() -> Unit) -> Any {
        override fun deserialize(deserializer: KtMessageDeserializer): Any {
            var typeUrl = ""
            var value = Bytes.empty()
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Any(typeUrl,
                        value,
                        UnknownFieldSet.from(unknownFields))
                    10 -> typeUrl = deserializer.readString()
                    18 -> value = deserializer.readBytes()
                    else -> unknownFields = (unknownFields ?:
                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AnyDsl.() -> Unit): Any = AnyDsl().apply(dsl).build()
    }
}
