/*
 * Copyright (c) 2019. Toast Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import "renderers.stg"
import "options.stg"

header(package, runtimePackage, ext, extPackage) ::= <<
/*
 * Generated by protokt. Do not modify.
 */

package <package>

import <runtimePackage>.rt.*
<if(ext)>import <extPackage>.*<endif>

>>

oneof(name, types, options) ::= <<
sealed class <name> <oneofDoesImplement()>{
    <types.keys:{k |<\\>
    <blockComment(types.(k).documentation)><\\>
    <deprecated(types.(k))><\\>
    data class <k>(
    val <types.(k).fieldName>: <types.(k).type>
) : <name>()<oneofImplements()>}; separator="\n\n">
}

>>

enum(name, map, options) ::= <<
<blockComment(options.documentation)><\\>
<suppressDeprecation(options)><\\>
<deprecated(options)><\\>
sealed class <name>(
    override val value: Int,
    override val name: String
) : KtEnum() {
    <map.keys:{k |<\\>
    <blockComment(map.(k).documentation)><\\>
    <deprecated(map.(k))><\\>
    object <map.(k).valueName> : <name>(<k>, "<map.(k).valueName>")<\\>
    }; separator="\n\n">

    class UNRECOGNIZED(value: Int) : <name>(value, "UNRECOGNIZED")

    companion object Deserializer : KtEnumDeserializer\<<name>\> {
        override fun from(value: Int) =
            when (value) {
                <map.keys:{k | <k> -> <map.(k).valueName>}; separator="\n">
                else -> UNRECOGNIZED(value)
            }
    }
}

>>

message(message, entry, serialize, deserialize, plus, sizeof, inner, params, oneofs, options) ::= <<
<blockComment(message.documentation)><\\>
<suppressDeprecation(message)><\\>
<deprecated(message)><\\>
<if (entry.entry)><\\>
private <\\>
<else><\\>
@KtGeneratedMessage("<message.fullTypeName>")
<endif><\\>
data class <message.name>(
<if (entry.entry)>
    val key: <entry.kType>,
    val value: <entry.vType>
) : KtMessage {
<else>
    <params:{p |<\\>
        <blockComment(p.documentation)><\\>
        <deprecated(p)><\\>
        <messagePropertyOverrides()><\\>
        val <p.name>: <p.type><\\>
    }; separator=",\n"><if (params)>,<endif>
    val unknown: Map\<Int, Unknown> = emptyMap()
) : KtMessage<messageImplements()> {
    @Suppress("UNUSED")
    constructor(
        <params:{p | <p.name>: <p.type><defaultConstructorExp()>}; separator=",\n">
    ) : this(
        <params:{p | <p.name>};separator=",\n"><if (params)>,<endif>
        emptyMap()
    )
<endif>

    <if (oneofs)>
    <oneofs:{it |<it>}; separator="\n\n">
    <else>
    <endif>
    override val messageSize<\\>
    <if (entry.entry)>
        get() = sizeof(key, value)<\n>
    <else><\\>
        <\ >by lazy { sizeof() }
    <endif>

    override fun serialize(serializer: KtMessageSerializer) {
        <serialize:{it | <\\>
            <if (it.std)><\\>
                <it.conditionals:{n |<\\>
                <if (it.skipDefaultValue && !entry.entry)><\\>
                    if <n.condition>{<\n><\\>
                        <t()><n.consequent><\n><\\>
                    \}<\\>
                <else><\\>
                    <n.consequent><\\>
                <endif><\\>
                }; separator="\n"><\\>
            <else><\\>
                when (<it.fieldName>) {<\n><\\>
                    <t()><it.conditionals:{x | is <x.condition> -><\n><\\>
                        <t()><t()><x.consequent>}; separator="\n    "><\n><\\>
                \}<\\>
            <endif><\\>
        }; separator="\n">
        <if (!entry.entry)><\\>
        if (unknown.isNotEmpty()) {<\n><\\>
            <t()>serializer.writeUnknown(unknown)<\n><\\>
        }
        <endif>
    }

    <if (!entry.entry)>
    private fun sizeof(): Int {
        var res = 0
        <sizeof:{it | <\\>
        <if(it.std)><\\>
            <it.conditionals:{n |<\\>
                <if (it.skipDefaultValue)><\\>
                    if <n.condition>{<\n><\\>
                        <t()>res += <n.consequent><\n><\\>
                    \}<\\>
                <else><\\>
                    res += <n.consequent><\\>
                <endif><\\>
            }; separator="\n"><\\>
        <else><\\>
            <if (!it.skipDefaultValue)><\\>
                res += <\\>
            <endif><\\>
            when (<it.fieldName>) {<\n><\\>
                <t()><it.conditionals:{x | is <x.condition> -><\n><\\>
                <t()><t()><if (it.skipDefaultValue)>res += <endif><x.consequent>}; separator="\n    "><\n><\\>
            \}<\\>
        <endif><\\>
        }; separator="\n">
        res += unknown.values.sumBy { it.sizeof() }
        return res
    }
    <endif>

    companion object Deserializer : KtDeserializer\<<message.name>\> {
        <if (entry.entry)>
        fun sizeof(key: <entry.kType>, value: <entry.vType>) =
            <sizeof:{it | <it.conditionals:{n | <n.consequent>}; separator="">}; separator=" + ">

        <endif><\\>

        override fun deserialize(<\\>
        <if (options.longDeserializer)><\n><t()><t()><t()><endif><\\>
        deserializer: KtMessageDeserializer<\\>
        <if (options.longDeserializer)><\n><t()><t()><endif>): <message.name> {
            <params:{p | var <deserializeVar(p)>}; separator="\n">
            <if (!entry.entry)>
            var unknown: MutableMap\<Int, Unknown>? = null
            <endif>

            while (true) {
                when (deserializer.readTag()) {
                    0 -><\\>
                        <if (entry.entry)><\\>
                        <\ >return <message.name>(<params:{p | <deserializeWrapper(p.name)>}; separator=", ">)
                        <else>
                        return <message.name>(
                            <params:{p | <deserializeWrapper(p.name)>}; separator=",\n"><\\>
                            <if (params)>,<endif>
                            finishMap(unknown)
                        )
                        <endif>
                    <deserialize:{d | <d.tag> -> <d.assignment.fieldName> = <\\>
                    <if ((!d.std || d.repeated || d.assignment.long) && !entry.entry)><\n><t()><endif><\\>
                    <d.assignment.value>}; separator="\n">
                    <if (!entry.entry)>
                    else -> unknown =
                        (unknown ?: mutableMapOf()).also {
                            processUnknown(deserializer, it)
                        }
                    <endif>
                }
            }
        }
    }
    <if (inner)>

    <inner><\\>
    <endif><\\>
}

>>
