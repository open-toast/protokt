/*
 * Copyright (c) 2019 Toast Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import "options.stg"

kotlinDefaultValues ::= [
    "BOOL": "false",
    "BYTES": "Bytes.empty",
    "DOUBLE": "0.0",
    "ENUM": ".from(0)",
    "MESSAGE": "null",
    "FIXED32": "0",
    "INT32": "0",
    "SFIXED32": "0",
    "SINT32": "0",
    "UINT32": "0",
    "FIXED64": "0L",
    "INT64": "0L",
    "SFIXED64": "0L",
    "SINT64": "0L",
    "UINT64": "0L",
    "FLOAT": "0.0F",
    "STRING": "\"\""
]

readFunctions ::= [
    "BOOL": "readBool",
    "BYTES": "readBytes",
    "DOUBLE": "readDouble",
    "ENUM": "readEnum",
    "FIXED32": "readFixed32",
    "FIXED64": "readFixed64",
    "FLOAT": "readFloat",
    "INT32": "readInt32",
    "INT64": "readInt64",
    "MESSAGE": "readMessage",
    "SFIXED32": "readSFixed32",
    "SFIXED64": "readSFixed64",
    "SINT32": "readSInt32",
    "SINT64": "readSInt64",
    "STRING": "readString",
    "UINT32": "readUInt32",
    "UINT64": "readUInt64",
    default : "throw new RuntimeException"
]

boxFunction ::= [
    "INT32": true,
    "INT64": true,
    "SINT32": true,
    "SINT64": true,
    "UINT32": true,
    "UINT64": true,
    "SFIXED32": true,
    "SFIXED64": true,
    "FIXED32": true,
    "FIXED64": true,
    default: false
]

boxer ::= [
    "INT32": "Int32",
    "INT64": "Int64",
    "SINT32": "SInt32",
    "SINT64": "SInt64",
    "UINT32": "UInt32",
    "UINT64": "UInt64",
    "SFIXED32": "SFixed32",
    "SFIXED64": "SFixed64",
    "FIXED32": "Fixed32",
    "FIXED64": "Fixed64",
    default: ""
]

isScalar ::= [
    "BOOL": true,
    "STRING": true,
    "FLOAT": true,
    "DOUBLE": true,
    "INT32": true,
    "INT64": true,
    "SINT32": true,
    "SINT64": true,
    "UINT32": true,
    "UINT64": true,
    "SFIXED32": true,
    "SFIXED64": true,
    "FIXED32": true,
    "FIXED64": true,
    default: false
]

isMessage ::= ["MESSAGE": true, default: false]

isEnum ::= ["ENUM": true, default: false]

isBool ::= ["BOOL": true, default: false]

isGeneratedType ::= ["MESSAGE": true, "ENUM": true, default: false]

isBytes ::= ["BYTES": true, "STRING": true, default: false]

read(type, builder) ::= "<readFunctions.(type)>(<builder>)"

box(type, def) ::= "<if (boxFunction.(type))><boxer.(type)>(<def>)<else><def><endif>"

boxMap(type, box) ::= "<if (isMessage.(type))><box>(it.key, it.value)<else><endif>"

nullable ::= ["MESSAGE":"?", default:""]

deserializeType(p) ::= <%
    <if (p.repeated || p.map)>
        Mutable
    <endif>
    <p.type>
    <if ((p.wrapped && !isMessage.(p.messageType)) || p.nonNullOption || p.repeated)>
        ?
    <endif>
%>

deserializeValue(p) ::= <%
    <if (p.repeated || isMessage.(p.messageType) || p.wrapped)>
        null
    <else>
        <p.defaultValue>
    <endif>
%>

requireNotNullMessage(p) ::= <%
    "<p.name> specified nonnull with (protokt.<if (p.oneOf)>oneof<else>property<endif>).non_null but was null"
%>

deserializeWrapper(v) ::= <%
    <if (p.nonNullOption)>
        requireNotNull(<p.name>) {<\n>
            <t()><requireNotNullMessage(p)><\n>
        }
    <else>
        <if (p.map)>
            finishMap(<v>)
        <elseif (p.repeated)>
            finishList(<v>)
        <else>
            <v>
            <if (p.wrapped && !p.nullable)>
                <\ >?: <p.defaultValue>
            <elseif (entry.entry && isMessage.(p.messageType))>
                <\ >?: <entry.vType> {}
            <endif>
        <endif>
    <endif>
%>

deserializeVar(p) ::= <%
    <p.name>
    <if (isMessage.(p.messageType) || p.repeated || p.oneOf || p.nullable || p.wrapped)>
    : <deserializeType(p)>
    <endif>
    <\ >= <deserializeValue(p)>
%>

concatWithScope(scope, value) ::= "<scope>.<value>"

defaultValue(field, type, name) ::= <%
    <if (field.map)>
        emptyMap()
    <elseif (field.repeated)>
        emptyList()
    <elseif (isGeneratedType.(type))>
        <name><kotlinDefaultValues.(type)>
    <else>
        <kotlinDefaultValues.(type)>
    <endif>
%>

defaultConstructorExp() ::= <%
    <if (
        ((isScalar.(p.messageType) || isBytes.(p.messageType)) && !p.wrapped) ||
        p.repeated ||
        p.nullable ||
        isEnum.(p.messageType)
    )>
        <\ >= <p.defaultValue>
    <endif>
%>

nonDefaultValue(field, name) ::= <%
    <if (field.repeated)>(<field.fieldName>.isNotEmpty())<\ >
    <elseif (isBytes.(field.type))>(<name>.isNotEmpty())<\ >
    <elseif (isMessage.(field.type))>(<field.fieldName> != null)<\ >
    <elseif (isEnum.(field.type))>(<name>.value != 0)<\ >
    <elseif (isScalar.(field.type))>
        <if (isBool.(field.type))>(<name>)<\ >
        <else>(<name> != <kotlinDefaultValues.(field.type)>)<\ >
        <endif>
    <endif>
%>

iterationVar() ::= "it"

serialize(field, name, tag, box, options) ::= <<
<if (field.repeated && field.packed)>
serializer
        .write(Tag(<tag>))
        .write(UInt32(<name>.sumBy { sizeof(<box(field.type, iterationVar())>) }))
    <name>.forEach {
        serializer.write(<box(field.type, options.fieldAccess)>)
    }<\\>
<elseif (field.map)>
<name>.entries.forEach {
        serializer
            .write(Tag(<tag>))
            .write(<box>)
    }<\\>
<elseif (field.repeated)>
<name>.forEach {
        serializer.write(Tag(<tag>)).write(<box(field.type, options.fieldAccess)>)
    }<\\>
<else>
serializer.write(Tag(<tag>)).write(<box>)<\\>
<endif>
>>

deserialize(field, type, read, lhs, options) ::= <<
<if (field.map)>
(<lhs> ?: mutableMapOf()).apply {
        deserializer.readRepeated(false) {
            <read>
                .let { put(it.key, it.value) }
        }
    }<\\>
<elseif (field.repeated)>
(<lhs> ?: mutableListOf()).apply {
        deserializer.readRepeated(<field.packed>) {
            add(<wrapDeserializeRead(options, deserializerRead(read))>)
        }
    }<\\>
<else>
<wrapDeserializeRead(options, deserializerRead(read))><\\>
<endif>
>>

deserializerRead(read) ::= "deserializer.<read>"

standard(field, any, nullable) ::= <%
    <if (field.map)>
        Map\<<any.kType>, <any.vType>>
    <elseif (field.repeated)>
        List\<<any>>
    <else>
        <type(field, any, nullable, false)>
    <endif>
%>

type(field, any, nullable, oneof) ::= <%
    <if ((oneof || isMessage.(field.type)) && nullable)>
        <any>?
    <else>
        <any>
    <endif>
%>

sizeof(name, field, type, options) ::= <<
<if(field.map)><\\>
sizeofMap(<name>, Tag(<field.number>)) { k, v ->
        <type>.sizeof(k, v)
    }<\\>
<elseif(field.repeated && field.packed)><\\>
sizeof(Tag(<field.number>)) +
    <name>
        .sumBy { sizeof(<box(field.type, iterationVar())>) }
        .let { it + sizeof(UInt32(it)) }<\\>
<elseif(field.repeated && !field.map)><\\>
(sizeof(Tag(<field.number>)) * <name>.size) +
        <name>.sumBy { sizeof(<box(field.type, options.fieldAccess)>) }<\\>
<else><\\>
sizeof(Tag(<field.number>)) + <options.fieldSizeof><\\>
<endif>
>>

fieldSizeof(field, name) ::= <%
    sizeof(<box(field.type, name)>)
%>

blockComment(contents) ::= <<
<if (contents)><\\>
/**
 *<contents:{ln |<ln>};separator="\n *">
 */
<endif>
>>

t() ::= "    "
