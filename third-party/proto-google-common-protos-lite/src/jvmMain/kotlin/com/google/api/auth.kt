@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/auth.proto
package com.google.api

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * `Authentication` defines the authentication configuration for API methods provided by an API
 * service.
 *
 *  Example:
 *
 *      name: calendar.googleapis.com     authentication:       providers:       - id:
 * google_calendar_auth         jwks_uri: https://www.googleapis.com/oauth2/v1/certs         issuer:
 * https://securetoken.google.com       rules:       - selector: "*"         requirements:
 * provider_id: google_calendar_auth       - selector: google.calendar.Delegate         oauth:
 *  canonical_scopes: https://www.googleapis.com/auth/calendar.read
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.Authentication")
class Authentication private constructor(
    /**
     * A list of authentication rules that apply to individual API methods.
     *
     *  **NOTE:** All service configuration rules follow "last one wins" order.
     */
    val rules: List<AuthenticationRule>,
    /**
     * Defines a set of authentication providers that a service supports.
     */
    val providers: List<AuthProvider>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (rules.isNotEmpty()) {
            result += (sizeof(Tag(3)) * rules.size) + rules.sumOf { sizeof(it) }
        }
        if (providers.isNotEmpty()) {
            result += (sizeof(Tag(4)) * providers.size) + providers.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (rules.isNotEmpty()) {
            rules.forEach { serializer.write(Tag(26)).write(it) }
        }
        if (providers.isNotEmpty()) {
            providers.forEach { serializer.write(Tag(34)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Authentication &&
        other.rules == rules &&
        other.providers == providers &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + rules.hashCode()
        result = 31 * result + providers.hashCode()
        return result
    }

    override fun toString(): String = "Authentication(" +
        "rules=$rules, " +
        "providers=$providers" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AuthenticationDsl.() -> Unit): Authentication =
            Authentication.Deserializer {
        rules = this@Authentication.rules
        providers = this@Authentication.providers
        unknownFields = this@Authentication.unknownFields
        dsl()
    }

    class AuthenticationDsl {
        var rules: List<AuthenticationRule> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var providers: List<AuthProvider> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Authentication = Authentication(finishList(rules),
        finishList(providers),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Authentication>,
            (AuthenticationDsl.() -> Unit) -> Authentication {
        override fun deserialize(deserializer: KtMessageDeserializer): Authentication {
            var rules : MutableList<AuthenticationRule>? = null
            var providers : MutableList<AuthProvider>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Authentication(finishList(rules),
                            finishList(providers),
                            UnknownFieldSet.from(unknownFields))
                    26 -> rules = (rules ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {

                                    add(deserializer.readMessage(com.google.api.AuthenticationRule))
                                   }
                               }
                    34 -> providers = (providers ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.AuthProvider))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AuthenticationDsl.() -> Unit): Authentication =
                AuthenticationDsl().apply(dsl).build()
    }
}

/**
 * Authentication rules for the service.
 *
 *  By default, if a method has any authentication requirements, every request must include a valid
 * credential matching one of the requirements. It's an error to include more than one kind of
 * credential in a single request.
 *
 *  If a method doesn't have any auth requirements, request credentials will be ignored.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.AuthenticationRule")
class AuthenticationRule private constructor(
    /**
     * Selects the methods to which this rule applies.
     *
     *  Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
     */
    val selector: String,
    /**
     * The requirements for OAuth credentials.
     */
    val oauth: OAuthRequirements?,
    /**
     * If true, the service accepts API keys without any other credential. This flag only applies to
     * HTTP and gRPC requests.
     */
    val allowWithoutCredential: Boolean,
    /**
     * Requirements for additional authentication providers.
     */
    val requirements: List<AuthRequirement>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (selector.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(selector)
        }
        if (oauth  != null) {
            result += sizeof(Tag(2)) + sizeof(oauth)
        }
        if (allowWithoutCredential) {
            result += sizeof(Tag(5)) + sizeof(allowWithoutCredential)
        }
        if (requirements.isNotEmpty()) {
            result += (sizeof(Tag(7)) * requirements.size) + requirements.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (selector.isNotEmpty()) {
            serializer.write(Tag(10)).write(selector)
        }
        if (oauth  != null) {
            serializer.write(Tag(18)).write(oauth)
        }
        if (allowWithoutCredential) {
            serializer.write(Tag(40)).write(allowWithoutCredential)
        }
        if (requirements.isNotEmpty()) {
            requirements.forEach { serializer.write(Tag(58)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is AuthenticationRule &&
        other.selector == selector &&
        other.oauth == oauth &&
        other.allowWithoutCredential == allowWithoutCredential &&
        other.requirements == requirements &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + selector.hashCode()
        result = 31 * result + oauth.hashCode()
        result = 31 * result + allowWithoutCredential.hashCode()
        result = 31 * result + requirements.hashCode()
        return result
    }

    override fun toString(): String = "AuthenticationRule(" +
        "selector=$selector, " +
        "oauth=$oauth, " +
        "allowWithoutCredential=$allowWithoutCredential, " +
        "requirements=$requirements" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AuthenticationRuleDsl.() -> Unit): AuthenticationRule =
            AuthenticationRule.Deserializer {
        selector = this@AuthenticationRule.selector
        oauth = this@AuthenticationRule.oauth
        allowWithoutCredential = this@AuthenticationRule.allowWithoutCredential
        requirements = this@AuthenticationRule.requirements
        unknownFields = this@AuthenticationRule.unknownFields
        dsl()
    }

    class AuthenticationRuleDsl {
        var selector: String = ""

        var oauth: OAuthRequirements? = null

        var allowWithoutCredential: Boolean = false

        var requirements: List<AuthRequirement> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): AuthenticationRule = AuthenticationRule(selector,
        oauth,
        allowWithoutCredential,
        finishList(requirements),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<AuthenticationRule>,
            (AuthenticationRuleDsl.() -> Unit) -> AuthenticationRule {
        override fun deserialize(deserializer: KtMessageDeserializer): AuthenticationRule {
            var selector = ""
            var oauth : OAuthRequirements? = null
            var allowWithoutCredential = false
            var requirements : MutableList<AuthRequirement>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return AuthenticationRule(selector,
                            oauth,
                            allowWithoutCredential,
                            finishList(requirements),
                            UnknownFieldSet.from(unknownFields))
                    10 -> selector = deserializer.readString()
                    18 -> oauth = deserializer.readMessage(com.google.api.OAuthRequirements)
                    40 -> allowWithoutCredential = deserializer.readBool()
                    58 -> requirements = (requirements ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.AuthRequirement))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AuthenticationRuleDsl.() -> Unit): AuthenticationRule =
                AuthenticationRuleDsl().apply(dsl).build()
    }
}

/**
 * Specifies a location to extract JWT from an API request.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.JwtLocation")
class JwtLocation private constructor(
    val `in`: In?,
    /**
     * The value prefix. The value format is "value_prefix{token}" Only applies to "in" header type.
     * Must be empty for "in" query type. If not empty, the header value has to match (case sensitive)
     * this prefix. If not matched, JWT will not be extracted. If matched, JWT will be extracted after
     * the prefix is removed.
     *
     *  For example, for "Authorization: Bearer {JWT}", value_prefix="Bearer " with a space at the
     * end.
     */
    val valuePrefix: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        when (`in`) {
            is JwtLocation.In.Header -> {
                result += sizeof(Tag(1)) + sizeof(`in`.header)}
            is JwtLocation.In.Query -> {
                result += sizeof(Tag(2)) + sizeof(`in`.query)}
            null -> Unit
        }
        if (valuePrefix.isNotEmpty()) {
            result += sizeof(Tag(3)) + sizeof(valuePrefix)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        when (`in`) {
            is JwtLocation.In.Header -> {
                serializer.write(Tag(10)).write(`in`.header)
            }
            is JwtLocation.In.Query -> {
                serializer.write(Tag(18)).write(`in`.query)
            }
            null -> Unit
        }
        if (valuePrefix.isNotEmpty()) {
            serializer.write(Tag(26)).write(valuePrefix)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is JwtLocation &&
        other.`in` == `in` &&
        other.valuePrefix == valuePrefix &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + `in`.hashCode()
        result = 31 * result + valuePrefix.hashCode()
        return result
    }

    override fun toString(): String = "JwtLocation(" +
        "`in`=$`in`, " +
        "valuePrefix=$valuePrefix" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: JwtLocationDsl.() -> Unit): JwtLocation = JwtLocation.Deserializer {
        `in` = this@JwtLocation.`in`
        valuePrefix = this@JwtLocation.valuePrefix
        unknownFields = this@JwtLocation.unknownFields
        dsl()
    }

    sealed class In {
        /**
         * Specifies HTTP header name to extract JWT token.
         */
        data class Header(
            val `header`: String,
        ) : In()

        /**
         * Specifies URL query parameter name to extract JWT token.
         */
        data class Query(
            val query: String,
        ) : In()
    }

    class JwtLocationDsl {
        var `in`: In? = null

        var valuePrefix: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): JwtLocation = JwtLocation(`in`,
        valuePrefix,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<JwtLocation>,
            (JwtLocationDsl.() -> Unit) -> JwtLocation {
        override fun deserialize(deserializer: KtMessageDeserializer): JwtLocation {
            var `in` : In? = null
            var valuePrefix = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return JwtLocation(`in`,
                            valuePrefix,
                            UnknownFieldSet.from(unknownFields))
                    10 -> `in` = In.Header(deserializer.readString())
                    18 -> `in` = In.Query(deserializer.readString())
                    26 -> valuePrefix = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: JwtLocationDsl.() -> Unit): JwtLocation =
                JwtLocationDsl().apply(dsl).build()
    }
}

/**
 * Configuration for an authentication provider, including support for [JSON Web Token
 * (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.AuthProvider")
class AuthProvider private constructor(
    /**
     * The unique identifier of the auth provider. It will be referred to by
     * `AuthRequirement.provider_id`.
     *
     *  Example: "bookstore_auth".
     */
    val id: String,
    /**
     * Identifies the principal that issued the JWT. See
     * https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.1 Usually a URL or an
     * email address.
     *
     *  Example: https://securetoken.google.com Example:
     * 1234567-compute@developer.gserviceaccount.com
     */
    val issuer: String,
    /**
     * URL of the provider's public key set to validate signature of the JWT. See [OpenID
     * Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
     * Optional if the key set document:  - can be retrieved from    [OpenID
     * Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)    of the issuer.  - can
     * be inferred from the email domain of the issuer (e.g. a Google  service account).
     *
     *  Example: https://www.googleapis.com/oauth2/v1/certs
     */
    val jwksUri: String,
    /**
     * The list of JWT
     * [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3). that
     * are allowed to access. A JWT containing any of these audiences will be accepted. When this
     * setting is absent, JWTs with audiences:   -
     * "https://[service.name]/[google.protobuf.Api.name]"   - "https://[service.name]/" will be
     * accepted. For example, if no audiences are in the setting, LibraryService API will accept JWTs
     * with the following audiences:   -
     * https://library-example.googleapis.com/google.example.library.v1.LibraryService   -
     * https://library-example.googleapis.com/
     *
     *  Example:
     *
     *      audiences: bookstore_android.apps.googleusercontent.com,
     * bookstore_web.apps.googleusercontent.com
     */
    val audiences: String,
    /**
     * Redirect URL if JWT token is required but not present or is expired. Implement
     * authorizationUrl of securityDefinitions in OpenAPI spec.
     */
    val authorizationUrl: String,
    /**
     * Defines the locations to extract the JWT.
     *
     *  JWT locations can be either from HTTP headers or URL query parameters. The rule is that the
     * first match wins. The checking order is: checking all headers first, then URL query parameters.
     *
     *  If not specified,  default to use following 3 locations:    1) Authorization: Bearer    2)
     * x-goog-iap-jwt-assertion    3) access_token query parameter
     *
     *  Default locations can be specified as followings:    jwt_locations:    - header:
     * Authorization      value_prefix: "Bearer "    - header: x-goog-iap-jwt-assertion    - query:
     * access_token
     */
    val jwtLocations: List<JwtLocation>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (id.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(id)
        }
        if (issuer.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(issuer)
        }
        if (jwksUri.isNotEmpty()) {
            result += sizeof(Tag(3)) + sizeof(jwksUri)
        }
        if (audiences.isNotEmpty()) {
            result += sizeof(Tag(4)) + sizeof(audiences)
        }
        if (authorizationUrl.isNotEmpty()) {
            result += sizeof(Tag(5)) + sizeof(authorizationUrl)
        }
        if (jwtLocations.isNotEmpty()) {
            result += (sizeof(Tag(6)) * jwtLocations.size) + jwtLocations.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (id.isNotEmpty()) {
            serializer.write(Tag(10)).write(id)
        }
        if (issuer.isNotEmpty()) {
            serializer.write(Tag(18)).write(issuer)
        }
        if (jwksUri.isNotEmpty()) {
            serializer.write(Tag(26)).write(jwksUri)
        }
        if (audiences.isNotEmpty()) {
            serializer.write(Tag(34)).write(audiences)
        }
        if (authorizationUrl.isNotEmpty()) {
            serializer.write(Tag(42)).write(authorizationUrl)
        }
        if (jwtLocations.isNotEmpty()) {
            jwtLocations.forEach { serializer.write(Tag(50)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is AuthProvider &&
        other.id == id &&
        other.issuer == issuer &&
        other.jwksUri == jwksUri &&
        other.audiences == audiences &&
        other.authorizationUrl == authorizationUrl &&
        other.jwtLocations == jwtLocations &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + id.hashCode()
        result = 31 * result + issuer.hashCode()
        result = 31 * result + jwksUri.hashCode()
        result = 31 * result + audiences.hashCode()
        result = 31 * result + authorizationUrl.hashCode()
        result = 31 * result + jwtLocations.hashCode()
        return result
    }

    override fun toString(): String = "AuthProvider(" +
        "id=$id, " +
        "issuer=$issuer, " +
        "jwksUri=$jwksUri, " +
        "audiences=$audiences, " +
        "authorizationUrl=$authorizationUrl, " +
        "jwtLocations=$jwtLocations" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AuthProviderDsl.() -> Unit): AuthProvider = AuthProvider.Deserializer {
        id = this@AuthProvider.id
        issuer = this@AuthProvider.issuer
        jwksUri = this@AuthProvider.jwksUri
        audiences = this@AuthProvider.audiences
        authorizationUrl = this@AuthProvider.authorizationUrl
        jwtLocations = this@AuthProvider.jwtLocations
        unknownFields = this@AuthProvider.unknownFields
        dsl()
    }

    class AuthProviderDsl {
        var id: String = ""

        var issuer: String = ""

        var jwksUri: String = ""

        var audiences: String = ""

        var authorizationUrl: String = ""

        var jwtLocations: List<JwtLocation> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): AuthProvider = AuthProvider(id,
        issuer,
        jwksUri,
        audiences,
        authorizationUrl,
        finishList(jwtLocations),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<AuthProvider>,
            (AuthProviderDsl.() -> Unit) -> AuthProvider {
        override fun deserialize(deserializer: KtMessageDeserializer): AuthProvider {
            var id = ""
            var issuer = ""
            var jwksUri = ""
            var audiences = ""
            var authorizationUrl = ""
            var jwtLocations : MutableList<JwtLocation>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return AuthProvider(id,
                            issuer,
                            jwksUri,
                            audiences,
                            authorizationUrl,
                            finishList(jwtLocations),
                            UnknownFieldSet.from(unknownFields))
                    10 -> id = deserializer.readString()
                    18 -> issuer = deserializer.readString()
                    26 -> jwksUri = deserializer.readString()
                    34 -> audiences = deserializer.readString()
                    42 -> authorizationUrl = deserializer.readString()
                    50 -> jwtLocations = (jwtLocations ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.JwtLocation))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AuthProviderDsl.() -> Unit): AuthProvider =
                AuthProviderDsl().apply(dsl).build()
    }
}

/**
 * OAuth scopes are a way to define data and permissions on data. For example, there are scopes
 * defined for "Read-only access to Google Calendar" and "Access to Cloud Platform". Users can consent
 * to a scope for an application, giving it permission to access that data on their behalf.
 *
 *  OAuth scope specifications should be fairly coarse grained; a user will need to see and
 * understand the text description of what your scope means.
 *
 *  In most cases: use one or at most two OAuth scopes for an entire family of products. If your
 * product has multiple APIs, you should probably be sharing the OAuth scope across all of those APIs.
 *
 *  When you need finer grained OAuth consent screens: talk with your product management about how
 * developers will use them in practice.
 *
 *  Please note that even though each of the canonical scopes is enough for a request to be accepted
 * and passed to the backend, a request can still fail due to the backend requiring additional scopes
 * or permissions.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.OAuthRequirements")
class OAuthRequirements private constructor(
    /**
     * The list of publicly documented OAuth scopes that are allowed access. An OAuth token
     * containing any of these scopes will be accepted.
     *
     *  Example:
     *
     *       canonical_scopes: https://www.googleapis.com/auth/calendar,
     * https://www.googleapis.com/auth/calendar.read
     */
    val canonicalScopes: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (canonicalScopes.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(canonicalScopes)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (canonicalScopes.isNotEmpty()) {
            serializer.write(Tag(10)).write(canonicalScopes)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is OAuthRequirements &&
        other.canonicalScopes == canonicalScopes &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + canonicalScopes.hashCode()
        return result
    }

    override fun toString(): String = "OAuthRequirements(" +
        "canonicalScopes=$canonicalScopes" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: OAuthRequirementsDsl.() -> Unit): OAuthRequirements =
            OAuthRequirements.Deserializer {
        canonicalScopes = this@OAuthRequirements.canonicalScopes
        unknownFields = this@OAuthRequirements.unknownFields
        dsl()
    }

    class OAuthRequirementsDsl {
        var canonicalScopes: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): OAuthRequirements = OAuthRequirements(canonicalScopes,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<OAuthRequirements>,
            (OAuthRequirementsDsl.() -> Unit) -> OAuthRequirements {
        override fun deserialize(deserializer: KtMessageDeserializer): OAuthRequirements {
            var canonicalScopes = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return OAuthRequirements(canonicalScopes,
                            UnknownFieldSet.from(unknownFields))
                    10 -> canonicalScopes = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: OAuthRequirementsDsl.() -> Unit): OAuthRequirements =
                OAuthRequirementsDsl().apply(dsl).build()
    }
}

/**
 * User-defined authentication requirements, including support for [JSON Web Token
 * (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.AuthRequirement")
class AuthRequirement private constructor(
    /**
     * [id][google.api.AuthProvider.id] from authentication provider.
     *
     *  Example:
     *
     *      provider_id: bookstore_auth
     */
    val providerId: String,
    /**
     * NOTE: This will be deprecated soon, once AuthProvider.audiences is implemented and accepted
     * in all the runtime components.
     *
     *  The list of JWT
     * [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3). that
     * are allowed to access. A JWT containing any of these audiences will be accepted. When this
     * setting is absent, only JWTs with audience
     * "https://[Service_name][google.api.Service.name]/[API_name][google.protobuf.Api.name]" will be
     * accepted. For example, if no audiences are in the setting, LibraryService API will only accept
     * JWTs with the following audience
     * "https://library-example.googleapis.com/google.example.library.v1.LibraryService".
     *
     *  Example:
     *
     *      audiences: bookstore_android.apps.googleusercontent.com,
     * bookstore_web.apps.googleusercontent.com
     */
    val audiences: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (providerId.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(providerId)
        }
        if (audiences.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(audiences)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (providerId.isNotEmpty()) {
            serializer.write(Tag(10)).write(providerId)
        }
        if (audiences.isNotEmpty()) {
            serializer.write(Tag(18)).write(audiences)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is AuthRequirement &&
        other.providerId == providerId &&
        other.audiences == audiences &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + providerId.hashCode()
        result = 31 * result + audiences.hashCode()
        return result
    }

    override fun toString(): String = "AuthRequirement(" +
        "providerId=$providerId, " +
        "audiences=$audiences" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AuthRequirementDsl.() -> Unit): AuthRequirement =
            AuthRequirement.Deserializer {
        providerId = this@AuthRequirement.providerId
        audiences = this@AuthRequirement.audiences
        unknownFields = this@AuthRequirement.unknownFields
        dsl()
    }

    class AuthRequirementDsl {
        var providerId: String = ""

        var audiences: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): AuthRequirement = AuthRequirement(providerId,
        audiences,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<AuthRequirement>,
            (AuthRequirementDsl.() -> Unit) -> AuthRequirement {
        override fun deserialize(deserializer: KtMessageDeserializer): AuthRequirement {
            var providerId = ""
            var audiences = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return AuthRequirement(providerId,
                            audiences,
                            UnknownFieldSet.from(unknownFields))
                    10 -> providerId = deserializer.readString()
                    18 -> audiences = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AuthRequirementDsl.() -> Unit): AuthRequirement =
                AuthRequirementDsl().apply(dsl).build()
    }
}
