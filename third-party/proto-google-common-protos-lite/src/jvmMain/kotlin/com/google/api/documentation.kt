@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/documentation.proto
package com.google.api

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * `Documentation` provides the information for describing a service.
 *
 *  Example: <pre><code>documentation:   summary: >     The Google Calendar API gives access     to
 * most calendar features.   pages:   - name: Overview     content: &#40;== include
 * google/foo/overview.md ==&#41;   - name: Tutorial     content: &#40;== include
 * google/foo/tutorial.md ==&#41;     subpages;     - name: Java       content: &#40;== include
 * google/foo/tutorial_java.md ==&#41;   rules:   - selector: google.calendar.Calendar.Get
 * description: >       ...   - selector: google.calendar.Calendar.Put     description: >       ...
 * </code></pre> Documentation is provided in markdown syntax. In addition to standard markdown
 * features, definition lists, tables and fenced code blocks are supported. Section headers can be
 * provided and are interpreted relative to the section nesting of the context where a documentation
 * fragment is embedded.
 *
 *  Documentation from the IDL is merged with documentation defined via the config at normalization
 * time, where documentation provided by config rules overrides IDL provided.
 *
 *  A number of constructs specific to the API platform are supported in documentation text.
 *
 *  In order to reference a proto element, the following notation can be used:
 * <pre><code>&#91;fully.qualified.proto.name]&#91;]</code></pre> To override the display text used for
 * the link, this can be used: <pre><code>&#91;display
 * text]&#91;fully.qualified.proto.name]</code></pre> Text can be excluded from doc using the following
 * notation: <pre><code>&#40;-- internal comment --&#41;</code></pre>
 *
 *  A few directives are available in documentation. Note that directives must appear on a single
 * line to be properly identified. The `include` directive includes a markdown file from an external
 * source: <pre><code>&#40;== include path/to/file ==&#41;</code></pre> The `resource_for` directive
 * marks a message to be the resource of a collection in REST view. If it is not specified, tools
 * attempt to infer the resource from the operations in a collection: <pre><code>&#40;== resource_for
 * v1.shelves.books ==&#41;</code></pre> The directive `suppress_warning` does not directly affect
 * documentation and is documented together with service config validation.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.Documentation")
class Documentation private constructor(
    /**
     * A short summary of what the service does. Can only be provided by plain text.
     */
    val summary: String,
    /**
     * Declares a single overview page. For example: <pre><code>documentation:   summary: ...
     * overview: &#40;== include overview.md ==&#41; </code></pre> This is a shortcut for the following
     * declaration (using pages style): <pre><code>documentation:   summary: ...   pages:   - name:
     * Overview     content: &#40;== include overview.md ==&#41; </code></pre> Note: you cannot specify
     * both `overview` field and `pages` field.
     */
    val overview: String,
    /**
     * A list of documentation rules that apply to individual API elements.
     *
     *  **NOTE:** All service configuration rules follow "last one wins" order.
     */
    val rules: List<DocumentationRule>,
    /**
     * The URL to the root of documentation.
     */
    val documentationRootUrl: String,
    /**
     * The top level pages for the documentation set.
     */
    val pages: List<Page>,
    /**
     * Specifies the service root url if the default one (the service name from the yaml file) is
     * not suitable. This can be seen in any fully specified service urls as well as sections that show
     * a base that other urls are relative to.
     */
    val serviceRootUrl: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (summary.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(summary)
        }
        if (overview.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(overview)
        }
        if (rules.isNotEmpty()) {
            result += (sizeof(Tag(3)) * rules.size) + rules.sumOf { sizeof(it) }
        }
        if (documentationRootUrl.isNotEmpty()) {
            result += sizeof(Tag(4)) + sizeof(documentationRootUrl)
        }
        if (pages.isNotEmpty()) {
            result += (sizeof(Tag(5)) * pages.size) + pages.sumOf { sizeof(it) }
        }
        if (serviceRootUrl.isNotEmpty()) {
            result += sizeof(Tag(6)) + sizeof(serviceRootUrl)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (summary.isNotEmpty()) {
            serializer.write(Tag(10)).write(summary)
        }
        if (overview.isNotEmpty()) {
            serializer.write(Tag(18)).write(overview)
        }
        if (rules.isNotEmpty()) {
            rules.forEach { serializer.write(Tag(26)).write(it) }
        }
        if (documentationRootUrl.isNotEmpty()) {
            serializer.write(Tag(34)).write(documentationRootUrl)
        }
        if (pages.isNotEmpty()) {
            pages.forEach { serializer.write(Tag(42)).write(it) }
        }
        if (serviceRootUrl.isNotEmpty()) {
            serializer.write(Tag(50)).write(serviceRootUrl)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Documentation &&
        other.summary == summary &&
        other.overview == overview &&
        other.rules == rules &&
        other.documentationRootUrl == documentationRootUrl &&
        other.pages == pages &&
        other.serviceRootUrl == serviceRootUrl &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + summary.hashCode()
        result = 31 * result + overview.hashCode()
        result = 31 * result + rules.hashCode()
        result = 31 * result + documentationRootUrl.hashCode()
        result = 31 * result + pages.hashCode()
        result = 31 * result + serviceRootUrl.hashCode()
        return result
    }

    override fun toString(): String = "Documentation(" +
        "summary=$summary, " +
        "overview=$overview, " +
        "rules=$rules, " +
        "documentationRootUrl=$documentationRootUrl, " +
        "pages=$pages, " +
        "serviceRootUrl=$serviceRootUrl" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: DocumentationDsl.() -> Unit): Documentation = Documentation.Deserializer {
        summary = this@Documentation.summary
        overview = this@Documentation.overview
        rules = this@Documentation.rules
        documentationRootUrl = this@Documentation.documentationRootUrl
        pages = this@Documentation.pages
        serviceRootUrl = this@Documentation.serviceRootUrl
        unknownFields = this@Documentation.unknownFields
        dsl()
    }

    class DocumentationDsl {
        var summary: String = ""

        var overview: String = ""

        var rules: List<DocumentationRule> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var documentationRootUrl: String = ""

        var pages: List<Page> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var serviceRootUrl: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Documentation = Documentation(summary,
        overview,
        finishList(rules),
        documentationRootUrl,
        finishList(pages),
        serviceRootUrl,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Documentation>,
            (DocumentationDsl.() -> Unit) -> Documentation {
        override fun deserialize(deserializer: KtMessageDeserializer): Documentation {
            var summary = ""
            var overview = ""
            var rules : MutableList<DocumentationRule>? = null
            var documentationRootUrl = ""
            var pages : MutableList<Page>? = null
            var serviceRootUrl = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Documentation(summary,
                            overview,
                            finishList(rules),
                            documentationRootUrl,
                            finishList(pages),
                            serviceRootUrl,
                            UnknownFieldSet.from(unknownFields))
                    10 -> summary = deserializer.readString()
                    18 -> overview = deserializer.readString()
                    26 -> rules = (rules ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {

                                    add(deserializer.readMessage(com.google.api.DocumentationRule))
                                   }
                               }
                    34 -> documentationRootUrl = deserializer.readString()
                    42 -> pages = (pages ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.Page))
                                   }
                               }
                    50 -> serviceRootUrl = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: DocumentationDsl.() -> Unit): Documentation =
                DocumentationDsl().apply(dsl).build()
    }
}

/**
 * A documentation rule provides information about individual API elements.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.DocumentationRule")
class DocumentationRule private constructor(
    /**
     * The selector is a comma-separated list of patterns. Each pattern is a qualified name of the
     * element which may end in "*", indicating a wildcard. Wildcards are only allowed at the end and
     * for a whole component of the qualified name, i.e. "foo.*" is ok, but not "foo.b*" or
     * "foo.*.bar". A wildcard will match one or more components. To specify a default for all
     * applicable elements, the whole pattern "*" is used.
     */
    val selector: String,
    /**
     * Description of the selected API(s).
     */
    val description: String,
    /**
     * Deprecation description of the selected element(s). It can be provided if an element is
     * marked as `deprecated`.
     */
    val deprecationDescription: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (selector.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(selector)
        }
        if (description.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(description)
        }
        if (deprecationDescription.isNotEmpty()) {
            result += sizeof(Tag(3)) + sizeof(deprecationDescription)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (selector.isNotEmpty()) {
            serializer.write(Tag(10)).write(selector)
        }
        if (description.isNotEmpty()) {
            serializer.write(Tag(18)).write(description)
        }
        if (deprecationDescription.isNotEmpty()) {
            serializer.write(Tag(26)).write(deprecationDescription)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is DocumentationRule &&
        other.selector == selector &&
        other.description == description &&
        other.deprecationDescription == deprecationDescription &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + selector.hashCode()
        result = 31 * result + description.hashCode()
        result = 31 * result + deprecationDescription.hashCode()
        return result
    }

    override fun toString(): String = "DocumentationRule(" +
        "selector=$selector, " +
        "description=$description, " +
        "deprecationDescription=$deprecationDescription" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: DocumentationRuleDsl.() -> Unit): DocumentationRule =
            DocumentationRule.Deserializer {
        selector = this@DocumentationRule.selector
        description = this@DocumentationRule.description
        deprecationDescription = this@DocumentationRule.deprecationDescription
        unknownFields = this@DocumentationRule.unknownFields
        dsl()
    }

    class DocumentationRuleDsl {
        var selector: String = ""

        var description: String = ""

        var deprecationDescription: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): DocumentationRule = DocumentationRule(selector,
        description,
        deprecationDescription,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<DocumentationRule>,
            (DocumentationRuleDsl.() -> Unit) -> DocumentationRule {
        override fun deserialize(deserializer: KtMessageDeserializer): DocumentationRule {
            var selector = ""
            var description = ""
            var deprecationDescription = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return DocumentationRule(selector,
                            description,
                            deprecationDescription,
                            UnknownFieldSet.from(unknownFields))
                    10 -> selector = deserializer.readString()
                    18 -> description = deserializer.readString()
                    26 -> deprecationDescription = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: DocumentationRuleDsl.() -> Unit): DocumentationRule =
                DocumentationRuleDsl().apply(dsl).build()
    }
}

/**
 * Represents a documentation page. A page can contain subpages to represent nested documentation
 * set structure.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.Page")
class Page private constructor(
    /**
     * The name of the page. It will be used as an identity of the page to generate URI of the page,
     * text of the link to this page in navigation, etc. The full page name (start from the root page
     * name to this page concatenated with `.`) can be used as reference to the page in your
     * documentation. For example: <pre><code>pages: - name: Tutorial   content: &#40;== include
     * tutorial.md ==&#41;   subpages:   - name: Java     content: &#40;== include tutorial_java.md
     * ==&#41; </code></pre> You can reference `Java` page using Markdown reference link syntax:
     * `[Java][Tutorial.Java]`.
     */
    val name: String,
    /**
     * The Markdown content of the page. You can use <code>&#40;== include {path} ==&#41;</code> to
     * include content from a Markdown file.
     */
    val content: String,
    /**
     * Subpages of this page. The order of subpages specified here will be honored in the generated
     * docset.
     */
    val subpages: List<Page>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (name.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(name)
        }
        if (content.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(content)
        }
        if (subpages.isNotEmpty()) {
            result += (sizeof(Tag(3)) * subpages.size) + subpages.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (name.isNotEmpty()) {
            serializer.write(Tag(10)).write(name)
        }
        if (content.isNotEmpty()) {
            serializer.write(Tag(18)).write(content)
        }
        if (subpages.isNotEmpty()) {
            subpages.forEach { serializer.write(Tag(26)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Page &&
        other.name == name &&
        other.content == content &&
        other.subpages == subpages &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + content.hashCode()
        result = 31 * result + subpages.hashCode()
        return result
    }

    override fun toString(): String = "Page(" +
        "name=$name, " +
        "content=$content, " +
        "subpages=$subpages" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: PageDsl.() -> Unit): Page = Page.Deserializer {
        name = this@Page.name
        content = this@Page.content
        subpages = this@Page.subpages
        unknownFields = this@Page.unknownFields
        dsl()
    }

    class PageDsl {
        var name: String = ""

        var content: String = ""

        var subpages: List<Page> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Page = Page(name,
        content,
        finishList(subpages),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Page>, (PageDsl.() -> Unit) -> Page {
        override fun deserialize(deserializer: KtMessageDeserializer): Page {
            var name = ""
            var content = ""
            var subpages : MutableList<Page>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Page(name,
                            content,
                            finishList(subpages),
                            UnknownFieldSet.from(unknownFields))
                    10 -> name = deserializer.readString()
                    18 -> content = deserializer.readString()
                    26 -> subpages = (subpages ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.Page))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: PageDsl.() -> Unit): Page = PageDsl().apply(dsl).build()
    }
}
