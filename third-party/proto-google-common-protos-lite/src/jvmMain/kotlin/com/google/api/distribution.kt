@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/distribution.proto
package com.google.api

import com.toasttab.protokt.Timestamp
import com.toasttab.protokt.rt.Int32
import com.toasttab.protokt.rt.Int64
import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UInt32
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Double
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * `Distribution` contains summary statistics for a population of values. It optionally contains a
 * histogram representing the distribution of those values across a set of buckets.
 *
 *  The summary statistics are the count, mean, sum of the squared deviation from the mean, the
 * minimum, and the maximum of the set of population of values. The histogram is based on a sequence of
 * buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are
 * given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.
 *
 *  Although it is not forbidden, it is generally a bad idea to include non-finite values
 * (infinities or NaNs) in the population of values, as this will render the `mean` and
 * `sum_of_squared_deviation` fields meaningless.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.Distribution")
class Distribution private constructor(
    /**
     * The number of values in the population. Must be non-negative. This value must equal the sum
     * of the values in `bucket_counts` if a histogram is provided.
     */
    val count: Long,
    /**
     * The arithmetic mean of the values in the population. If `count` is zero then this field must
     * be zero.
     */
    val mean: Double,
    /**
     * The sum of squared deviations from the mean of the values in the population. For values x_i
     * this is:
     *
     *      Sum[i=1..n]((x_i - mean)^2)
     *
     *  Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's
     * method for accumulating this sum in one pass.
     *
     *  If `count` is zero then this field must be zero.
     */
    val sumOfSquaredDeviation: Double,
    /**
     * If specified, contains the range of the population values. The field must not be present if
     * the `count` is zero.
     */
    val range: Range?,
    /**
     * Defines the histogram bucket boundaries. If the distribution does not contain a histogram,
     * then omit this field.
     */
    val bucketOptions: BucketOptions?,
    /**
     * The number of values in each bucket of the histogram, as described in `bucket_options`. If
     * the distribution does not have a histogram, then omit this field. If there is a histogram, then
     * the sum of the values in `bucket_counts` must equal the value in the `count` field of the
     * distribution.
     *
     *  If present, `bucket_counts` should contain N values, where N is the number of buckets
     * specified in `bucket_options`. If you supply fewer than N values, the remaining values are
     * assumed to be 0.
     *
     *  The order of the values in `bucket_counts` follows the bucket numbering schemes described
     * for the three bucket types. The first value must be the count for the underflow bucket (number
     * 0). The next N-2 values are the counts for the finite buckets (number 1 through N-2). The N'th
     * value in `bucket_counts` is the count for the overflow bucket (number N-1).
     */
    val bucketCounts: List<Long>,
    /**
     * Must be in increasing order of `value` field.
     */
    val exemplars: List<Exemplar>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (count != 0L) {
            result += sizeof(Tag(1)) + sizeof(Int64(count))
        }
        if (mean != 0.0) {
            result += sizeof(Tag(2)) + sizeof(mean)
        }
        if (sumOfSquaredDeviation != 0.0) {
            result += sizeof(Tag(3)) + sizeof(sumOfSquaredDeviation)
        }
        if (range  != null) {
            result += sizeof(Tag(4)) + sizeof(range)
        }
        if (bucketOptions  != null) {
            result += sizeof(Tag(6)) + sizeof(bucketOptions)
        }
        if (bucketCounts.isNotEmpty()) {
            result += sizeof(Tag(7)) + bucketCounts.sumOf {
                    sizeof(com.toasttab.protokt.rt.Int64(it)) }.let { it + sizeof(UInt32(it)) }
        }
        if (exemplars.isNotEmpty()) {
            result += (sizeof(Tag(10)) * exemplars.size) + exemplars.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (count != 0L) {
            serializer.write(Tag(8)).write(Int64(count))
        }
        if (mean != 0.0) {
            serializer.write(Tag(17)).write(mean)
        }
        if (sumOfSquaredDeviation != 0.0) {
            serializer.write(Tag(25)).write(sumOfSquaredDeviation)
        }
        if (range  != null) {
            serializer.write(Tag(34)).write(range)
        }
        if (bucketOptions  != null) {
            serializer.write(Tag(50)).write(bucketOptions)
        }
        if (bucketCounts.isNotEmpty()) {
            serializer.write(Tag(58)).write(UInt32(bucketCounts.sumOf{sizeof(Int64(it))}))
            bucketCounts.forEach { serializer.write(Int64(it)) }
        }
        if (exemplars.isNotEmpty()) {
            exemplars.forEach { serializer.write(Tag(82)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Distribution &&
        other.count == count &&
        other.mean == mean &&
        other.sumOfSquaredDeviation == sumOfSquaredDeviation &&
        other.range == range &&
        other.bucketOptions == bucketOptions &&
        other.bucketCounts == bucketCounts &&
        other.exemplars == exemplars &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + count.hashCode()
        result = 31 * result + mean.hashCode()
        result = 31 * result + sumOfSquaredDeviation.hashCode()
        result = 31 * result + range.hashCode()
        result = 31 * result + bucketOptions.hashCode()
        result = 31 * result + bucketCounts.hashCode()
        result = 31 * result + exemplars.hashCode()
        return result
    }

    override fun toString(): String = "Distribution(" +
        "count=$count, " +
        "mean=$mean, " +
        "sumOfSquaredDeviation=$sumOfSquaredDeviation, " +
        "range=$range, " +
        "bucketOptions=$bucketOptions, " +
        "bucketCounts=$bucketCounts, " +
        "exemplars=$exemplars" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: DistributionDsl.() -> Unit): Distribution = Distribution.Deserializer {
        count = this@Distribution.count
        mean = this@Distribution.mean
        sumOfSquaredDeviation = this@Distribution.sumOfSquaredDeviation
        range = this@Distribution.range
        bucketOptions = this@Distribution.bucketOptions
        bucketCounts = this@Distribution.bucketCounts
        exemplars = this@Distribution.exemplars
        unknownFields = this@Distribution.unknownFields
        dsl()
    }

    class DistributionDsl {
        var count: Long = 0L

        var mean: Double = 0.0

        var sumOfSquaredDeviation: Double = 0.0

        var range: Range? = null

        var bucketOptions: BucketOptions? = null

        var bucketCounts: List<Long> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var exemplars: List<Exemplar> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Distribution = Distribution(count,
        mean,
        sumOfSquaredDeviation,
        range,
        bucketOptions,
        finishList(bucketCounts),
        finishList(exemplars),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Distribution>,
            (DistributionDsl.() -> Unit) -> Distribution {
        override fun deserialize(deserializer: KtMessageDeserializer): Distribution {
            var count = 0L
            var mean = 0.0
            var sumOfSquaredDeviation = 0.0
            var range : Range? = null
            var bucketOptions : BucketOptions? = null
            var bucketCounts : MutableList<Long>? = null
            var exemplars : MutableList<Exemplar>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Distribution(count,
                            mean,
                            sumOfSquaredDeviation,
                            range,
                            bucketOptions,
                            finishList(bucketCounts),
                            finishList(exemplars),
                            UnknownFieldSet.from(unknownFields))
                    8 -> count = deserializer.readInt64()
                    17 -> mean = deserializer.readDouble()
                    25 -> sumOfSquaredDeviation = deserializer.readDouble()
                    34 -> range = deserializer.readMessage(com.google.api.Distribution.Range)
                    50 -> bucketOptions =
                            deserializer.readMessage(com.google.api.Distribution.BucketOptions)
                    56 -> bucketCounts = (bucketCounts ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readInt64())
                                   }
                               }
                    58 -> bucketCounts = (bucketCounts ?: mutableListOf()).apply {
                                   deserializer.readRepeated(true) {
                                       add(deserializer.readInt64())
                                   }
                               }
                    82 -> exemplars = (exemplars ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {

                                    add(deserializer.readMessage(com.google.api.Distribution.Exemplar))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: DistributionDsl.() -> Unit): Distribution =
                DistributionDsl().apply(dsl).build()
    }

    /**
     * The range of the population values.
     */
    @KtGeneratedMessage("google.api.Range")
    class Range private constructor(
        /**
         * The minimum of the population values.
         */
        val min: Double,
        /**
         * The maximum of the population values.
         */
        val max: Double,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (min != 0.0) {
                result += sizeof(Tag(1)) + sizeof(min)
            }
            if (max != 0.0) {
                result += sizeof(Tag(2)) + sizeof(max)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (min != 0.0) {
                serializer.write(Tag(9)).write(min)
            }
            if (max != 0.0) {
                serializer.write(Tag(17)).write(max)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is Range &&
            other.min == min &&
            other.max == max &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + min.hashCode()
            result = 31 * result + max.hashCode()
            return result
        }

        override fun toString(): String = "Range(" +
            "min=$min, " +
            "max=$max" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: RangeDsl.() -> Unit): Range = Range.Deserializer {
            min = this@Range.min
            max = this@Range.max
            unknownFields = this@Range.unknownFields
            dsl()
        }

        class RangeDsl {
            var min: Double = 0.0

            var max: Double = 0.0

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Range = Range(min,
            max,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Range>, (RangeDsl.() -> Unit) -> Range
                {
            override fun deserialize(deserializer: KtMessageDeserializer): Range {
                var min = 0.0
                var max = 0.0
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Range(min,
                                max,
                                UnknownFieldSet.from(unknownFields))
                        9 -> min = deserializer.readDouble()
                        17 -> max = deserializer.readDouble()
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: RangeDsl.() -> Unit): Range =
                    RangeDsl().apply(dsl).build()
        }
    }

    /**
     * `BucketOptions` describes the bucket boundaries used to create a histogram for the
     * distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket
     * can be specified explicitly. `BucketOptions` does not include the number of values in each
     * bucket.
     *
     *  A bucket has an inclusive lower bound and exclusive upper bound for the values that are
     * counted for that bucket. The upper bound of a bucket must be strictly greater than the lower
     * bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0),
     * zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The
     * buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of
     * bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow
     * bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets
     * are so-called because both bounds are finite.
     */
    @KtGeneratedMessage("google.api.BucketOptions")
    class BucketOptions private constructor(
        /**
         * Exactly one of these three fields must be set.
         */
        val options: Options?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            when (options) {
                is BucketOptions.Options.LinearBuckets -> {
                    result += sizeof(Tag(1)) + sizeof(options.linearBuckets)}
                is BucketOptions.Options.ExponentialBuckets -> {
                    result += sizeof(Tag(2)) + sizeof(options.exponentialBuckets)}
                is BucketOptions.Options.ExplicitBuckets -> {
                    result += sizeof(Tag(3)) + sizeof(options.explicitBuckets)}
                null -> Unit
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            when (options) {
                is BucketOptions.Options.LinearBuckets -> {
                    serializer.write(Tag(10)).write(options.linearBuckets)
                }
                is BucketOptions.Options.ExponentialBuckets -> {
                    serializer.write(Tag(18)).write(options.exponentialBuckets)
                }
                is BucketOptions.Options.ExplicitBuckets -> {
                    serializer.write(Tag(26)).write(options.explicitBuckets)
                }
                null -> Unit
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is BucketOptions &&
            other.options == options &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + options.hashCode()
            return result
        }

        override fun toString(): String = "BucketOptions(" +
            "options=$options" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: BucketOptionsDsl.() -> Unit): BucketOptions =
                BucketOptions.Deserializer {
            options = this@BucketOptions.options
            unknownFields = this@BucketOptions.unknownFields
            dsl()
        }

        sealed class Options {
            /**
             * The linear bucket.
             */
            data class LinearBuckets(
                val linearBuckets: Linear,
            ) : Options()

            /**
             * The exponential buckets.
             */
            data class ExponentialBuckets(
                val exponentialBuckets: Exponential,
            ) : Options()

            /**
             * The explicit buckets.
             */
            data class ExplicitBuckets(
                val explicitBuckets: Explicit,
            ) : Options()
        }

        class BucketOptionsDsl {
            var options: Options? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): BucketOptions = BucketOptions(options,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<BucketOptions>,
                (BucketOptionsDsl.() -> Unit) -> BucketOptions {
            override fun deserialize(deserializer: KtMessageDeserializer): BucketOptions {
                var options : Options? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return BucketOptions(options,
                                UnknownFieldSet.from(unknownFields))
                        10 -> options =
                                Options.LinearBuckets(deserializer.readMessage(com.google.api.Distribution.BucketOptions.Linear))
                        18 -> options =
                                Options.ExponentialBuckets(deserializer.readMessage(com.google.api.Distribution.BucketOptions.Exponential))
                        26 -> options =
                                Options.ExplicitBuckets(deserializer.readMessage(com.google.api.Distribution.BucketOptions.Explicit))
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: BucketOptionsDsl.() -> Unit): BucketOptions =
                    BucketOptionsDsl().apply(dsl).build()
        }

        /**
         * Specifies a linear sequence of buckets that all have the same width (except overflow and
         * underflow). Each bucket represents a constant absolute uncertainty on the specific value in
         * the bucket.
         *
         *  There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the following
         * boundaries:
         *
         *     Upper bound (0 <= i < N-1):     offset + (width * i).    Lower bound (1 <= i < N):
         *    offset + (width * (i - 1)).
         */
        @KtGeneratedMessage("google.api.Linear")
        class Linear private constructor(
            /**
             * Must be greater than 0.
             */
            val numFiniteBuckets: Int,
            /**
             * Must be greater than 0.
             */
            val width: Double,
            /**
             * Lower bound of the first bucket.
             */
            val offset: Double,
            val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
        ) : KtMessage {
            override val messageSize: Int by lazy { messageSize() }

            private fun messageSize(): Int {
                var result = 0
                if (numFiniteBuckets != 0) {
                    result += sizeof(Tag(1)) + sizeof(Int32(numFiniteBuckets))
                }
                if (width != 0.0) {
                    result += sizeof(Tag(2)) + sizeof(width)
                }
                if (offset != 0.0) {
                    result += sizeof(Tag(3)) + sizeof(offset)
                }
                result += unknownFields.size()
                return result
            }

            override fun serialize(serializer: KtMessageSerializer) {
                if (numFiniteBuckets != 0) {
                    serializer.write(Tag(8)).write(Int32(numFiniteBuckets))
                }
                if (width != 0.0) {
                    serializer.write(Tag(17)).write(width)
                }
                if (offset != 0.0) {
                    serializer.write(Tag(25)).write(offset)
                }
                serializer.writeUnknown(unknownFields)
            }

            override fun equals(other: Any?): Boolean = other is Linear &&
                other.numFiniteBuckets == numFiniteBuckets &&
                other.width == width &&
                other.offset == offset &&
                other.unknownFields == unknownFields

            override fun hashCode(): Int {
                var result = unknownFields.hashCode()
                result = 31 * result + numFiniteBuckets.hashCode()
                result = 31 * result + width.hashCode()
                result = 31 * result + offset.hashCode()
                return result
            }

            override fun toString(): String = "Linear(" +
                "numFiniteBuckets=$numFiniteBuckets, " +
                "width=$width, " +
                "offset=$offset" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

            fun copy(dsl: LinearDsl.() -> Unit): Linear = Linear.Deserializer {
                numFiniteBuckets = this@Linear.numFiniteBuckets
                width = this@Linear.width
                offset = this@Linear.offset
                unknownFields = this@Linear.unknownFields
                dsl()
            }

            class LinearDsl {
                var numFiniteBuckets: Int = 0

                var width: Double = 0.0

                var offset: Double = 0.0

                var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

                fun build(): Linear = Linear(numFiniteBuckets,
                width,
                offset,
                 unknownFields)
            }

            companion object Deserializer : KtDeserializer<Linear>,
                    (LinearDsl.() -> Unit) -> Linear {
                override fun deserialize(deserializer: KtMessageDeserializer): Linear {
                    var numFiniteBuckets = 0
                    var width = 0.0
                    var offset = 0.0
                    var unknownFields: UnknownFieldSet.Builder? = null
                    while (true) {
                        when(deserializer.readTag()) {
                            0 -> return Linear(numFiniteBuckets,
                                    width,
                                    offset,
                                    UnknownFieldSet.from(unknownFields))
                            8 -> numFiniteBuckets = deserializer.readInt32()
                            17 -> width = deserializer.readDouble()
                            25 -> offset = deserializer.readDouble()
                            else -> unknownFields = (unknownFields ?:
                                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                    }
                        }
                    }
                }

                override fun invoke(dsl: LinearDsl.() -> Unit): Linear =
                        LinearDsl().apply(dsl).build()
            }
        }

        /**
         * Specifies an exponential sequence of buckets that have a width that is proportional to
         * the value of the lower bound. Each bucket represents a constant relative uncertainty on a
         * specific value in the bucket.
         *
         *  There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the following
         * boundaries:
         *
         *     Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).    Lower bound (1 <= i <
         * N):       scale * (growth_factor ^ (i - 1)).
         */
        @KtGeneratedMessage("google.api.Exponential")
        class Exponential private constructor(
            /**
             * Must be greater than 0.
             */
            val numFiniteBuckets: Int,
            /**
             * Must be greater than 1.
             */
            val growthFactor: Double,
            /**
             * Must be greater than 0.
             */
            val scale: Double,
            val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
        ) : KtMessage {
            override val messageSize: Int by lazy { messageSize() }

            private fun messageSize(): Int {
                var result = 0
                if (numFiniteBuckets != 0) {
                    result += sizeof(Tag(1)) + sizeof(Int32(numFiniteBuckets))
                }
                if (growthFactor != 0.0) {
                    result += sizeof(Tag(2)) + sizeof(growthFactor)
                }
                if (scale != 0.0) {
                    result += sizeof(Tag(3)) + sizeof(scale)
                }
                result += unknownFields.size()
                return result
            }

            override fun serialize(serializer: KtMessageSerializer) {
                if (numFiniteBuckets != 0) {
                    serializer.write(Tag(8)).write(Int32(numFiniteBuckets))
                }
                if (growthFactor != 0.0) {
                    serializer.write(Tag(17)).write(growthFactor)
                }
                if (scale != 0.0) {
                    serializer.write(Tag(25)).write(scale)
                }
                serializer.writeUnknown(unknownFields)
            }

            override fun equals(other: Any?): Boolean = other is Exponential &&
                other.numFiniteBuckets == numFiniteBuckets &&
                other.growthFactor == growthFactor &&
                other.scale == scale &&
                other.unknownFields == unknownFields

            override fun hashCode(): Int {
                var result = unknownFields.hashCode()
                result = 31 * result + numFiniteBuckets.hashCode()
                result = 31 * result + growthFactor.hashCode()
                result = 31 * result + scale.hashCode()
                return result
            }

            override fun toString(): String = "Exponential(" +
                "numFiniteBuckets=$numFiniteBuckets, " +
                "growthFactor=$growthFactor, " +
                "scale=$scale" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

            fun copy(dsl: ExponentialDsl.() -> Unit): Exponential =
                    Exponential.Deserializer {
                numFiniteBuckets = this@Exponential.numFiniteBuckets
                growthFactor = this@Exponential.growthFactor
                scale = this@Exponential.scale
                unknownFields = this@Exponential.unknownFields
                dsl()
            }

            class ExponentialDsl {
                var numFiniteBuckets: Int = 0

                var growthFactor: Double = 0.0

                var scale: Double = 0.0

                var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

                fun build(): Exponential = Exponential(numFiniteBuckets,
                growthFactor,
                scale,
                 unknownFields)
            }

            companion object Deserializer : KtDeserializer<Exponential>,
                    (ExponentialDsl.() -> Unit) -> Exponential {
                override fun deserialize(deserializer: KtMessageDeserializer): Exponential {
                    var numFiniteBuckets = 0
                    var growthFactor = 0.0
                    var scale = 0.0
                    var unknownFields: UnknownFieldSet.Builder? = null
                    while (true) {
                        when(deserializer.readTag()) {
                            0 -> return Exponential(numFiniteBuckets,
                                    growthFactor,
                                    scale,
                                    UnknownFieldSet.from(unknownFields))
                            8 -> numFiniteBuckets = deserializer.readInt32()
                            17 -> growthFactor = deserializer.readDouble()
                            25 -> scale = deserializer.readDouble()
                            else -> unknownFields = (unknownFields ?:
                                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                    }
                        }
                    }
                }

                override fun invoke(dsl: ExponentialDsl.() -> Unit): Exponential =
                        ExponentialDsl().apply(dsl).build()
            }
        }

        /**
         * Specifies a set of buckets with arbitrary widths.
         *
         *  There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following boundaries:
         *
         *     Upper bound (0 <= i < N-1):     bounds[i]    Lower bound (1 <= i < N);
         * bounds[i - 1]
         *
         *  The `bounds` field must contain at least one element. If `bounds` has only one element,
         * then there are no finite buckets, and that single element is the common boundary of the
         * overflow and underflow buckets.
         */
        @KtGeneratedMessage("google.api.Explicit")
        class Explicit private constructor(
            /**
             * The values must be monotonically increasing.
             */
            val bounds: List<Double>,
            val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
        ) : KtMessage {
            override val messageSize: Int by lazy { messageSize() }

            private fun messageSize(): Int {
                var result = 0
                if (bounds.isNotEmpty()) {
                    result += sizeof(Tag(1)) + bounds.sumOf { sizeof(it) }.let { it +
                            sizeof(UInt32(it)) }
                }
                result += unknownFields.size()
                return result
            }

            override fun serialize(serializer: KtMessageSerializer) {
                if (bounds.isNotEmpty()) {
                    serializer.write(Tag(10)).write(UInt32(bounds.sumOf{sizeof(it)}))
                    bounds.forEach { serializer.write(it) }
                }
                serializer.writeUnknown(unknownFields)
            }

            override fun equals(other: Any?): Boolean = other is Explicit &&
                other.bounds == bounds &&
                other.unknownFields == unknownFields

            override fun hashCode(): Int {
                var result = unknownFields.hashCode()
                result = 31 * result + bounds.hashCode()
                return result
            }

            override fun toString(): String = "Explicit(" +
                "bounds=$bounds" +
                "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

            fun copy(dsl: ExplicitDsl.() -> Unit): Explicit = Explicit.Deserializer {
                bounds = this@Explicit.bounds
                unknownFields = this@Explicit.unknownFields
                dsl()
            }

            class ExplicitDsl {
                var bounds: List<Double> = emptyList()
                    set(newValue) {
                        field = copyList(newValue)
                    }

                var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

                fun build(): Explicit = Explicit(finishList(bounds),
                 unknownFields)
            }

            companion object Deserializer : KtDeserializer<Explicit>,
                    (ExplicitDsl.() -> Unit) -> Explicit {
                override fun deserialize(deserializer: KtMessageDeserializer): Explicit {
                    var bounds : MutableList<Double>? = null
                    var unknownFields: UnknownFieldSet.Builder? = null
                    while (true) {
                        when(deserializer.readTag()) {
                            0 -> return Explicit(finishList(bounds),
                                    UnknownFieldSet.from(unknownFields))
                            9 -> bounds = (bounds ?: mutableListOf()).apply {
                                           deserializer.readRepeated(false) {
                                               add(deserializer.readDouble())
                                           }
                                       }
                            10 -> bounds = (bounds ?: mutableListOf()).apply {
                                           deserializer.readRepeated(true) {
                                               add(deserializer.readDouble())
                                           }
                                       }
                            else -> unknownFields = (unknownFields ?:
                                    UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                    }
                        }
                    }
                }

                override fun invoke(dsl: ExplicitDsl.() -> Unit): Explicit =
                        ExplicitDsl().apply(dsl).build()
            }
        }
    }

    /**
     * Exemplars are example points that may be used to annotate aggregated distribution values.
     * They are metadata that gives information about a particular value added to a Distribution
     * bucket, such as a trace ID that was active when a value was added. They may contain further
     * information, such as a example values and timestamps, origin, etc.
     */
    @KtGeneratedMessage("google.api.Exemplar")
    class Exemplar private constructor(
        /**
         * Value of the exemplar point. This value determines to which bucket the exemplar belongs.
         */
        val `value`: Double,
        /**
         * The observation (sampling) time of the above value.
         */
        val timestamp: Timestamp?,
        /**
         * Contextual information about the example value. Examples are:
         *
         *    Trace: type.googleapis.com/google.monitoring.v3.SpanContext
         *
         *    Literal string: type.googleapis.com/google.protobuf.StringValue
         *
         *    Labels dropped during aggregation:
         * type.googleapis.com/google.monitoring.v3.DroppedLabels
         *
         *  There may be only a single attachment of any given message type in a single exemplar,
         * and this is enforced by the system.
         */
        val attachments: List<com.toasttab.protokt.Any>,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (value != 0.0) {
                result += sizeof(Tag(1)) + sizeof(value)
            }
            if (timestamp  != null) {
                result += sizeof(Tag(2)) + sizeof(timestamp)
            }
            if (attachments.isNotEmpty()) {
                result += (sizeof(Tag(3)) * attachments.size) + attachments.sumOf { sizeof(it) }
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (value != 0.0) {
                serializer.write(Tag(9)).write(value)
            }
            if (timestamp  != null) {
                serializer.write(Tag(18)).write(timestamp)
            }
            if (attachments.isNotEmpty()) {
                attachments.forEach { serializer.write(Tag(26)).write(it) }
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is Exemplar &&
            other.value == value &&
            other.timestamp == timestamp &&
            other.attachments == attachments &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + value.hashCode()
            result = 31 * result + timestamp.hashCode()
            result = 31 * result + attachments.hashCode()
            return result
        }

        override fun toString(): String = "Exemplar(" +
            "value=$value, " +
            "timestamp=$timestamp, " +
            "attachments=$attachments" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: ExemplarDsl.() -> Unit): Exemplar = Exemplar.Deserializer {
            value = this@Exemplar.value
            timestamp = this@Exemplar.timestamp
            attachments = this@Exemplar.attachments
            unknownFields = this@Exemplar.unknownFields
            dsl()
        }

        class ExemplarDsl {
            var `value`: Double = 0.0

            var timestamp: Timestamp? = null

            var attachments: List<com.toasttab.protokt.Any> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Exemplar = Exemplar(value,
            timestamp,
            finishList(attachments),
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Exemplar>,
                (ExemplarDsl.() -> Unit) -> Exemplar {
            override fun deserialize(deserializer: KtMessageDeserializer): Exemplar {
                var value = 0.0
                var timestamp : Timestamp? = null
                var attachments : MutableList<com.toasttab.protokt.Any>? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Exemplar(value,
                                timestamp,
                                finishList(attachments),
                                UnknownFieldSet.from(unknownFields))
                        9 -> value = deserializer.readDouble()
                        18 -> timestamp = deserializer.readMessage(com.toasttab.protokt.Timestamp)
                        26 -> attachments = (attachments ?: mutableListOf()).apply {
                                       deserializer.readRepeated(false) {
                                           add(deserializer.readMessage(com.toasttab.protokt.Any))
                                       }
                                   }
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: ExemplarDsl.() -> Unit): Exemplar =
                    ExemplarDsl().apply(dsl).build()
        }
    }
}
