@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/backend.proto
package com.google.api

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtEnum
import com.toasttab.protokt.rt.KtEnumDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Double
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * `Backend` defines the backend configuration for a service.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.Backend")
class Backend private constructor(
    /**
     * A list of API backend rules that apply to individual API methods.
     *
     *  **NOTE:** All service configuration rules follow "last one wins" order.
     */
    val rules: List<BackendRule>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (rules.isNotEmpty()) {
            result += (sizeof(Tag(1)) * rules.size) + rules.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (rules.isNotEmpty()) {
            rules.forEach { serializer.write(Tag(10)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Backend &&
        other.rules == rules &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + rules.hashCode()
        return result
    }

    override fun toString(): String = "Backend(" +
        "rules=$rules" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: BackendDsl.() -> Unit): Backend = Backend.Deserializer {
        rules = this@Backend.rules
        unknownFields = this@Backend.unknownFields
        dsl()
    }

    class BackendDsl {
        var rules: List<BackendRule> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Backend = Backend(finishList(rules),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Backend>,
            (BackendDsl.() -> Unit) -> Backend {
        override fun deserialize(deserializer: KtMessageDeserializer): Backend {
            var rules : MutableList<BackendRule>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Backend(finishList(rules),
                            UnknownFieldSet.from(unknownFields))
                    10 -> rules = (rules ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.BackendRule))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: BackendDsl.() -> Unit): Backend =
                BackendDsl().apply(dsl).build()
    }
}

/**
 * A backend rule provides configuration for an individual API element.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.BackendRule")
class BackendRule private constructor(
    /**
     * Selects the methods to which this rule applies.
     *
     *  Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
     */
    val selector: String,
    /**
     * The address of the API backend.
     *
     *  The scheme is used to determine the backend protocol and security. The following schemes are
     * accepted:
     *
     *     SCHEME        PROTOCOL    SECURITY    http://       HTTP        None    https://
     * HTTP        TLS    grpc://       gRPC        None    grpcs://      gRPC        TLS
     *
     *  It is recommended to explicitly include a scheme. Leaving out the scheme may cause
     * constrasting behaviors across platforms.
     *
     *  If the port is unspecified, the default is: - 80 for schemes without TLS - 443 for schemes
     * with TLS
     *
     *  For HTTP backends, use [protocol][google.api.BackendRule.protocol] to specify the protocol
     * version.
     */
    val address: String,
    /**
     * The number of seconds to wait for a response from a request. The default varies based on the
     * request protocol and deployment environment.
     */
    val deadline: Double,
    /**
     * Minimum deadline in seconds needed for this method. Calls having deadline value lower than
     * this will be rejected.
     */
    val minDeadline: Double,
    /**
     * The number of seconds to wait for the completion of a long running operation. The default is
     * no deadline.
     */
    val operationDeadline: Double,
    val pathTranslation: PathTranslation,
    /**
     * Authentication settings used by the backend.
     *
     *  These are typically used to provide service management functionality to a backend served on
     * a publicly-routable URL. The `authentication` details should match the authentication behavior
     * used by the backend.
     *
     *  For example, specifying `jwt_audience` implies that the backend expects authentication via a
     * JWT.
     *
     *  When authentication is unspecified, the resulting behavior is the same as `disable_auth` set
     * to `true`.
     *
     *  Refer to https://developers.google.com/identity/protocols/OpenIDConnect for JWT ID token.
     */
    val authentication: Authentication?,
    /**
     * The protocol used for sending a request to the backend. The supported values are "http/1.1"
     * and "h2".
     *
     *  The default value is inferred from the scheme in the
     * [address][google.api.BackendRule.address] field:
     *
     *     SCHEME        PROTOCOL    http://       http/1.1    https://      http/1.1    grpc://
     *   h2    grpcs://      h2
     *
     *  For secure HTTP backends (https://) that support HTTP/2, set this field to "h2" for improved
     * performance.
     *
     *  Configuring this field to non-default values is only supported for secure HTTP backends.
     * This field will be ignored for all other backends.
     *
     *  See
     * https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
     * for more details on the supported values.
     */
    val protocol: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (selector.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(selector)
        }
        if (address.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(address)
        }
        if (deadline != 0.0) {
            result += sizeof(Tag(3)) + sizeof(deadline)
        }
        if (minDeadline != 0.0) {
            result += sizeof(Tag(4)) + sizeof(minDeadline)
        }
        if (operationDeadline != 0.0) {
            result += sizeof(Tag(5)) + sizeof(operationDeadline)
        }
        if (pathTranslation.value != 0) {
            result += sizeof(Tag(6)) + sizeof(pathTranslation)
        }
        when (authentication) {
            is BackendRule.Authentication.JwtAudience -> {
                result += sizeof(Tag(7)) + sizeof(authentication.jwtAudience)}
            is BackendRule.Authentication.DisableAuth -> {
                result += sizeof(Tag(8)) + sizeof(authentication.disableAuth)}
            null -> Unit
        }
        if (protocol.isNotEmpty()) {
            result += sizeof(Tag(9)) + sizeof(protocol)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (selector.isNotEmpty()) {
            serializer.write(Tag(10)).write(selector)
        }
        if (address.isNotEmpty()) {
            serializer.write(Tag(18)).write(address)
        }
        if (deadline != 0.0) {
            serializer.write(Tag(25)).write(deadline)
        }
        if (minDeadline != 0.0) {
            serializer.write(Tag(33)).write(minDeadline)
        }
        if (operationDeadline != 0.0) {
            serializer.write(Tag(41)).write(operationDeadline)
        }
        if (pathTranslation.value != 0) {
            serializer.write(Tag(48)).write(pathTranslation)
        }
        when (authentication) {
            is BackendRule.Authentication.JwtAudience -> {
                serializer.write(Tag(58)).write(authentication.jwtAudience)
            }
            is BackendRule.Authentication.DisableAuth -> {
                serializer.write(Tag(64)).write(authentication.disableAuth)
            }
            null -> Unit
        }
        if (protocol.isNotEmpty()) {
            serializer.write(Tag(74)).write(protocol)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is BackendRule &&
        other.selector == selector &&
        other.address == address &&
        other.deadline == deadline &&
        other.minDeadline == minDeadline &&
        other.operationDeadline == operationDeadline &&
        other.pathTranslation == pathTranslation &&
        other.authentication == authentication &&
        other.protocol == protocol &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + selector.hashCode()
        result = 31 * result + address.hashCode()
        result = 31 * result + deadline.hashCode()
        result = 31 * result + minDeadline.hashCode()
        result = 31 * result + operationDeadline.hashCode()
        result = 31 * result + pathTranslation.hashCode()
        result = 31 * result + authentication.hashCode()
        result = 31 * result + protocol.hashCode()
        return result
    }

    override fun toString(): String = "BackendRule(" +
        "selector=$selector, " +
        "address=$address, " +
        "deadline=$deadline, " +
        "minDeadline=$minDeadline, " +
        "operationDeadline=$operationDeadline, " +
        "pathTranslation=$pathTranslation, " +
        "authentication=$authentication, " +
        "protocol=$protocol" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: BackendRuleDsl.() -> Unit): BackendRule = BackendRule.Deserializer {
        selector = this@BackendRule.selector
        address = this@BackendRule.address
        deadline = this@BackendRule.deadline
        minDeadline = this@BackendRule.minDeadline
        operationDeadline = this@BackendRule.operationDeadline
        pathTranslation = this@BackendRule.pathTranslation
        authentication = this@BackendRule.authentication
        protocol = this@BackendRule.protocol
        unknownFields = this@BackendRule.unknownFields
        dsl()
    }

    sealed class Authentication {
        /**
         * The JWT audience is used when generating a JWT ID token for the backend. This ID token
         * will be added in the HTTP "authorization" header, and sent to the backend.
         */
        data class JwtAudience(
            val jwtAudience: String,
        ) : Authentication()

        /**
         * When disable_auth is true, a JWT ID token won't be generated and the original
         * "Authorization" HTTP header will be preserved. If the header is used to carry the original
         * token and is expected by the backend, this field must be set to true to preserve the header.
         */
        data class DisableAuth(
            val disableAuth: Boolean,
        ) : Authentication()
    }

    class BackendRuleDsl {
        var selector: String = ""

        var address: String = ""

        var deadline: Double = 0.0

        var minDeadline: Double = 0.0

        var operationDeadline: Double = 0.0

        var pathTranslation: PathTranslation = PathTranslation.from(0)

        var authentication: Authentication? = null

        var protocol: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): BackendRule = BackendRule(selector,
        address,
        deadline,
        minDeadline,
        operationDeadline,
        pathTranslation,
        authentication,
        protocol,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<BackendRule>,
            (BackendRuleDsl.() -> Unit) -> BackendRule {
        override fun deserialize(deserializer: KtMessageDeserializer): BackendRule {
            var selector = ""
            var address = ""
            var deadline = 0.0
            var minDeadline = 0.0
            var operationDeadline = 0.0
            var pathTranslation = PathTranslation.from(0)
            var authentication : Authentication? = null
            var protocol = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return BackendRule(selector,
                            address,
                            deadline,
                            minDeadline,
                            operationDeadline,
                            pathTranslation,
                            authentication,
                            protocol,
                            UnknownFieldSet.from(unknownFields))
                    10 -> selector = deserializer.readString()
                    18 -> address = deserializer.readString()
                    25 -> deadline = deserializer.readDouble()
                    33 -> minDeadline = deserializer.readDouble()
                    41 -> operationDeadline = deserializer.readDouble()
                    48 -> pathTranslation =
                            deserializer.readEnum(com.google.api.BackendRule.PathTranslation)
                    58 -> authentication = Authentication.JwtAudience(deserializer.readString())
                    64 -> authentication = Authentication.DisableAuth(deserializer.readBool())
                    74 -> protocol = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: BackendRuleDsl.() -> Unit): BackendRule =
                BackendRuleDsl().apply(dsl).build()
    }

    /**
     * Path Translation specifies how to combine the backend address with the request path in order
     * to produce the appropriate forwarding URL for the request.
     *
     *  Path Translation is applicable only to HTTP-based backends. Backends which do not accept
     * requests over HTTP/HTTPS should leave `path_translation` unspecified.
     */
    sealed class PathTranslation(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        object PATH_TRANSLATION_UNSPECIFIED : PathTranslation(0,
                "PATH_TRANSLATION_UNSPECIFIED")

        /**
         * Use the backend address as-is, with no modification to the path. If the URL pattern
         * contains variables, the variable names and values will be appended to the query string. If a
         * query string parameter and a URL pattern variable have the same name, this may result in
         * duplicate keys in the query string.
         *
         *  # Examples
         *
         *  Given the following operation config:
         *
         *      Method path:        /api/company/{cid}/user/{uid}     Backend address:
         * https://example.cloudfunctions.net/getUser
         *
         *  Requests to the following request paths will call the backend at the translated path:
         *
         *      Request path: /api/company/widgetworks/user/johndoe     Translated:
         * https://example.cloudfunctions.net/getUser?cid=widgetworks&uid=johndoe
         *
         *      Request path: /api/company/widgetworks/user/johndoe?timezone=EST     Translated:
         * https://example.cloudfunctions.net/getUser?timezone=EST&cid=widgetworks&uid=johndoe
         */
        object CONSTANT_ADDRESS : PathTranslation(1, "CONSTANT_ADDRESS")

        /**
         * The request path will be appended to the backend address.
         *
         *  # Examples
         *
         *  Given the following operation config:
         *
         *      Method path:        /api/company/{cid}/user/{uid}     Backend address:
         * https://example.appspot.com
         *
         *  Requests to the following request paths will call the backend at the translated path:
         *
         *      Request path: /api/company/widgetworks/user/johndoe     Translated:
         * https://example.appspot.com/api/company/widgetworks/user/johndoe
         *
         *      Request path: /api/company/widgetworks/user/johndoe?timezone=EST     Translated:
         * https://example.appspot.com/api/company/widgetworks/user/johndoe?timezone=EST
         */
        object APPEND_PATH_TO_ADDRESS : PathTranslation(2, "APPEND_PATH_TO_ADDRESS")

        class UNRECOGNIZED(
            `value`: Int,
        ) : PathTranslation(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<PathTranslation> {
            override fun from(`value`: Int): PathTranslation = when (value) {
              0 -> PATH_TRANSLATION_UNSPECIFIED
              1 -> CONSTANT_ADDRESS
              2 -> APPEND_PATH_TO_ADDRESS
              else -> UNRECOGNIZED(value)
            }
        }
    }
}
