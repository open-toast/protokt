@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/quota.proto
package com.google.api

import com.toasttab.protokt.rt.Int64
import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.copyMap
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.finishMap
import com.toasttab.protokt.rt.sizeof
import com.toasttab.protokt.rt.sizeofMap
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableList
import kotlin.collections.MutableMap

/**
 * Quota configuration helps to achieve fairness and budgeting in service usage.
 *
 *  The metric based quota configuration works this way: - The service configuration defines a set
 * of metrics. - For API calls, the quota.metric_rules maps methods to metrics with   corresponding
 * costs. - The quota.limits defines limits on the metrics, which will be used for   quota checks at
 * runtime.
 *
 *  An example quota configuration in yaml format:
 *
 *     quota:      limits:
 *
 *       - name: apiWriteQpsPerProject        metric: library.googleapis.com/write_calls
 * unit: "1/min/{project}"  # rate limit for consumer projects        values:          STANDARD: 10000
 *
 *
 *
 *       # The metric rules bind all methods to the read_calls metric,      # except for the
 * UpdateBook and DeleteBook methods. These two methods      # are mapped to the write_calls metric,
 * with the UpdateBook method      # consuming at twice rate as the DeleteBook method.
 * metric_rules:      - selector: "*"        metric_costs:          library.googleapis.com/read_calls:
 * 1      - selector: google.example.library.v1.LibraryService.UpdateBook        metric_costs:
 * library.googleapis.com/write_calls: 2      - selector:
 * google.example.library.v1.LibraryService.DeleteBook        metric_costs:
 * library.googleapis.com/write_calls: 1
 *
 *   Corresponding Metric definition:
 *
 *       metrics:      - name: library.googleapis.com/read_calls        display_name: Read requests
 *       metric_kind: DELTA        value_type: INT64
 *
 *       - name: library.googleapis.com/write_calls        display_name: Write requests
 * metric_kind: DELTA        value_type: INT64
 *
 *
 */
@KtGeneratedMessage("google.api.Quota")
class Quota private constructor(
    /**
     * List of `QuotaLimit` definitions for the service.
     */
    val limits: List<QuotaLimit>,
    /**
     * List of `MetricRule` definitions, each one mapping a selected method to one or more metrics.
     */
    val metricRules: List<MetricRule>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (limits.isNotEmpty()) {
            result += (sizeof(Tag(3)) * limits.size) + limits.sumOf { sizeof(it) }
        }
        if (metricRules.isNotEmpty()) {
            result += (sizeof(Tag(4)) * metricRules.size) + metricRules.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (limits.isNotEmpty()) {
            limits.forEach { serializer.write(Tag(26)).write(it) }
        }
        if (metricRules.isNotEmpty()) {
            metricRules.forEach { serializer.write(Tag(34)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Quota &&
        other.limits == limits &&
        other.metricRules == metricRules &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + limits.hashCode()
        result = 31 * result + metricRules.hashCode()
        return result
    }

    override fun toString(): String = "Quota(" +
        "limits=$limits, " +
        "metricRules=$metricRules" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: QuotaDsl.() -> Unit): Quota = Quota.Deserializer {
        limits = this@Quota.limits
        metricRules = this@Quota.metricRules
        unknownFields = this@Quota.unknownFields
        dsl()
    }

    class QuotaDsl {
        var limits: List<QuotaLimit> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var metricRules: List<MetricRule> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Quota = Quota(finishList(limits),
        finishList(metricRules),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Quota>, (QuotaDsl.() -> Unit) -> Quota {
        override fun deserialize(deserializer: KtMessageDeserializer): Quota {
            var limits : MutableList<QuotaLimit>? = null
            var metricRules : MutableList<MetricRule>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Quota(finishList(limits),
                            finishList(metricRules),
                            UnknownFieldSet.from(unknownFields))
                    26 -> limits = (limits ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.QuotaLimit))
                                   }
                               }
                    34 -> metricRules = (metricRules ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.MetricRule))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: QuotaDsl.() -> Unit): Quota = QuotaDsl().apply(dsl).build()
    }
}

/**
 * Bind API methods to metrics. Binding a method to a metric causes that metric's configured quota
 * behaviors to apply to the method call.
 */
@KtGeneratedMessage("google.api.MetricRule")
class MetricRule private constructor(
    /**
     * Selects the methods to which this rule applies.
     *
     *  Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
     */
    val selector: String,
    /**
     * Metrics to update when the selected methods are called, and the associated cost applied to
     * each metric.
     *
     *  The key of the map is the metric name, and the values are the amount increased for the
     * metric against which the quota limits are defined. The value must not be negative.
     */
    val metricCosts: Map<String, Long>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (selector.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(selector)
        }
        if (metricCosts.isNotEmpty()) {
            result += sizeofMap(metricCosts, Tag(2)) { k, v -> MetricCostsEntry.sizeof(k, v)}
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (selector.isNotEmpty()) {
            serializer.write(Tag(10)).write(selector)
        }
        if (metricCosts.isNotEmpty()) {
            metricCosts.entries.forEach { serializer.write(Tag(18)).write(MetricCostsEntry(it.key,
                    it.value)) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is MetricRule &&
        other.selector == selector &&
        other.metricCosts == metricCosts &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + selector.hashCode()
        result = 31 * result + metricCosts.hashCode()
        return result
    }

    override fun toString(): String = "MetricRule(" +
        "selector=$selector, " +
        "metricCosts=$metricCosts" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: MetricRuleDsl.() -> Unit): MetricRule = MetricRule.Deserializer {
        selector = this@MetricRule.selector
        metricCosts = this@MetricRule.metricCosts
        unknownFields = this@MetricRule.unknownFields
        dsl()
    }

    class MetricRuleDsl {
        var selector: String = ""

        var metricCosts: Map<String, Long> = emptyMap()
            set(newValue) {
                field = copyMap(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): MetricRule = MetricRule(selector,
        finishMap(metricCosts),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<MetricRule>,
            (MetricRuleDsl.() -> Unit) -> MetricRule {
        override fun deserialize(deserializer: KtMessageDeserializer): MetricRule {
            var selector = ""
            var metricCosts : MutableMap<String, Long>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return MetricRule(selector,
                            finishMap(metricCosts),
                            UnknownFieldSet.from(unknownFields))
                    10 -> selector = deserializer.readString()
                    18 -> metricCosts = (metricCosts ?: mutableMapOf()).apply {
                                   deserializer.readRepeated(false) {

                                    deserializer.readMessage(com.google.api.MetricRule.MetricCostsEntry)
                                       .let { put(
                                           it.key,
                                           it.value
                                       ) }
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: MetricRuleDsl.() -> Unit): MetricRule =
                MetricRuleDsl().apply(dsl).build()
    }

    private class MetricCostsEntry(
        val key: String,
        val `value`: Long,
    ) : KtMessage {
        override val messageSize: Int
            get() = sizeof(key, value)

        override fun serialize(serializer: KtMessageSerializer) {
            serializer.write(Tag(10)).write(key)

            serializer.write(Tag(16)).write(Int64(value))
        }

        companion object Deserializer : KtDeserializer<MetricCostsEntry> {
            fun sizeof(key: String, `value`: Long) =
                    com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Int64(value))

            override fun deserialize(deserializer: KtMessageDeserializer): MetricCostsEntry {
                var key = ""
                var value = 0L

                while (true) {
                  when (deserializer.readTag()) {
                    0 -> return MetricCostsEntry(key, value)
                    10 -> key = deserializer.readString()
                    16 -> value = deserializer.readInt64()
                  }
                }
            }
        }
    }
}

/**
 * `QuotaLimit` defines a specific limit that applies over a specified duration for a limit type.
 * There can be at most one limit for a duration and limit type combination defined within a
 * `QuotaGroup`.
 */
@KtGeneratedMessage("google.api.QuotaLimit")
class QuotaLimit private constructor(
    /**
     * Optional. User-visible, extended description for this quota limit. Should be used only when
     * more context is needed to understand this limit than provided by the limit's display name (see:
     * `display_name`).
     */
    val description: String,
    /**
     * Default number of tokens that can be consumed during the specified duration. This is the
     * number of tokens assigned when a client application developer activates the service for his/her
     * project.
     *
     *  Specifying a value of 0 will block all requests. This can be used if you are provisioning
     * quota to selected consumers and blocking others. Similarly, a value of -1 will indicate an
     * unlimited quota. No other negative values are allowed.
     *
     *  Used by group-based quotas only.
     */
    val defaultLimit: Long,
    /**
     * Maximum number of tokens that can be consumed during the specified duration. Client
     * application developers can override the default limit up to this maximum. If specified, this
     * value cannot be set to a value less than the default limit. If not specified, it is set to the
     * default limit.
     *
     *  To allow clients to apply overrides with no upper bound, set this to -1, indicating
     * unlimited maximum quota.
     *
     *  Used by group-based quotas only.
     */
    val maxLimit: Long,
    /**
     * Duration of this limit in textual notation. Must be "100s" or "1d".
     *
     *  Used by group-based quotas only.
     */
    val duration: String,
    /**
     * Name of the quota limit.
     *
     *  The name must be provided, and it must be unique within the service. The name can only
     * include alphanumeric characters as well as '-'.
     *
     *  The maximum length of the limit name is 64 characters.
     */
    val name: String,
    /**
     * Free tier value displayed in the Developers Console for this limit. The free tier is the
     * number of tokens that will be subtracted from the billed amount when billing is enabled. This
     * field can only be set on a limit with duration "1d", in a billable group; it is invalid on any
     * other limit. If this field is not set, it defaults to 0, indicating that there is no free tier
     * for this service.
     *
     *  Used by group-based quotas only.
     */
    val freeTier: Long,
    /**
     * The name of the metric this quota limit applies to. The quota limits with the same metric
     * will be checked together during runtime. The metric must be defined within the service config.
     */
    val metric: String,
    /**
     * Specify the unit of the quota limit. It uses the same syntax as [Metric.unit][]. The
     * supported unit kinds are determined by the quota backend system.
     *
     *  Here are some examples: * "1/min/{project}" for quota per minute per project.
     *
     *  Note: the order of unit components is insignificant. The "1" at the beginning is required to
     * follow the metric unit syntax.
     */
    val unit: String,
    /**
     * Tiered limit values. You must specify this as a key:value pair, with an integer value that is
     * the maximum number of requests allowed for the specified unit. Currently only STANDARD is
     * supported.
     */
    val values: Map<String, Long>,
    /**
     * User-visible display name for this limit. Optional. If not set, the UI will provide a default
     * display name based on the quota configuration. This field can be used to override the default
     * display name generated from the configuration.
     */
    val displayName: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (description.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(description)
        }
        if (defaultLimit != 0L) {
            result += sizeof(Tag(3)) + sizeof(Int64(defaultLimit))
        }
        if (maxLimit != 0L) {
            result += sizeof(Tag(4)) + sizeof(Int64(maxLimit))
        }
        if (duration.isNotEmpty()) {
            result += sizeof(Tag(5)) + sizeof(duration)
        }
        if (name.isNotEmpty()) {
            result += sizeof(Tag(6)) + sizeof(name)
        }
        if (freeTier != 0L) {
            result += sizeof(Tag(7)) + sizeof(Int64(freeTier))
        }
        if (metric.isNotEmpty()) {
            result += sizeof(Tag(8)) + sizeof(metric)
        }
        if (unit.isNotEmpty()) {
            result += sizeof(Tag(9)) + sizeof(unit)
        }
        if (values.isNotEmpty()) {
            result += sizeofMap(values, Tag(10)) { k, v -> ValuesEntry.sizeof(k, v)}
        }
        if (displayName.isNotEmpty()) {
            result += sizeof(Tag(12)) + sizeof(displayName)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (description.isNotEmpty()) {
            serializer.write(Tag(18)).write(description)
        }
        if (defaultLimit != 0L) {
            serializer.write(Tag(24)).write(Int64(defaultLimit))
        }
        if (maxLimit != 0L) {
            serializer.write(Tag(32)).write(Int64(maxLimit))
        }
        if (duration.isNotEmpty()) {
            serializer.write(Tag(42)).write(duration)
        }
        if (name.isNotEmpty()) {
            serializer.write(Tag(50)).write(name)
        }
        if (freeTier != 0L) {
            serializer.write(Tag(56)).write(Int64(freeTier))
        }
        if (metric.isNotEmpty()) {
            serializer.write(Tag(66)).write(metric)
        }
        if (unit.isNotEmpty()) {
            serializer.write(Tag(74)).write(unit)
        }
        if (values.isNotEmpty()) {
            values.entries.forEach { serializer.write(Tag(82)).write(ValuesEntry(it.key, it.value))
                    }
        }
        if (displayName.isNotEmpty()) {
            serializer.write(Tag(98)).write(displayName)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is QuotaLimit &&
        other.description == description &&
        other.defaultLimit == defaultLimit &&
        other.maxLimit == maxLimit &&
        other.duration == duration &&
        other.name == name &&
        other.freeTier == freeTier &&
        other.metric == metric &&
        other.unit == unit &&
        other.values == values &&
        other.displayName == displayName &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + description.hashCode()
        result = 31 * result + defaultLimit.hashCode()
        result = 31 * result + maxLimit.hashCode()
        result = 31 * result + duration.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + freeTier.hashCode()
        result = 31 * result + metric.hashCode()
        result = 31 * result + unit.hashCode()
        result = 31 * result + values.hashCode()
        result = 31 * result + displayName.hashCode()
        return result
    }

    override fun toString(): String = "QuotaLimit(" +
        "description=$description, " +
        "defaultLimit=$defaultLimit, " +
        "maxLimit=$maxLimit, " +
        "duration=$duration, " +
        "name=$name, " +
        "freeTier=$freeTier, " +
        "metric=$metric, " +
        "unit=$unit, " +
        "values=$values, " +
        "displayName=$displayName" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: QuotaLimitDsl.() -> Unit): QuotaLimit = QuotaLimit.Deserializer {
        description = this@QuotaLimit.description
        defaultLimit = this@QuotaLimit.defaultLimit
        maxLimit = this@QuotaLimit.maxLimit
        duration = this@QuotaLimit.duration
        name = this@QuotaLimit.name
        freeTier = this@QuotaLimit.freeTier
        metric = this@QuotaLimit.metric
        unit = this@QuotaLimit.unit
        values = this@QuotaLimit.values
        displayName = this@QuotaLimit.displayName
        unknownFields = this@QuotaLimit.unknownFields
        dsl()
    }

    class QuotaLimitDsl {
        var description: String = ""

        var defaultLimit: Long = 0L

        var maxLimit: Long = 0L

        var duration: String = ""

        var name: String = ""

        var freeTier: Long = 0L

        var metric: String = ""

        var unit: String = ""

        var values: Map<String, Long> = emptyMap()
            set(newValue) {
                field = copyMap(newValue)
            }

        var displayName: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): QuotaLimit = QuotaLimit(description,
        defaultLimit,
        maxLimit,
        duration,
        name,
        freeTier,
        metric,
        unit,
        finishMap(values),
        displayName,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<QuotaLimit>,
            (QuotaLimitDsl.() -> Unit) -> QuotaLimit {
        override fun deserialize(deserializer: KtMessageDeserializer): QuotaLimit {
            var description = ""
            var defaultLimit = 0L
            var maxLimit = 0L
            var duration = ""
            var name = ""
            var freeTier = 0L
            var metric = ""
            var unit = ""
            var values : MutableMap<String, Long>? = null
            var displayName = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return QuotaLimit(description,
                            defaultLimit,
                            maxLimit,
                            duration,
                            name,
                            freeTier,
                            metric,
                            unit,
                            finishMap(values),
                            displayName,
                            UnknownFieldSet.from(unknownFields))
                    18 -> description = deserializer.readString()
                    24 -> defaultLimit = deserializer.readInt64()
                    32 -> maxLimit = deserializer.readInt64()
                    42 -> duration = deserializer.readString()
                    50 -> name = deserializer.readString()
                    56 -> freeTier = deserializer.readInt64()
                    66 -> metric = deserializer.readString()
                    74 -> unit = deserializer.readString()
                    82 -> values = (values ?: mutableMapOf()).apply {
                                   deserializer.readRepeated(false) {

                                    deserializer.readMessage(com.google.api.QuotaLimit.ValuesEntry)
                                       .let { put(
                                           it.key,
                                           it.value
                                       ) }
                                   }
                               }
                    98 -> displayName = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: QuotaLimitDsl.() -> Unit): QuotaLimit =
                QuotaLimitDsl().apply(dsl).build()
    }

    private class ValuesEntry(
        val key: String,
        val `value`: Long,
    ) : KtMessage {
        override val messageSize: Int
            get() = sizeof(key, value)

        override fun serialize(serializer: KtMessageSerializer) {
            serializer.write(Tag(10)).write(key)

            serializer.write(Tag(16)).write(Int64(value))
        }

        companion object Deserializer : KtDeserializer<ValuesEntry> {
            fun sizeof(key: String, `value`: Long) =
                    com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Int64(value))

            override fun deserialize(deserializer: KtMessageDeserializer): ValuesEntry {
                var key = ""
                var value = 0L

                while (true) {
                  when (deserializer.readTag()) {
                    0 -> return ValuesEntry(key, value)
                    10 -> key = deserializer.readString()
                    16 -> value = deserializer.readInt64()
                  }
                }
            }
        }
    }
}
