@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/logging.proto
package com.google.api

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * Logging configuration of the service.
 *
 *  The following example shows how to configure logs to be sent to the producer and consumer
 * projects. In the example, the `activity_history` log is sent to both the producer and consumer
 * projects, whereas the `purchase_history` log is only sent to the producer project.
 *
 *      monitored_resources:     - type: library.googleapis.com/branch       labels:       - key:
 * /city         description: The city where the library branch is located in.       - key: /name
 *   description: The name of the branch.     logs:     - name: activity_history       labels:       -
 * key: /customer_id     - name: purchase_history     logging:       producer_destinations:       -
 * monitored_resource: library.googleapis.com/branch         logs:         - activity_history         -
 * purchase_history       consumer_destinations:       - monitored_resource:
 * library.googleapis.com/branch         logs:         - activity_history
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.api.Logging")
class Logging private constructor(
    /**
     * Logging configurations for sending logs to the producer project. There can be multiple
     * producer destinations, each one must have a different monitored resource type. A log can be used
     * in at most one producer destination.
     */
    val producerDestinations: List<LoggingDestination>,
    /**
     * Logging configurations for sending logs to the consumer project. There can be multiple
     * consumer destinations, each one must have a different monitored resource type. A log can be used
     * in at most one consumer destination.
     */
    val consumerDestinations: List<LoggingDestination>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (producerDestinations.isNotEmpty()) {
            result += (sizeof(Tag(1)) * producerDestinations.size) + producerDestinations.sumOf {
                    sizeof(it) }
        }
        if (consumerDestinations.isNotEmpty()) {
            result += (sizeof(Tag(2)) * consumerDestinations.size) + consumerDestinations.sumOf {
                    sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (producerDestinations.isNotEmpty()) {
            producerDestinations.forEach { serializer.write(Tag(10)).write(it) }
        }
        if (consumerDestinations.isNotEmpty()) {
            consumerDestinations.forEach { serializer.write(Tag(18)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Logging &&
        other.producerDestinations == producerDestinations &&
        other.consumerDestinations == consumerDestinations &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + producerDestinations.hashCode()
        result = 31 * result + consumerDestinations.hashCode()
        return result
    }

    override fun toString(): String = "Logging(" +
        "producerDestinations=$producerDestinations, " +
        "consumerDestinations=$consumerDestinations" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: LoggingDsl.() -> Unit): Logging = Logging.Deserializer {
        producerDestinations = this@Logging.producerDestinations
        consumerDestinations = this@Logging.consumerDestinations
        unknownFields = this@Logging.unknownFields
        dsl()
    }

    class LoggingDsl {
        var producerDestinations: List<LoggingDestination> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var consumerDestinations: List<LoggingDestination> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Logging = Logging(finishList(producerDestinations),
        finishList(consumerDestinations),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Logging>,
            (LoggingDsl.() -> Unit) -> Logging {
        override fun deserialize(deserializer: KtMessageDeserializer): Logging {
            var producerDestinations : MutableList<LoggingDestination>? = null
            var consumerDestinations : MutableList<LoggingDestination>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Logging(finishList(producerDestinations),
                            finishList(consumerDestinations),
                            UnknownFieldSet.from(unknownFields))
                    10 -> producerDestinations = (producerDestinations ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {

                                    add(deserializer.readMessage(com.google.api.Logging.LoggingDestination))
                                   }
                               }
                    18 -> consumerDestinations = (consumerDestinations ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {

                                    add(deserializer.readMessage(com.google.api.Logging.LoggingDestination))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: LoggingDsl.() -> Unit): Logging =
                LoggingDsl().apply(dsl).build()
    }

    /**
     * Configuration of a specific logging destination (the producer project or the consumer
     * project).
     */
    @KtGeneratedMessage("google.api.LoggingDestination")
    class LoggingDestination private constructor(
        /**
         * Names of the logs to be sent to this destination. Each name must be defined in the
         * [Service.logs][google.api.Service.logs] section. If the log name is not a domain scoped
         * name, it will be automatically prefixed with the service name followed by "/".
         */
        val logs: List<String>,
        /**
         * The monitored resource type. The type must be defined in the
         * [Service.monitored_resources][google.api.Service.monitored_resources] section.
         */
        val monitoredResource: String,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (logs.isNotEmpty()) {
                result += (sizeof(Tag(1)) * logs.size) + logs.sumOf { sizeof(it) }
            }
            if (monitoredResource.isNotEmpty()) {
                result += sizeof(Tag(3)) + sizeof(monitoredResource)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (logs.isNotEmpty()) {
                logs.forEach { serializer.write(Tag(10)).write(it) }
            }
            if (monitoredResource.isNotEmpty()) {
                serializer.write(Tag(26)).write(monitoredResource)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: Any?): Boolean = other is LoggingDestination &&
            other.logs == logs &&
            other.monitoredResource == monitoredResource &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + logs.hashCode()
            result = 31 * result + monitoredResource.hashCode()
            return result
        }

        override fun toString(): String = "LoggingDestination(" +
            "logs=$logs, " +
            "monitoredResource=$monitoredResource" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: LoggingDestinationDsl.() -> Unit): LoggingDestination =
                LoggingDestination.Deserializer {
            logs = this@LoggingDestination.logs
            monitoredResource = this@LoggingDestination.monitoredResource
            unknownFields = this@LoggingDestination.unknownFields
            dsl()
        }

        class LoggingDestinationDsl {
            var logs: List<String> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var monitoredResource: String = ""

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): LoggingDestination = LoggingDestination(finishList(logs),
            monitoredResource,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<LoggingDestination>,
                (LoggingDestinationDsl.() -> Unit) -> LoggingDestination {
            override fun deserialize(deserializer: KtMessageDeserializer):
                    LoggingDestination {
                var logs : MutableList<String>? = null
                var monitoredResource = ""
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return LoggingDestination(finishList(logs),
                                monitoredResource,
                                UnknownFieldSet.from(unknownFields))
                        10 -> logs = (logs ?: mutableListOf()).apply {
                                       deserializer.readRepeated(false) {
                                           add(deserializer.readString())
                                       }
                                   }
                        26 -> monitoredResource = deserializer.readString()
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: LoggingDestinationDsl.() -> Unit): LoggingDestination =
                    LoggingDestinationDsl().apply(dsl).build()
        }
    }
}
