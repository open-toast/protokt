@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/resource.proto
package com.google.api

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtEnum
import com.toasttab.protokt.rt.KtEnumDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UInt32
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * A simple descriptor of a resource type.
 *
 *  ResourceDescriptor annotates a resource message (either by means of a protobuf annotation or use
 * in the service config), and associates the resource's schema, the resource type, and the pattern of
 * the resource name.
 *
 *  Example:
 *
 *      message Topic {       // Indicates this message defines a resource schema.       // Declares
 * the resource type in the format of {service}/{kind}.       // For Kubernetes resources, the format
 * is {api group}/{kind}.       option (google.api.resource) = {         type:
 * "pubsub.googleapis.com/Topic"         pattern: "projects/{project}/topics/{topic}"       };     }
 *
 *  The ResourceDescriptor Yaml config will look like:
 *
 *      resources:     - type: "pubsub.googleapis.com/Topic"       pattern:
 * "projects/{project}/topics/{topic}"
 *
 *  Sometimes, resources have multiple patterns, typically because they can live under multiple
 * parents.
 *
 *  Example:
 *
 *      message LogEntry {       option (google.api.resource) = {         type:
 * "logging.googleapis.com/LogEntry"         pattern: "projects/{project}/logs/{log}"         pattern:
 * "folders/{folder}/logs/{log}"         pattern: "organizations/{organization}/logs/{log}"
 * pattern: "billingAccounts/{billing_account}/logs/{log}"       };     }
 *
 *  The ResourceDescriptor Yaml config will look like:
 *
 *      resources:     - type: 'logging.googleapis.com/LogEntry'       pattern:
 * "projects/{project}/logs/{log}"       pattern: "folders/{folder}/logs/{log}"       pattern:
 * "organizations/{organization}/logs/{log}"       pattern:
 * "billingAccounts/{billing_account}/logs/{log}"
 */
@KtGeneratedMessage("google.api.ResourceDescriptor")
class ResourceDescriptor private constructor(
    /**
     * The resource type. It must be in the format of {service_name}/{resource_type_kind}. The
     * `resource_type_kind` must be singular and must not include version numbers.
     *
     *  Example: `storage.googleapis.com/Bucket`
     *
     *  The value of the resource_type_kind must follow the regular expression
     * /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and should use PascalCase
     * (UpperCamelCase). The maximum number of characters allowed for the `resource_type_kind` is 100.
     */
    val type: String,
    /**
     * Optional. The relative resource name pattern associated with this resource type. The DNS
     * prefix of the full resource name shouldn't be specified here.
     *
     *  The path pattern must follow the syntax, which aligns with HTTP binding syntax:
     *
     *      Template = Segment { "/" Segment } ;     Segment = LITERAL | Variable ;     Variable =
     * "{" LITERAL "}" ;
     *
     *  Examples:
     *
     *      - "projects/{project}/topics/{topic}"     -
     * "projects/{project}/knowledgeBases/{knowledge_base}"
     *
     *  The components in braces correspond to the IDs for each resource in the hierarchy. It is
     * expected that, if multiple patterns are provided, the same component name (e.g. "project")
     * refers to IDs of the same type of resource.
     */
    val pattern: List<String>,
    /**
     * Optional. The field on the resource that designates the resource name field. If omitted, this
     * is assumed to be "name".
     */
    val nameField: String,
    /**
     * Optional. The historical or future-looking state of the resource pattern.
     *
     *  Example:
     *
     *      // The InspectTemplate message originally only supported resource     // names with
     * organization, and project was added later.     message InspectTemplate {       option
     * (google.api.resource) = {         type: "dlp.googleapis.com/InspectTemplate"         pattern:
     *      "organizations/{organization}/inspectTemplates/{inspect_template}"         pattern:
     * "projects/{project}/inspectTemplates/{inspect_template}"         history:
     * ORIGINALLY_SINGLE_PATTERN       };     }
     */
    val history: History,
    /**
     * The plural name used in the resource name and permission names, such as 'projects' for the
     * resource name of 'projects/{project}' and the permission name of
     * 'cloudresourcemanager.googleapis.com/projects.get'. It is the same concept of the `plural` field
     * in k8s CRD spec
     * https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
     *
     *
     *  Note: The plural form is required even for singleton resources. See https://aip.dev/156
     */
    val plural: String,
    /**
     * The same concept of the `singular` field in k8s CRD spec
     * https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
     * Such as "project" for the `resourcemanager.googleapis.com/Project` type.
     */
    val singular: String,
    /**
     * Style flag(s) for this resource. These indicate that a resource is expected to conform to a
     * given style. See the specific style flags for additional information.
     */
    val style: List<Style>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (type.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(type)
        }
        if (pattern.isNotEmpty()) {
            result += (sizeof(Tag(2)) * pattern.size) + pattern.sumOf { sizeof(it) }
        }
        if (nameField.isNotEmpty()) {
            result += sizeof(Tag(3)) + sizeof(nameField)
        }
        if (history.value != 0) {
            result += sizeof(Tag(4)) + sizeof(history)
        }
        if (plural.isNotEmpty()) {
            result += sizeof(Tag(5)) + sizeof(plural)
        }
        if (singular.isNotEmpty()) {
            result += sizeof(Tag(6)) + sizeof(singular)
        }
        if (style.isNotEmpty()) {
            result += sizeof(Tag(10)) + style.sumOf { sizeof(it) }.let { it + sizeof(UInt32(it)) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (type.isNotEmpty()) {
            serializer.write(Tag(10)).write(type)
        }
        if (pattern.isNotEmpty()) {
            pattern.forEach { serializer.write(Tag(18)).write(it) }
        }
        if (nameField.isNotEmpty()) {
            serializer.write(Tag(26)).write(nameField)
        }
        if (history.value != 0) {
            serializer.write(Tag(32)).write(history)
        }
        if (plural.isNotEmpty()) {
            serializer.write(Tag(42)).write(plural)
        }
        if (singular.isNotEmpty()) {
            serializer.write(Tag(50)).write(singular)
        }
        if (style.isNotEmpty()) {
            serializer.write(Tag(82)).write(UInt32(style.sumOf{sizeof(it)}))
            style.forEach { serializer.write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ResourceDescriptor &&
        other.type == type &&
        other.pattern == pattern &&
        other.nameField == nameField &&
        other.history == history &&
        other.plural == plural &&
        other.singular == singular &&
        other.style == style &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + type.hashCode()
        result = 31 * result + pattern.hashCode()
        result = 31 * result + nameField.hashCode()
        result = 31 * result + history.hashCode()
        result = 31 * result + plural.hashCode()
        result = 31 * result + singular.hashCode()
        result = 31 * result + style.hashCode()
        return result
    }

    override fun toString(): String = "ResourceDescriptor(" +
        "type=$type, " +
        "pattern=$pattern, " +
        "nameField=$nameField, " +
        "history=$history, " +
        "plural=$plural, " +
        "singular=$singular, " +
        "style=$style" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ResourceDescriptorDsl.() -> Unit): ResourceDescriptor =
            ResourceDescriptor.Deserializer {
        type = this@ResourceDescriptor.type
        pattern = this@ResourceDescriptor.pattern
        nameField = this@ResourceDescriptor.nameField
        history = this@ResourceDescriptor.history
        plural = this@ResourceDescriptor.plural
        singular = this@ResourceDescriptor.singular
        style = this@ResourceDescriptor.style
        unknownFields = this@ResourceDescriptor.unknownFields
        dsl()
    }

    class ResourceDescriptorDsl {
        var type: String = ""

        var pattern: List<String> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var nameField: String = ""

        var history: History = History.from(0)

        var plural: String = ""

        var singular: String = ""

        var style: List<Style> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ResourceDescriptor = ResourceDescriptor(type,
        finishList(pattern),
        nameField,
        history,
        plural,
        singular,
        finishList(style),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<ResourceDescriptor>,
            (ResourceDescriptorDsl.() -> Unit) -> ResourceDescriptor {
        override fun deserialize(deserializer: KtMessageDeserializer): ResourceDescriptor {
            var type = ""
            var pattern : MutableList<String>? = null
            var nameField = ""
            var history = History.from(0)
            var plural = ""
            var singular = ""
            var style : MutableList<Style>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ResourceDescriptor(type,
                            finishList(pattern),
                            nameField,
                            history,
                            plural,
                            singular,
                            finishList(style),
                            UnknownFieldSet.from(unknownFields))
                    10 -> type = deserializer.readString()
                    18 -> pattern = (pattern ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readString())
                                   }
                               }
                    26 -> nameField = deserializer.readString()
                    32 -> history = deserializer.readEnum(com.google.api.ResourceDescriptor.History)
                    42 -> plural = deserializer.readString()
                    50 -> singular = deserializer.readString()
                    80 -> style = (style ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {

                                    add(deserializer.readEnum(com.google.api.ResourceDescriptor.Style))
                                   }
                               }
                    82 -> style = (style ?: mutableListOf()).apply {
                                   deserializer.readRepeated(true) {

                                    add(deserializer.readEnum(com.google.api.ResourceDescriptor.Style))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ResourceDescriptorDsl.() -> Unit): ResourceDescriptor =
                ResourceDescriptorDsl().apply(dsl).build()
    }

    /**
     * A description of the historical or future-looking state of the resource pattern.
     */
    sealed class History(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        /**
         * The "unset" value.
         */
        object HISTORY_UNSPECIFIED : History(0, "HISTORY_UNSPECIFIED")

        /**
         * The resource originally had one pattern and launched as such, and additional patterns
         * were added later.
         */
        object ORIGINALLY_SINGLE_PATTERN : History(1, "ORIGINALLY_SINGLE_PATTERN")

        /**
         * The resource has one pattern, but the API owner expects to add more later. (This is the
         * inverse of ORIGINALLY_SINGLE_PATTERN, and prevents that from being necessary once there are
         * multiple patterns.)
         */
        object FUTURE_MULTI_PATTERN : History(2, "FUTURE_MULTI_PATTERN")

        class UNRECOGNIZED(
            `value`: Int,
        ) : History(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<History> {
            override fun from(`value`: Int): History = when (value) {
              0 -> HISTORY_UNSPECIFIED
              1 -> ORIGINALLY_SINGLE_PATTERN
              2 -> FUTURE_MULTI_PATTERN
              else -> UNRECOGNIZED(value)
            }
        }
    }

    /**
     * A flag representing a specific style that a resource claims to conform to.
     */
    sealed class Style(
        override val `value`: Int,
        override val name: String,
    ) : KtEnum() {
        /**
         * The unspecified value. Do not use.
         */
        object STYLE_UNSPECIFIED : Style(0, "STYLE_UNSPECIFIED")

        /**
         * This resource is intended to be "declarative-friendly".
         *
         *  Declarative-friendly resources must be more strictly consistent, and setting this to
         * true communicates to tools that this resource should adhere to declarative-friendly
         * expectations.
         *
         *  Note: This is used by the API linter (linter.aip.dev) to enable additional checks.
         */
        object DECLARATIVE_FRIENDLY : Style(1, "DECLARATIVE_FRIENDLY")

        class UNRECOGNIZED(
            `value`: Int,
        ) : Style(value, "UNRECOGNIZED")

        companion object Deserializer : KtEnumDeserializer<Style> {
            override fun from(`value`: Int): Style = when (value) {
              0 -> STYLE_UNSPECIFIED
              1 -> DECLARATIVE_FRIENDLY
              else -> UNRECOGNIZED(value)
            }
        }
    }
}

/**
 * Defines a proto annotation that describes a string field that refers to an API resource.
 */
@KtGeneratedMessage("google.api.ResourceReference")
class ResourceReference private constructor(
    /**
     * The resource type that the annotated field references.
     *
     *  Example:
     *
     *      message Subscription {       string topic = 2 [(google.api.resource_reference) = {
     *   type: "pubsub.googleapis.com/Topic"       }];     }
     *
     *  Occasionally, a field may reference an arbitrary resource. In this case, APIs use the
     * special value * in their resource reference.
     *
     *  Example:
     *
     *      message GetIamPolicyRequest {       string resource = 2 [(google.api.resource_reference)
     * = {         type: "*"       }];     }
     */
    val type: String,
    /**
     * The resource type of a child collection that the annotated field references. This is useful
     * for annotating the `parent` field that doesn't have a fixed resource type.
     *
     *  Example:
     *
     *      message ListLogEntriesRequest {       string parent = 1 [(google.api.resource_reference)
     * = {         child_type: "logging.googleapis.com/LogEntry"       };     }
     */
    val childType: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (type.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(type)
        }
        if (childType.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(childType)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (type.isNotEmpty()) {
            serializer.write(Tag(10)).write(type)
        }
        if (childType.isNotEmpty()) {
            serializer.write(Tag(18)).write(childType)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ResourceReference &&
        other.type == type &&
        other.childType == childType &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + type.hashCode()
        result = 31 * result + childType.hashCode()
        return result
    }

    override fun toString(): String = "ResourceReference(" +
        "type=$type, " +
        "childType=$childType" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ResourceReferenceDsl.() -> Unit): ResourceReference =
            ResourceReference.Deserializer {
        type = this@ResourceReference.type
        childType = this@ResourceReference.childType
        unknownFields = this@ResourceReference.unknownFields
        dsl()
    }

    class ResourceReferenceDsl {
        var type: String = ""

        var childType: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ResourceReference = ResourceReference(type,
        childType,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<ResourceReference>,
            (ResourceReferenceDsl.() -> Unit) -> ResourceReference {
        override fun deserialize(deserializer: KtMessageDeserializer): ResourceReference {
            var type = ""
            var childType = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ResourceReference(type,
                            childType,
                            UnknownFieldSet.from(unknownFields))
                    10 -> type = deserializer.readString()
                    18 -> childType = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ResourceReferenceDsl.() -> Unit): ResourceReference =
                ResourceReferenceDsl().apply(dsl).build()
    }
}
