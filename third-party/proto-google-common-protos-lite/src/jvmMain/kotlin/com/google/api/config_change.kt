@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/api/config_change.proto
package com.google.api

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtEnum
import com.toasttab.protokt.rt.KtEnumDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * Output generated from semantically comparing two versions of a service configuration.
 *
 *  Includes detailed information about a field that have changed with applicable advice about
 * potential consequences for the change, such as backwards-incompatibility.
 */
sealed class ChangeType(
    override val `value`: Int,
    override val name: String,
) : KtEnum() {
    /**
     * Object hierarchy path to the change, with levels separated by a '.' character. For repeated
     * fields, an applicable unique identifier field is used for the index (usually selector, name, or
     * id). For maps, the term 'key' is used. If the field has no unique identifier, the numeric index
     * is used. Examples: - visibility.rules[selector=="google.LibraryService.ListBooks"].restriction -
     * quota.metric_rules[selector=="google"].metric_costs[key=="reads"].value -
     * logging.producer_destinations[0]
     */
    object CHANGE_TYPE_UNSPECIFIED : ChangeType(0, "CHANGE_TYPE_UNSPECIFIED")

    /**
     * Value of the changed object in the old Service configuration, in JSON format. This field will
     * not be populated if ChangeType == ADDED.
     */
    object ADDED : ChangeType(1, "ADDED")

    /**
     * Value of the changed object in the new Service configuration, in JSON format. This field will
     * not be populated if ChangeType == REMOVED.
     */
    object REMOVED : ChangeType(2, "REMOVED")

    /**
     * The type for this change, either ADDED, REMOVED, or MODIFIED.
     */
    object MODIFIED : ChangeType(3, "MODIFIED")

    class UNRECOGNIZED(
        `value`: Int,
    ) : ChangeType(value, "UNRECOGNIZED")

    companion object Deserializer : KtEnumDeserializer<ChangeType> {
        override fun from(`value`: Int): ChangeType = when (value) {
          0 -> CHANGE_TYPE_UNSPECIFIED
          1 -> ADDED
          2 -> REMOVED
          3 -> MODIFIED
          else -> UNRECOGNIZED(value)
        }
    }
}

/**
 * Output generated from semantically comparing two versions of a service configuration.
 *
 *  Includes detailed information about a field that have changed with applicable advice about
 * potential consequences for the change, such as backwards-incompatibility.
 */
@KtGeneratedMessage("google.api.ConfigChange")
class ConfigChange private constructor(
    /**
     * Object hierarchy path to the change, with levels separated by a '.' character. For repeated
     * fields, an applicable unique identifier field is used for the index (usually selector, name, or
     * id). For maps, the term 'key' is used. If the field has no unique identifier, the numeric index
     * is used. Examples: - visibility.rules[selector=="google.LibraryService.ListBooks"].restriction -
     * quota.metric_rules[selector=="google"].metric_costs[key=="reads"].value -
     * logging.producer_destinations[0]
     */
    val element: String,
    /**
     * Value of the changed object in the old Service configuration, in JSON format. This field will
     * not be populated if ChangeType == ADDED.
     */
    val oldValue: String,
    /**
     * Value of the changed object in the new Service configuration, in JSON format. This field will
     * not be populated if ChangeType == REMOVED.
     */
    val newValue: String,
    /**
     * The type for this change, either ADDED, REMOVED, or MODIFIED.
     */
    val changeType: ChangeType,
    /**
     * Collection of advice provided for this change, useful for determining the possible impact of
     * this change.
     */
    val advices: List<Advice>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (element.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(element)
        }
        if (oldValue.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(oldValue)
        }
        if (newValue.isNotEmpty()) {
            result += sizeof(Tag(3)) + sizeof(newValue)
        }
        if (changeType.value != 0) {
            result += sizeof(Tag(4)) + sizeof(changeType)
        }
        if (advices.isNotEmpty()) {
            result += (sizeof(Tag(5)) * advices.size) + advices.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (element.isNotEmpty()) {
            serializer.write(Tag(10)).write(element)
        }
        if (oldValue.isNotEmpty()) {
            serializer.write(Tag(18)).write(oldValue)
        }
        if (newValue.isNotEmpty()) {
            serializer.write(Tag(26)).write(newValue)
        }
        if (changeType.value != 0) {
            serializer.write(Tag(32)).write(changeType)
        }
        if (advices.isNotEmpty()) {
            advices.forEach { serializer.write(Tag(42)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is ConfigChange &&
        other.element == element &&
        other.oldValue == oldValue &&
        other.newValue == newValue &&
        other.changeType == changeType &&
        other.advices == advices &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + element.hashCode()
        result = 31 * result + oldValue.hashCode()
        result = 31 * result + newValue.hashCode()
        result = 31 * result + changeType.hashCode()
        result = 31 * result + advices.hashCode()
        return result
    }

    override fun toString(): String = "ConfigChange(" +
        "element=$element, " +
        "oldValue=$oldValue, " +
        "newValue=$newValue, " +
        "changeType=$changeType, " +
        "advices=$advices" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: ConfigChangeDsl.() -> Unit): ConfigChange = ConfigChange.Deserializer {
        element = this@ConfigChange.element
        oldValue = this@ConfigChange.oldValue
        newValue = this@ConfigChange.newValue
        changeType = this@ConfigChange.changeType
        advices = this@ConfigChange.advices
        unknownFields = this@ConfigChange.unknownFields
        dsl()
    }

    class ConfigChangeDsl {
        var element: String = ""

        var oldValue: String = ""

        var newValue: String = ""

        var changeType: ChangeType = ChangeType.from(0)

        var advices: List<Advice> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): ConfigChange = ConfigChange(element,
        oldValue,
        newValue,
        changeType,
        finishList(advices),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<ConfigChange>,
            (ConfigChangeDsl.() -> Unit) -> ConfigChange {
        override fun deserialize(deserializer: KtMessageDeserializer): ConfigChange {
            var element = ""
            var oldValue = ""
            var newValue = ""
            var changeType = ChangeType.from(0)
            var advices : MutableList<Advice>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return ConfigChange(element,
                            oldValue,
                            newValue,
                            changeType,
                            finishList(advices),
                            UnknownFieldSet.from(unknownFields))
                    10 -> element = deserializer.readString()
                    18 -> oldValue = deserializer.readString()
                    26 -> newValue = deserializer.readString()
                    32 -> changeType = deserializer.readEnum(com.google.api.ChangeType)
                    42 -> advices = (advices ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.google.api.Advice))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: ConfigChangeDsl.() -> Unit): ConfigChange =
                ConfigChangeDsl().apply(dsl).build()
    }
}

/**
 * Generated advice about this change, used for providing more information about how a change will
 * affect the existing service.
 */
@KtGeneratedMessage("google.api.Advice")
class Advice private constructor(
    /**
     * Useful description for why this advice was applied and what actions should be taken to
     * mitigate any implied risks.
     */
    val description: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (description.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(description)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (description.isNotEmpty()) {
            serializer.write(Tag(18)).write(description)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Advice &&
        other.description == description &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + description.hashCode()
        return result
    }

    override fun toString(): String = "Advice(" +
        "description=$description" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AdviceDsl.() -> Unit): Advice = Advice.Deserializer {
        description = this@Advice.description
        unknownFields = this@Advice.unknownFields
        dsl()
    }

    class AdviceDsl {
        var description: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Advice = Advice(description,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Advice>, (AdviceDsl.() -> Unit) -> Advice
            {
        override fun deserialize(deserializer: KtMessageDeserializer): Advice {
            var description = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Advice(description,
                            UnknownFieldSet.from(unknownFields))
                    18 -> description = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AdviceDsl.() -> Unit): Advice =
                AdviceDsl().apply(dsl).build()
    }
}
