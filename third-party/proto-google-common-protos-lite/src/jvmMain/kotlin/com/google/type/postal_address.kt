@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/type/postal_address.proto
package com.google.type

import com.toasttab.protokt.rt.Int32
import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.MutableList

/**
 * Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal
 * address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to
 * model geographical locations (roads, towns, mountains).
 *
 *  In typical usage an address would be created via user input or from importing existing data,
 * depending on the type of process.
 *
 *  Advice on address input / editing:  - Use an i18n-ready address widget such as
 * https://github.com/google/libaddressinput) - Users should not be presented with UI elements for
 * input or editing of   fields outside countries where that field is used.
 *
 *  For more guidance on how to use this schema, please see:
 * https://support.google.com/business/answer/6397478
 */
@KtGeneratedMessage("google.type.PostalAddress")
class PostalAddress private constructor(
    /**
     * The schema revision of the `PostalAddress`. This must be set to 0, which is the latest
     * revision.
     *
     *  All new revisions **must** be backward compatible with old revisions.
     */
    val revision: Int,
    /**
     * Required. CLDR region code of the country/region of the address. This is never inferred and
     * it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details.
     * Example: "CH" for Switzerland.
     */
    val regionCode: String,
    /**
     * Optional. BCP-47 language code of the contents of this address (if known). This is often the
     * UI language of the input form or is expected to match one of the languages used in the address'
     * country/region, or their transliterated equivalents. This can affect formatting in certain
     * countries, but is not critical to the correctness of the data and will never affect any
     * validation or other non-formatting related operations.
     *
     *  If this value is not known, it should be omitted (rather than specifying a possibly
     * incorrect default).
     *
     *  Examples: "zh-Hant", "ja", "ja-Latn", "en".
     */
    val languageCode: String,
    /**
     * Optional. Postal code of the address. Not all countries use or require postal codes to be
     * present, but where they are used, they may trigger additional validation with other parts of the
     * address (e.g. state/zip validation in the U.S.A.).
     */
    val postalCode: String,
    /**
     * Optional. Additional, country-specific, sorting code. This is not used in most regions. Where
     * it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g.
     * "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area
     * indicator" (Malawi) or "post office indicator" (e.g. CÃ´te d'Ivoire).
     */
    val sortingCode: String,
    /**
     * Optional. Highest administrative subdivision which is used for postal addresses of a country
     * or region. For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona"
     * and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     */
    val administrativeArea: String,
    /**
     * Optional. Generally refers to the city/town portion of the address. Examples: US city, IT
     * comune, UK post town. In regions of the world where localities are not well defined or do not
     * fit into this structure well, leave locality empty and use address_lines.
     */
    val locality: String,
    /**
     * Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs,
     * districts.
     */
    val sublocality: String,
    /**
     * Unstructured address lines describing the lower levels of an address.
     *
     *  Because values in address_lines do not have type information and may sometimes contain
     * multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is
     * clear. The order of address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is used to make it
     * explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This
     * way, the most specific line of an address can be selected based on the language.
     *
     *  The minimum permitted structural representation of an address consists of a region_code with
     * all remaining information placed in the address_lines. It would be possible to format such an
     * address very approximately without geocoding, but no semantic reasoning could be made about any
     * of the address components until it was at least partially resolved.
     *
     *  Creating an address only containing a region_code and address_lines, and then geocoding is
     * the recommended way to handle completely unstructured addresses (as opposed to guessing which
     * parts of the address should be localities or administrative areas).
     */
    val addressLines: List<String>,
    /**
     * Optional. The recipient at the address. This field may, under certain circumstances, contain
     * multiline information. For example, it might contain "care of" information.
     */
    val recipients: List<String>,
    /**
     * Optional. The name of the organization at the address.
     */
    val organization: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (revision != 0) {
            result += sizeof(Tag(1)) + sizeof(Int32(revision))
        }
        if (regionCode.isNotEmpty()) {
            result += sizeof(Tag(2)) + sizeof(regionCode)
        }
        if (languageCode.isNotEmpty()) {
            result += sizeof(Tag(3)) + sizeof(languageCode)
        }
        if (postalCode.isNotEmpty()) {
            result += sizeof(Tag(4)) + sizeof(postalCode)
        }
        if (sortingCode.isNotEmpty()) {
            result += sizeof(Tag(5)) + sizeof(sortingCode)
        }
        if (administrativeArea.isNotEmpty()) {
            result += sizeof(Tag(6)) + sizeof(administrativeArea)
        }
        if (locality.isNotEmpty()) {
            result += sizeof(Tag(7)) + sizeof(locality)
        }
        if (sublocality.isNotEmpty()) {
            result += sizeof(Tag(8)) + sizeof(sublocality)
        }
        if (addressLines.isNotEmpty()) {
            result += (sizeof(Tag(9)) * addressLines.size) + addressLines.sumOf { sizeof(it) }
        }
        if (recipients.isNotEmpty()) {
            result += (sizeof(Tag(10)) * recipients.size) + recipients.sumOf { sizeof(it) }
        }
        if (organization.isNotEmpty()) {
            result += sizeof(Tag(11)) + sizeof(organization)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (revision != 0) {
            serializer.write(Tag(8)).write(Int32(revision))
        }
        if (regionCode.isNotEmpty()) {
            serializer.write(Tag(18)).write(regionCode)
        }
        if (languageCode.isNotEmpty()) {
            serializer.write(Tag(26)).write(languageCode)
        }
        if (postalCode.isNotEmpty()) {
            serializer.write(Tag(34)).write(postalCode)
        }
        if (sortingCode.isNotEmpty()) {
            serializer.write(Tag(42)).write(sortingCode)
        }
        if (administrativeArea.isNotEmpty()) {
            serializer.write(Tag(50)).write(administrativeArea)
        }
        if (locality.isNotEmpty()) {
            serializer.write(Tag(58)).write(locality)
        }
        if (sublocality.isNotEmpty()) {
            serializer.write(Tag(66)).write(sublocality)
        }
        if (addressLines.isNotEmpty()) {
            addressLines.forEach { serializer.write(Tag(74)).write(it) }
        }
        if (recipients.isNotEmpty()) {
            recipients.forEach { serializer.write(Tag(82)).write(it) }
        }
        if (organization.isNotEmpty()) {
            serializer.write(Tag(90)).write(organization)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is PostalAddress &&
        other.revision == revision &&
        other.regionCode == regionCode &&
        other.languageCode == languageCode &&
        other.postalCode == postalCode &&
        other.sortingCode == sortingCode &&
        other.administrativeArea == administrativeArea &&
        other.locality == locality &&
        other.sublocality == sublocality &&
        other.addressLines == addressLines &&
        other.recipients == recipients &&
        other.organization == organization &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + revision.hashCode()
        result = 31 * result + regionCode.hashCode()
        result = 31 * result + languageCode.hashCode()
        result = 31 * result + postalCode.hashCode()
        result = 31 * result + sortingCode.hashCode()
        result = 31 * result + administrativeArea.hashCode()
        result = 31 * result + locality.hashCode()
        result = 31 * result + sublocality.hashCode()
        result = 31 * result + addressLines.hashCode()
        result = 31 * result + recipients.hashCode()
        result = 31 * result + organization.hashCode()
        return result
    }

    override fun toString(): String = "PostalAddress(" +
        "revision=$revision, " +
        "regionCode=$regionCode, " +
        "languageCode=$languageCode, " +
        "postalCode=$postalCode, " +
        "sortingCode=$sortingCode, " +
        "administrativeArea=$administrativeArea, " +
        "locality=$locality, " +
        "sublocality=$sublocality, " +
        "addressLines=$addressLines, " +
        "recipients=$recipients, " +
        "organization=$organization" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: PostalAddressDsl.() -> Unit): PostalAddress = PostalAddress.Deserializer {
        revision = this@PostalAddress.revision
        regionCode = this@PostalAddress.regionCode
        languageCode = this@PostalAddress.languageCode
        postalCode = this@PostalAddress.postalCode
        sortingCode = this@PostalAddress.sortingCode
        administrativeArea = this@PostalAddress.administrativeArea
        locality = this@PostalAddress.locality
        sublocality = this@PostalAddress.sublocality
        addressLines = this@PostalAddress.addressLines
        recipients = this@PostalAddress.recipients
        organization = this@PostalAddress.organization
        unknownFields = this@PostalAddress.unknownFields
        dsl()
    }

    class PostalAddressDsl {
        var revision: Int = 0

        var regionCode: String = ""

        var languageCode: String = ""

        var postalCode: String = ""

        var sortingCode: String = ""

        var administrativeArea: String = ""

        var locality: String = ""

        var sublocality: String = ""

        var addressLines: List<String> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var recipients: List<String> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var organization: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): PostalAddress = PostalAddress(revision,
        regionCode,
        languageCode,
        postalCode,
        sortingCode,
        administrativeArea,
        locality,
        sublocality,
        finishList(addressLines),
        finishList(recipients),
        organization,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<PostalAddress>,
            (PostalAddressDsl.() -> Unit) -> PostalAddress {
        override fun deserialize(deserializer: KtMessageDeserializer): PostalAddress {
            var revision = 0
            var regionCode = ""
            var languageCode = ""
            var postalCode = ""
            var sortingCode = ""
            var administrativeArea = ""
            var locality = ""
            var sublocality = ""
            var addressLines : MutableList<String>? = null
            var recipients : MutableList<String>? = null
            var organization = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return PostalAddress(revision,
                            regionCode,
                            languageCode,
                            postalCode,
                            sortingCode,
                            administrativeArea,
                            locality,
                            sublocality,
                            finishList(addressLines),
                            finishList(recipients),
                            organization,
                            UnknownFieldSet.from(unknownFields))
                    8 -> revision = deserializer.readInt32()
                    18 -> regionCode = deserializer.readString()
                    26 -> languageCode = deserializer.readString()
                    34 -> postalCode = deserializer.readString()
                    42 -> sortingCode = deserializer.readString()
                    50 -> administrativeArea = deserializer.readString()
                    58 -> locality = deserializer.readString()
                    66 -> sublocality = deserializer.readString()
                    74 -> addressLines = (addressLines ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readString())
                                   }
                               }
                    82 -> recipients = (recipients ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readString())
                                   }
                               }
                    90 -> organization = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: PostalAddressDsl.() -> Unit): PostalAddress =
                PostalAddressDsl().apply(dsl).build()
    }
}
