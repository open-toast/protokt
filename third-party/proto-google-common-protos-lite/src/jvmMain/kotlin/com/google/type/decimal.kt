@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/type/decimal.proto
package com.google.type

import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.sizeof
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.Unit

/**
 * A representation of a decimal value, such as 2.5. Clients may convert values into language-native
 * decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
 *
 *  [BigDecimal]:
 * https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
 * [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.type.Decimal")
class Decimal private constructor(
    /**
     * The decimal value, as a string.
     *
     *  The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`),
     * followed by a sequence of zero or more decimal digits ("the integer"), optionally followed by a
     * fraction, optionally followed by an exponent.
     *
     *  The fraction consists of a decimal point followed by zero or more decimal digits. The string
     * must contain at least one digit in either the integer or the fraction. The number formed by the
     * sign, the integer and the fraction is referred to as the significand.
     *
     *  The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or
     * more decimal digits.
     *
     *  Services **should** normalize decimal values before storing them by:
     *
     *    - Removing an explicitly-provided `+` sign (`+2.5` -> `2.5`).   - Replacing a zero-length
     * integer value with `0` (`.5` -> `0.5`).   - Coercing the exponent character to lower-case
     * (`2.5E8` -> `2.5e8`).   - Removing an explicitly-provided zero exponent (`2.5e0` -> `2.5`).
     *
     *  Services **may** perform additional normalization based on its own needs and the internal
     * decimal implementation selected, such as shifting the decimal point and exponent value together
     * (example: `2.5e-1` <-> `0.25`). Additionally, services **may** preserve trailing zeroes in the
     * fraction to indicate increased precision, but are not required to do so.
     *
     *  Note that only the `.` character is supported to divide the integer and the fraction; `,`
     * **should not** be supported regardless of locale. Additionally, thousand separators **should
     * not** be supported. If a service does support them, values **must** be normalized.
     *
     *  The ENBF grammar is:
     *
     *      DecimalString =       [Sign] Significand [Exponent];
     *
     *      Sign = '+' | '-';
     *
     *      Significand =       Digits ['.'] [Digits] | [Digits] '.' Digits;
     *
     *      Exponent = ('e' | 'E') [Sign] Digits;
     *
     *      Digits = { '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' };
     *
     *  Services **should** clearly document the range of supported values, the maximum supported
     * precision (total number of digits), and, if applicable, the scale (number of digits after the
     * decimal point), as well as how it behaves when receiving out-of-bounds values.
     *
     *  Services **may** choose to accept values passed as input even when the value has a higher
     * precision or scale than the service supports, and **should** round the value to fit the
     * supported scale. Alternatively, the service **may** error with `400 Bad Request`
     * (`INVALID_ARGUMENT` in gRPC) if precision would be lost.
     *
     *  Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service
     * receives a value outside of the supported range.
     */
    val `value`: String,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (value.isNotEmpty()) {
            result += sizeof(Tag(1)) + sizeof(value)
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (value.isNotEmpty()) {
            serializer.write(Tag(10)).write(value)
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: Any?): Boolean = other is Decimal &&
        other.value == value &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + value.hashCode()
        return result
    }

    override fun toString(): String = "Decimal(" +
        "value=$value" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: DecimalDsl.() -> Unit): Decimal = Decimal.Deserializer {
        value = this@Decimal.value
        unknownFields = this@Decimal.unknownFields
        dsl()
    }

    class DecimalDsl {
        var `value`: String = ""

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): Decimal = Decimal(value,
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<Decimal>,
            (DecimalDsl.() -> Unit) -> Decimal {
        override fun deserialize(deserializer: KtMessageDeserializer): Decimal {
            var value = ""
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return Decimal(value,
                            UnknownFieldSet.from(unknownFields))
                    10 -> value = deserializer.readString()
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: DecimalDsl.() -> Unit): Decimal =
                DecimalDsl().apply(dsl).build()
    }
}
