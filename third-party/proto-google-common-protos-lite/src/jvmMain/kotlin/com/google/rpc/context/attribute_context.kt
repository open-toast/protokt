@file:Suppress("DEPRECATION")

// Generated by protokt version 0.12.1. Do not modify.
// Source: google/rpc/context/attribute_context.proto
package com.google.rpc.context

import com.toasttab.protokt.Any
import com.toasttab.protokt.Duration
import com.toasttab.protokt.Struct
import com.toasttab.protokt.Timestamp
import com.toasttab.protokt.rt.Int64
import com.toasttab.protokt.rt.KtDeserializer
import com.toasttab.protokt.rt.KtGeneratedMessage
import com.toasttab.protokt.rt.KtMessage
import com.toasttab.protokt.rt.KtMessageDeserializer
import com.toasttab.protokt.rt.KtMessageSerializer
import com.toasttab.protokt.rt.Tag
import com.toasttab.protokt.rt.UnknownFieldSet
import com.toasttab.protokt.rt.copyList
import com.toasttab.protokt.rt.copyMap
import com.toasttab.protokt.rt.finishList
import com.toasttab.protokt.rt.finishMap
import com.toasttab.protokt.rt.sizeof
import com.toasttab.protokt.rt.sizeofMap
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableList
import kotlin.collections.MutableMap

/**
 * This message defines the standard attribute vocabulary for Google APIs.
 *
 *  An attribute is a piece of metadata that describes an activity on a network service. For
 * example, the size of an HTTP request, or the status code of an HTTP response.
 *
 *  Each attribute has a type and a name, which is logically defined as a proto message field in
 * `AttributeContext`. The field type becomes the attribute type, and the field path becomes the
 * attribute name. For example, the attribute `source.ip` maps to field `AttributeContext.source.ip`.
 *
 *  This message definition is guaranteed not to have any wire breaking change. So you can use it
 * directly for passing attributes across different systems.
 *
 *  NOTE: Different system may generate different subset of attributes. Please verify the system
 * specification before relying on an attribute generated a system.
 */
@Deprecated("use v1")
@KtGeneratedMessage("google.rpc.context.AttributeContext")
class AttributeContext private constructor(
    /**
     * The source of a network activity, such as starting a TCP connection. In a multi hop network
     * activity, the source represents the sender of the last hop.
     */
    val source: Peer?,
    /**
     * The destination of a network activity, such as accepting a TCP connection. In a multi hop
     * network activity, the destination represents the receiver of the last hop.
     */
    val destination: Peer?,
    /**
     * Represents a network request, such as an HTTP request.
     */
    val request: Request?,
    /**
     * Represents a network response, such as an HTTP response.
     */
    val response: Response?,
    /**
     * Represents a target resource that is involved with a network activity. If multiple resources
     * are involved with an activity, this must be the primary one.
     */
    val resource: Resource?,
    /**
     * Represents an API operation that is involved to a network activity.
     */
    val api: Api?,
    /**
     * The origin of a network activity. In a multi hop network activity, the origin represents the
     * sender of the first hop. For the first hop, the `source` and the `origin` must have the same
     * content.
     */
    val origin: Peer?,
    /**
     * Supports extensions for advanced use cases, such as logs and metrics.
     */
    val extensions: List<Any>,
    val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
) : KtMessage {
    override val messageSize: Int by lazy { messageSize() }

    private fun messageSize(): Int {
        var result = 0
        if (source  != null) {
            result += sizeof(Tag(1)) + sizeof(source)
        }
        if (destination  != null) {
            result += sizeof(Tag(2)) + sizeof(destination)
        }
        if (request  != null) {
            result += sizeof(Tag(3)) + sizeof(request)
        }
        if (response  != null) {
            result += sizeof(Tag(4)) + sizeof(response)
        }
        if (resource  != null) {
            result += sizeof(Tag(5)) + sizeof(resource)
        }
        if (api  != null) {
            result += sizeof(Tag(6)) + sizeof(api)
        }
        if (origin  != null) {
            result += sizeof(Tag(7)) + sizeof(origin)
        }
        if (extensions.isNotEmpty()) {
            result += (sizeof(Tag(8)) * extensions.size) + extensions.sumOf { sizeof(it) }
        }
        result += unknownFields.size()
        return result
    }

    override fun serialize(serializer: KtMessageSerializer) {
        if (source  != null) {
            serializer.write(Tag(10)).write(source)
        }
        if (destination  != null) {
            serializer.write(Tag(18)).write(destination)
        }
        if (request  != null) {
            serializer.write(Tag(26)).write(request)
        }
        if (response  != null) {
            serializer.write(Tag(34)).write(response)
        }
        if (resource  != null) {
            serializer.write(Tag(42)).write(resource)
        }
        if (api  != null) {
            serializer.write(Tag(50)).write(api)
        }
        if (origin  != null) {
            serializer.write(Tag(58)).write(origin)
        }
        if (extensions.isNotEmpty()) {
            extensions.forEach { serializer.write(Tag(66)).write(it) }
        }
        serializer.writeUnknown(unknownFields)
    }

    override fun equals(other: kotlin.Any?): Boolean = other is AttributeContext &&
        other.source == source &&
        other.destination == destination &&
        other.request == request &&
        other.response == response &&
        other.resource == resource &&
        other.api == api &&
        other.origin == origin &&
        other.extensions == extensions &&
        other.unknownFields == unknownFields

    override fun hashCode(): Int {
        var result = unknownFields.hashCode()
        result = 31 * result + source.hashCode()
        result = 31 * result + destination.hashCode()
        result = 31 * result + request.hashCode()
        result = 31 * result + response.hashCode()
        result = 31 * result + resource.hashCode()
        result = 31 * result + api.hashCode()
        result = 31 * result + origin.hashCode()
        result = 31 * result + extensions.hashCode()
        return result
    }

    override fun toString(): String = "AttributeContext(" +
        "source=$source, " +
        "destination=$destination, " +
        "request=$request, " +
        "response=$response, " +
        "resource=$resource, " +
        "api=$api, " +
        "origin=$origin, " +
        "extensions=$extensions" +
        "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

    fun copy(dsl: AttributeContextDsl.() -> Unit): AttributeContext =
            AttributeContext.Deserializer {
        source = this@AttributeContext.source
        destination = this@AttributeContext.destination
        request = this@AttributeContext.request
        response = this@AttributeContext.response
        resource = this@AttributeContext.resource
        api = this@AttributeContext.api
        origin = this@AttributeContext.origin
        extensions = this@AttributeContext.extensions
        unknownFields = this@AttributeContext.unknownFields
        dsl()
    }

    class AttributeContextDsl {
        var source: Peer? = null

        var destination: Peer? = null

        var request: Request? = null

        var response: Response? = null

        var resource: Resource? = null

        var api: Api? = null

        var origin: Peer? = null

        var extensions: List<Any> = emptyList()
            set(newValue) {
                field = copyList(newValue)
            }

        var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

        fun build(): AttributeContext = AttributeContext(source,
        destination,
        request,
        response,
        resource,
        api,
        origin,
        finishList(extensions),
         unknownFields)
    }

    companion object Deserializer : KtDeserializer<AttributeContext>,
            (AttributeContextDsl.() -> Unit) -> AttributeContext {
        override fun deserialize(deserializer: KtMessageDeserializer): AttributeContext {
            var source : Peer? = null
            var destination : Peer? = null
            var request : Request? = null
            var response : Response? = null
            var resource : Resource? = null
            var api : Api? = null
            var origin : Peer? = null
            var extensions : MutableList<Any>? = null
            var unknownFields: UnknownFieldSet.Builder? = null
            while (true) {
                when(deserializer.readTag()) {
                    0 -> return AttributeContext(source,
                            destination,
                            request,
                            response,
                            resource,
                            api,
                            origin,
                            finishList(extensions),
                            UnknownFieldSet.from(unknownFields))
                    10 -> source =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Peer)
                    18 -> destination =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Peer)
                    26 -> request =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Request)
                    34 -> response =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Response)
                    42 -> resource =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Resource)
                    50 -> api =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Api)
                    58 -> origin =
                            deserializer.readMessage(com.google.rpc.context.AttributeContext.Peer)
                    66 -> extensions = (extensions ?: mutableListOf()).apply {
                                   deserializer.readRepeated(false) {
                                       add(deserializer.readMessage(com.toasttab.protokt.Any))
                                   }
                               }
                    else -> unknownFields = (unknownFields ?:
                            UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown()) }
                }
            }
        }

        override fun invoke(dsl: AttributeContextDsl.() -> Unit): AttributeContext =
                AttributeContextDsl().apply(dsl).build()
    }

    /**
     * This message defines attributes for a node that handles a network request. The node can be
     * either a service or an application that sends, forwards, or receives the request. Service peers
     * should fill in `principal` and `labels` as appropriate.
     */
    @KtGeneratedMessage("google.rpc.context.Peer")
    class Peer private constructor(
        /**
         * The IP address of the peer.
         */
        val ip: String,
        /**
         * The network port of the peer.
         */
        val port: Long,
        /**
         * The labels associated with the peer.
         */
        val labels: Map<String, String>,
        /**
         * The identity of this peer. Similar to `Request.auth.principal`, but relative to the peer
         * instead of the request. For example, the idenity associated with a load balancer that
         * forwared the request.
         */
        val principal: String,
        /**
         * The CLDR country/region code associated with the above IP address. If the IP address is
         * private, the `region_code` should reflect the physical location where this peer is running.
         */
        val regionCode: String,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (ip.isNotEmpty()) {
                result += sizeof(Tag(1)) + sizeof(ip)
            }
            if (port != 0L) {
                result += sizeof(Tag(2)) + sizeof(Int64(port))
            }
            if (labels.isNotEmpty()) {
                result += sizeofMap(labels, Tag(6)) { k, v -> LabelsEntry.sizeof(k, v)}
            }
            if (principal.isNotEmpty()) {
                result += sizeof(Tag(7)) + sizeof(principal)
            }
            if (regionCode.isNotEmpty()) {
                result += sizeof(Tag(8)) + sizeof(regionCode)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (ip.isNotEmpty()) {
                serializer.write(Tag(10)).write(ip)
            }
            if (port != 0L) {
                serializer.write(Tag(16)).write(Int64(port))
            }
            if (labels.isNotEmpty()) {
                labels.entries.forEach { serializer.write(Tag(50)).write(LabelsEntry(it.key,
                        it.value)) }
            }
            if (principal.isNotEmpty()) {
                serializer.write(Tag(58)).write(principal)
            }
            if (regionCode.isNotEmpty()) {
                serializer.write(Tag(66)).write(regionCode)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: kotlin.Any?): Boolean = other is Peer &&
            other.ip == ip &&
            other.port == port &&
            other.labels == labels &&
            other.principal == principal &&
            other.regionCode == regionCode &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + ip.hashCode()
            result = 31 * result + port.hashCode()
            result = 31 * result + labels.hashCode()
            result = 31 * result + principal.hashCode()
            result = 31 * result + regionCode.hashCode()
            return result
        }

        override fun toString(): String = "Peer(" +
            "ip=$ip, " +
            "port=$port, " +
            "labels=$labels, " +
            "principal=$principal, " +
            "regionCode=$regionCode" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: PeerDsl.() -> Unit): Peer = Peer.Deserializer {
            ip = this@Peer.ip
            port = this@Peer.port
            labels = this@Peer.labels
            principal = this@Peer.principal
            regionCode = this@Peer.regionCode
            unknownFields = this@Peer.unknownFields
            dsl()
        }

        class PeerDsl {
            var ip: String = ""

            var port: Long = 0L

            var labels: Map<String, String> = emptyMap()
                set(newValue) {
                    field = copyMap(newValue)
                }

            var principal: String = ""

            var regionCode: String = ""

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Peer = Peer(ip,
            port,
            finishMap(labels),
            principal,
            regionCode,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Peer>, (PeerDsl.() -> Unit) -> Peer {
            override fun deserialize(deserializer: KtMessageDeserializer): Peer {
                var ip = ""
                var port = 0L
                var labels : MutableMap<String, String>? = null
                var principal = ""
                var regionCode = ""
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Peer(ip,
                                port,
                                finishMap(labels),
                                principal,
                                regionCode,
                                UnknownFieldSet.from(unknownFields))
                        10 -> ip = deserializer.readString()
                        16 -> port = deserializer.readInt64()
                        50 -> labels = (labels ?: mutableMapOf()).apply {
                                       deserializer.readRepeated(false) {

                                        deserializer.readMessage(com.google.rpc.context.AttributeContext.Peer.LabelsEntry)
                                           .let { put(
                                               it.key,
                                               it.value
                                           ) }
                                       }
                                   }
                        58 -> principal = deserializer.readString()
                        66 -> regionCode = deserializer.readString()
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: PeerDsl.() -> Unit): Peer = PeerDsl().apply(dsl).build()
        }

        private class LabelsEntry(
            val key: String,
            val `value`: String,
        ) : KtMessage {
            override val messageSize: Int
                get() = sizeof(key, value)

            override fun serialize(serializer: KtMessageSerializer) {
                serializer.write(Tag(10)).write(key)

                serializer.write(Tag(18)).write(value)
            }

            companion object Deserializer : KtDeserializer<LabelsEntry> {
                fun sizeof(key: String, `value`: String) =
                        com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(value)

                override fun deserialize(deserializer: KtMessageDeserializer): LabelsEntry {
                    var key = ""
                    var value = ""

                    while (true) {
                      when (deserializer.readTag()) {
                        0 -> return LabelsEntry(key, value)
                        10 -> key = deserializer.readString()
                        18 -> value = deserializer.readString()
                      }
                    }
                }
            }
        }
    }

    /**
     * This message defines attributes associated with API operations, such as a network API
     * request. The terminology is based on the conventions used by Google APIs, Istio, and OpenAPI.
     */
    @KtGeneratedMessage("google.rpc.context.Api")
    class Api private constructor(
        /**
         * The API service name. It is a logical identifier for a networked API, such as
         * "pubsub.googleapis.com". The naming syntax depends on the API management system being used
         * for handling the request.
         */
        val service: String,
        /**
         * The API operation name. For gRPC requests, it is the fully qualified API method name,
         * such as "google.pubsub.v1.Publisher.Publish". For OpenAPI requests, it is the `operationId`,
         * such as "getPet".
         */
        val operation: String,
        /**
         * The API protocol used for sending the request, such as "http", "https", "grpc", or
         * "internal".
         */
        val protocol: String,
        /**
         * The API version associated with the API operation above, such as "v1" or "v1alpha1".
         */
        val version: String,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (service.isNotEmpty()) {
                result += sizeof(Tag(1)) + sizeof(service)
            }
            if (operation.isNotEmpty()) {
                result += sizeof(Tag(2)) + sizeof(operation)
            }
            if (protocol.isNotEmpty()) {
                result += sizeof(Tag(3)) + sizeof(protocol)
            }
            if (version.isNotEmpty()) {
                result += sizeof(Tag(4)) + sizeof(version)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (service.isNotEmpty()) {
                serializer.write(Tag(10)).write(service)
            }
            if (operation.isNotEmpty()) {
                serializer.write(Tag(18)).write(operation)
            }
            if (protocol.isNotEmpty()) {
                serializer.write(Tag(26)).write(protocol)
            }
            if (version.isNotEmpty()) {
                serializer.write(Tag(34)).write(version)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: kotlin.Any?): Boolean = other is Api &&
            other.service == service &&
            other.operation == operation &&
            other.protocol == protocol &&
            other.version == version &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + service.hashCode()
            result = 31 * result + operation.hashCode()
            result = 31 * result + protocol.hashCode()
            result = 31 * result + version.hashCode()
            return result
        }

        override fun toString(): String = "Api(" +
            "service=$service, " +
            "operation=$operation, " +
            "protocol=$protocol, " +
            "version=$version" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: ApiDsl.() -> Unit): Api = Api.Deserializer {
            service = this@Api.service
            operation = this@Api.operation
            protocol = this@Api.protocol
            version = this@Api.version
            unknownFields = this@Api.unknownFields
            dsl()
        }

        class ApiDsl {
            var service: String = ""

            var operation: String = ""

            var protocol: String = ""

            var version: String = ""

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Api = Api(service,
            operation,
            protocol,
            version,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Api>, (ApiDsl.() -> Unit) -> Api {
            override fun deserialize(deserializer: KtMessageDeserializer): Api {
                var service = ""
                var operation = ""
                var protocol = ""
                var version = ""
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Api(service,
                                operation,
                                protocol,
                                version,
                                UnknownFieldSet.from(unknownFields))
                        10 -> service = deserializer.readString()
                        18 -> operation = deserializer.readString()
                        26 -> protocol = deserializer.readString()
                        34 -> version = deserializer.readString()
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: ApiDsl.() -> Unit): Api = ApiDsl().apply(dsl).build()
        }
    }

    /**
     * This message defines request authentication attributes. Terminology is based on the JSON Web
     * Token (JWT) standard, but the terms also correlate to concepts in other standards.
     */
    @KtGeneratedMessage("google.rpc.context.Auth")
    class Auth private constructor(
        /**
         * The authenticated principal. Reflects the issuer (`iss`) and subject (`sub`) claims
         * within a JWT. The issuer and subject should be `/` delimited, with `/` percent-encoded
         * within the subject fragment. For Google accounts, the principal format is:
         * "https://accounts.google.com/{id}"
         */
        val principal: String,
        /**
         * The intended audience(s) for this authentication information. Reflects the audience
         * (`aud`) claim within a JWT. The audience value(s) depends on the `issuer`, but typically
         * include one or more of the following pieces of information:
         *
         *  *  The services intended to receive the credential. For example,
         * ["https://pubsub.googleapis.com/", "https://storage.googleapis.com/"]. *  A set of
         * service-based scopes. For example,    ["https://www.googleapis.com/auth/cloud-platform"]. *
         * The client id of an app, such as the Firebase project id for JWTs    from Firebase Auth.
         *
         *  Consult the documentation for the credential issuer to determine the information
         * provided.
         */
        val audiences: List<String>,
        /**
         * The authorized presenter of the credential. Reflects the optional Authorized Presenter
         * (`azp`) claim within a JWT or the OAuth client id. For example, a Google Cloud Platform
         * client id looks as follows: "123456789012.apps.googleusercontent.com".
         */
        val presenter: String,
        /**
         * Structured claims presented with the credential. JWTs include `{key: value}` pairs for
         * standard and private claims. The following is a subset of the standard required and optional
         * claims that would typically be presented for a Google-based JWT:
         *
         *     {'iss': 'accounts.google.com',     'sub': '113289723416554971153',     'aud':
         * ['123456789012', 'pubsub.googleapis.com'],     'azp':
         * '123456789012.apps.googleusercontent.com',     'email': 'jsmith@example.com',     'iat':
         * 1353601026,     'exp': 1353604926}
         *
         *  SAML assertions are similarly specified, but with an identity provider dependent
         * structure.
         */
        val claims: Struct?,
        /**
         * A list of access level resource names that allow resources to be accessed by
         * authenticated requester. It is part of Secure GCP processing for the incoming request. An
         * access level string has the format:
         * "//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}"
         *
         *  Example:
         * "//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL"
         */
        val accessLevels: List<String>,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (principal.isNotEmpty()) {
                result += sizeof(Tag(1)) + sizeof(principal)
            }
            if (audiences.isNotEmpty()) {
                result += (sizeof(Tag(2)) * audiences.size) + audiences.sumOf { sizeof(it) }
            }
            if (presenter.isNotEmpty()) {
                result += sizeof(Tag(3)) + sizeof(presenter)
            }
            if (claims  != null) {
                result += sizeof(Tag(4)) + sizeof(claims)
            }
            if (accessLevels.isNotEmpty()) {
                result += (sizeof(Tag(5)) * accessLevels.size) + accessLevels.sumOf { sizeof(it) }
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (principal.isNotEmpty()) {
                serializer.write(Tag(10)).write(principal)
            }
            if (audiences.isNotEmpty()) {
                audiences.forEach { serializer.write(Tag(18)).write(it) }
            }
            if (presenter.isNotEmpty()) {
                serializer.write(Tag(26)).write(presenter)
            }
            if (claims  != null) {
                serializer.write(Tag(34)).write(claims)
            }
            if (accessLevels.isNotEmpty()) {
                accessLevels.forEach { serializer.write(Tag(42)).write(it) }
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: kotlin.Any?): Boolean = other is Auth &&
            other.principal == principal &&
            other.audiences == audiences &&
            other.presenter == presenter &&
            other.claims == claims &&
            other.accessLevels == accessLevels &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + principal.hashCode()
            result = 31 * result + audiences.hashCode()
            result = 31 * result + presenter.hashCode()
            result = 31 * result + claims.hashCode()
            result = 31 * result + accessLevels.hashCode()
            return result
        }

        override fun toString(): String = "Auth(" +
            "principal=$principal, " +
            "audiences=$audiences, " +
            "presenter=$presenter, " +
            "claims=$claims, " +
            "accessLevels=$accessLevels" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: AuthDsl.() -> Unit): Auth = Auth.Deserializer {
            principal = this@Auth.principal
            audiences = this@Auth.audiences
            presenter = this@Auth.presenter
            claims = this@Auth.claims
            accessLevels = this@Auth.accessLevels
            unknownFields = this@Auth.unknownFields
            dsl()
        }

        class AuthDsl {
            var principal: String = ""

            var audiences: List<String> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var presenter: String = ""

            var claims: Struct? = null

            var accessLevels: List<String> = emptyList()
                set(newValue) {
                    field = copyList(newValue)
                }

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Auth = Auth(principal,
            finishList(audiences),
            presenter,
            claims,
            finishList(accessLevels),
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Auth>, (AuthDsl.() -> Unit) -> Auth {
            override fun deserialize(deserializer: KtMessageDeserializer): Auth {
                var principal = ""
                var audiences : MutableList<String>? = null
                var presenter = ""
                var claims : Struct? = null
                var accessLevels : MutableList<String>? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Auth(principal,
                                finishList(audiences),
                                presenter,
                                claims,
                                finishList(accessLevels),
                                UnknownFieldSet.from(unknownFields))
                        10 -> principal = deserializer.readString()
                        18 -> audiences = (audiences ?: mutableListOf()).apply {
                                       deserializer.readRepeated(false) {
                                           add(deserializer.readString())
                                       }
                                   }
                        26 -> presenter = deserializer.readString()
                        34 -> claims = deserializer.readMessage(com.toasttab.protokt.Struct)
                        42 -> accessLevels = (accessLevels ?: mutableListOf()).apply {
                                       deserializer.readRepeated(false) {
                                           add(deserializer.readString())
                                       }
                                   }
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: AuthDsl.() -> Unit): Auth = AuthDsl().apply(dsl).build()
        }
    }

    /**
     * This message defines attributes for an HTTP request. If the actual request is not an HTTP
     * request, the runtime system should try to map the actual request to an equivalent HTTP request.
     */
    @KtGeneratedMessage("google.rpc.context.Request")
    class Request private constructor(
        /**
         * The unique ID for a request, which can be propagated to downstream systems. The ID should
         * have low probability of collision within a single day for a specific service.
         */
        val id: String,
        /**
         * The HTTP request method, such as `GET`, `POST`.
         */
        val method: String,
        /**
         * The HTTP request headers. If multiple headers share the same key, they must be merged
         * according to the HTTP spec. All header keys must be lowercased, because HTTP header keys are
         * case-insensitive.
         */
        val headers: Map<String, String>,
        /**
         * The HTTP URL path.
         */
        val path: String,
        /**
         * The HTTP request `Host` header value.
         */
        val host: String,
        /**
         * The HTTP URL scheme, such as `http` and `https`.
         */
        val scheme: String,
        /**
         * The HTTP URL query in the format of `name1=value1&name2=value2`, as it appears in the
         * first line of the HTTP request. No decoding is performed.
         */
        val query: String,
        /**
         * The timestamp when the `destination` service receives the last byte of the request.
         */
        val time: Timestamp?,
        /**
         * The HTTP request size in bytes. If unknown, it must be -1.
         */
        val size: Long,
        /**
         * The network protocol used with the request, such as "http/1.1", "spdy/3", "h2", "h2c",
         * "webrtc", "tcp", "udp", "quic". See
         * https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
         * for details.
         */
        val protocol: String,
        /**
         * A special parameter for request reason. It is used by security systems to associate
         * auditing information with a request.
         */
        val reason: String,
        /**
         * The request authentication. May be absent for unauthenticated requests. Derived from the
         * HTTP request `Authorization` header or equivalent.
         */
        val auth: Auth?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (id.isNotEmpty()) {
                result += sizeof(Tag(1)) + sizeof(id)
            }
            if (method.isNotEmpty()) {
                result += sizeof(Tag(2)) + sizeof(method)
            }
            if (headers.isNotEmpty()) {
                result += sizeofMap(headers, Tag(3)) { k, v -> HeadersEntry.sizeof(k, v)}
            }
            if (path.isNotEmpty()) {
                result += sizeof(Tag(4)) + sizeof(path)
            }
            if (host.isNotEmpty()) {
                result += sizeof(Tag(5)) + sizeof(host)
            }
            if (scheme.isNotEmpty()) {
                result += sizeof(Tag(6)) + sizeof(scheme)
            }
            if (query.isNotEmpty()) {
                result += sizeof(Tag(7)) + sizeof(query)
            }
            if (time  != null) {
                result += sizeof(Tag(9)) + sizeof(time)
            }
            if (size != 0L) {
                result += sizeof(Tag(10)) + sizeof(Int64(size))
            }
            if (protocol.isNotEmpty()) {
                result += sizeof(Tag(11)) + sizeof(protocol)
            }
            if (reason.isNotEmpty()) {
                result += sizeof(Tag(12)) + sizeof(reason)
            }
            if (auth  != null) {
                result += sizeof(Tag(13)) + sizeof(auth)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (id.isNotEmpty()) {
                serializer.write(Tag(10)).write(id)
            }
            if (method.isNotEmpty()) {
                serializer.write(Tag(18)).write(method)
            }
            if (headers.isNotEmpty()) {
                headers.entries.forEach { serializer.write(Tag(26)).write(HeadersEntry(it.key,
                        it.value)) }
            }
            if (path.isNotEmpty()) {
                serializer.write(Tag(34)).write(path)
            }
            if (host.isNotEmpty()) {
                serializer.write(Tag(42)).write(host)
            }
            if (scheme.isNotEmpty()) {
                serializer.write(Tag(50)).write(scheme)
            }
            if (query.isNotEmpty()) {
                serializer.write(Tag(58)).write(query)
            }
            if (time  != null) {
                serializer.write(Tag(74)).write(time)
            }
            if (size != 0L) {
                serializer.write(Tag(80)).write(Int64(size))
            }
            if (protocol.isNotEmpty()) {
                serializer.write(Tag(90)).write(protocol)
            }
            if (reason.isNotEmpty()) {
                serializer.write(Tag(98)).write(reason)
            }
            if (auth  != null) {
                serializer.write(Tag(106)).write(auth)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: kotlin.Any?): Boolean = other is Request &&
            other.id == id &&
            other.method == method &&
            other.headers == headers &&
            other.path == path &&
            other.host == host &&
            other.scheme == scheme &&
            other.query == query &&
            other.time == time &&
            other.size == size &&
            other.protocol == protocol &&
            other.reason == reason &&
            other.auth == auth &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + id.hashCode()
            result = 31 * result + method.hashCode()
            result = 31 * result + headers.hashCode()
            result = 31 * result + path.hashCode()
            result = 31 * result + host.hashCode()
            result = 31 * result + scheme.hashCode()
            result = 31 * result + query.hashCode()
            result = 31 * result + time.hashCode()
            result = 31 * result + size.hashCode()
            result = 31 * result + protocol.hashCode()
            result = 31 * result + reason.hashCode()
            result = 31 * result + auth.hashCode()
            return result
        }

        override fun toString(): String = "Request(" +
            "id=$id, " +
            "method=$method, " +
            "headers=$headers, " +
            "path=$path, " +
            "host=$host, " +
            "scheme=$scheme, " +
            "query=$query, " +
            "time=$time, " +
            "size=$size, " +
            "protocol=$protocol, " +
            "reason=$reason, " +
            "auth=$auth" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: RequestDsl.() -> Unit): Request = Request.Deserializer {
            id = this@Request.id
            method = this@Request.method
            headers = this@Request.headers
            path = this@Request.path
            host = this@Request.host
            scheme = this@Request.scheme
            query = this@Request.query
            time = this@Request.time
            size = this@Request.size
            protocol = this@Request.protocol
            reason = this@Request.reason
            auth = this@Request.auth
            unknownFields = this@Request.unknownFields
            dsl()
        }

        class RequestDsl {
            var id: String = ""

            var method: String = ""

            var headers: Map<String, String> = emptyMap()
                set(newValue) {
                    field = copyMap(newValue)
                }

            var path: String = ""

            var host: String = ""

            var scheme: String = ""

            var query: String = ""

            var time: Timestamp? = null

            var size: Long = 0L

            var protocol: String = ""

            var reason: String = ""

            var auth: Auth? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Request = Request(id,
            method,
            finishMap(headers),
            path,
            host,
            scheme,
            query,
            time,
            size,
            protocol,
            reason,
            auth,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Request>,
                (RequestDsl.() -> Unit) -> Request {
            override fun deserialize(deserializer: KtMessageDeserializer): Request {
                var id = ""
                var method = ""
                var headers : MutableMap<String, String>? = null
                var path = ""
                var host = ""
                var scheme = ""
                var query = ""
                var time : Timestamp? = null
                var size = 0L
                var protocol = ""
                var reason = ""
                var auth : Auth? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Request(id,
                                method,
                                finishMap(headers),
                                path,
                                host,
                                scheme,
                                query,
                                time,
                                size,
                                protocol,
                                reason,
                                auth,
                                UnknownFieldSet.from(unknownFields))
                        10 -> id = deserializer.readString()
                        18 -> method = deserializer.readString()
                        26 -> headers = (headers ?: mutableMapOf()).apply {
                                       deserializer.readRepeated(false) {

                                        deserializer.readMessage(com.google.rpc.context.AttributeContext.Request.HeadersEntry)
                                           .let { put(
                                               it.key,
                                               it.value
                                           ) }
                                       }
                                   }
                        34 -> path = deserializer.readString()
                        42 -> host = deserializer.readString()
                        50 -> scheme = deserializer.readString()
                        58 -> query = deserializer.readString()
                        74 -> time = deserializer.readMessage(com.toasttab.protokt.Timestamp)
                        80 -> size = deserializer.readInt64()
                        90 -> protocol = deserializer.readString()
                        98 -> reason = deserializer.readString()
                        106 -> auth =
                                deserializer.readMessage(com.google.rpc.context.AttributeContext.Auth)
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: RequestDsl.() -> Unit): Request =
                    RequestDsl().apply(dsl).build()
        }

        private class HeadersEntry(
            val key: String,
            val `value`: String,
        ) : KtMessage {
            override val messageSize: Int
                get() = sizeof(key, value)

            override fun serialize(serializer: KtMessageSerializer) {
                serializer.write(Tag(10)).write(key)

                serializer.write(Tag(18)).write(value)
            }

            companion object Deserializer : KtDeserializer<HeadersEntry> {
                fun sizeof(key: String, `value`: String) =
                        com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(value)

                override fun deserialize(deserializer: KtMessageDeserializer): HeadersEntry {
                    var key = ""
                    var value = ""

                    while (true) {
                      when (deserializer.readTag()) {
                        0 -> return HeadersEntry(key, value)
                        10 -> key = deserializer.readString()
                        18 -> value = deserializer.readString()
                      }
                    }
                }
            }
        }
    }

    /**
     * This message defines attributes for a typical network response. It generally models semantics
     * of an HTTP response.
     */
    @KtGeneratedMessage("google.rpc.context.Response")
    class Response private constructor(
        /**
         * The HTTP response status code, such as `200` and `404`.
         */
        val code: Long,
        /**
         * The HTTP response size in bytes. If unknown, it must be -1.
         */
        val size: Long,
        /**
         * The HTTP response headers. If multiple headers share the same key, they must be merged
         * according to HTTP spec. All header keys must be lowercased, because HTTP header keys are
         * case-insensitive.
         */
        val headers: Map<String, String>,
        /**
         * The timestamp when the `destination` service sends the last byte of the response.
         */
        val time: Timestamp?,
        /**
         * The length of time it takes the backend service to fully respond to a request. Measured
         * from when the destination service starts to send the request to the backend until when the
         * destination service receives the complete response from the backend.
         */
        val backendLatency: Duration?,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (code != 0L) {
                result += sizeof(Tag(1)) + sizeof(Int64(code))
            }
            if (size != 0L) {
                result += sizeof(Tag(2)) + sizeof(Int64(size))
            }
            if (headers.isNotEmpty()) {
                result += sizeofMap(headers, Tag(3)) { k, v -> HeadersEntry.sizeof(k, v)}
            }
            if (time  != null) {
                result += sizeof(Tag(4)) + sizeof(time)
            }
            if (backendLatency  != null) {
                result += sizeof(Tag(5)) + sizeof(backendLatency)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (code != 0L) {
                serializer.write(Tag(8)).write(Int64(code))
            }
            if (size != 0L) {
                serializer.write(Tag(16)).write(Int64(size))
            }
            if (headers.isNotEmpty()) {
                headers.entries.forEach { serializer.write(Tag(26)).write(HeadersEntry(it.key,
                        it.value)) }
            }
            if (time  != null) {
                serializer.write(Tag(34)).write(time)
            }
            if (backendLatency  != null) {
                serializer.write(Tag(42)).write(backendLatency)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: kotlin.Any?): Boolean = other is Response &&
            other.code == code &&
            other.size == size &&
            other.headers == headers &&
            other.time == time &&
            other.backendLatency == backendLatency &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + code.hashCode()
            result = 31 * result + size.hashCode()
            result = 31 * result + headers.hashCode()
            result = 31 * result + time.hashCode()
            result = 31 * result + backendLatency.hashCode()
            return result
        }

        override fun toString(): String = "Response(" +
            "code=$code, " +
            "size=$size, " +
            "headers=$headers, " +
            "time=$time, " +
            "backendLatency=$backendLatency" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: ResponseDsl.() -> Unit): Response = Response.Deserializer {
            code = this@Response.code
            size = this@Response.size
            headers = this@Response.headers
            time = this@Response.time
            backendLatency = this@Response.backendLatency
            unknownFields = this@Response.unknownFields
            dsl()
        }

        class ResponseDsl {
            var code: Long = 0L

            var size: Long = 0L

            var headers: Map<String, String> = emptyMap()
                set(newValue) {
                    field = copyMap(newValue)
                }

            var time: Timestamp? = null

            var backendLatency: Duration? = null

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Response = Response(code,
            size,
            finishMap(headers),
            time,
            backendLatency,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Response>,
                (ResponseDsl.() -> Unit) -> Response {
            override fun deserialize(deserializer: KtMessageDeserializer): Response {
                var code = 0L
                var size = 0L
                var headers : MutableMap<String, String>? = null
                var time : Timestamp? = null
                var backendLatency : Duration? = null
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Response(code,
                                size,
                                finishMap(headers),
                                time,
                                backendLatency,
                                UnknownFieldSet.from(unknownFields))
                        8 -> code = deserializer.readInt64()
                        16 -> size = deserializer.readInt64()
                        26 -> headers = (headers ?: mutableMapOf()).apply {
                                       deserializer.readRepeated(false) {

                                        deserializer.readMessage(com.google.rpc.context.AttributeContext.Response.HeadersEntry)
                                           .let { put(
                                               it.key,
                                               it.value
                                           ) }
                                       }
                                   }
                        34 -> time = deserializer.readMessage(com.toasttab.protokt.Timestamp)
                        42 -> backendLatency =
                                deserializer.readMessage(com.toasttab.protokt.Duration)
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: ResponseDsl.() -> Unit): Response =
                    ResponseDsl().apply(dsl).build()
        }

        private class HeadersEntry(
            val key: String,
            val `value`: String,
        ) : KtMessage {
            override val messageSize: Int
                get() = sizeof(key, value)

            override fun serialize(serializer: KtMessageSerializer) {
                serializer.write(Tag(10)).write(key)

                serializer.write(Tag(18)).write(value)
            }

            companion object Deserializer : KtDeserializer<HeadersEntry> {
                fun sizeof(key: String, `value`: String) =
                        com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(value)

                override fun deserialize(deserializer: KtMessageDeserializer): HeadersEntry {
                    var key = ""
                    var value = ""

                    while (true) {
                      when (deserializer.readTag()) {
                        0 -> return HeadersEntry(key, value)
                        10 -> key = deserializer.readString()
                        18 -> value = deserializer.readString()
                      }
                    }
                }
            }
        }
    }

    /**
     * This message defines core attributes for a resource. A resource is an addressable (named)
     * entity provided by the destination service. For example, a file stored on a network storage
     * service.
     */
    @KtGeneratedMessage("google.rpc.context.Resource")
    class Resource private constructor(
        /**
         * The name of the service that this resource belongs to, such as `pubsub.googleapis.com`.
         * The service may be different from the DNS hostname that actually serves the request.
         */
        val service: String,
        /**
         * The stable identifier (name) of a resource on the `service`. A resource can be logically
         * identified as "//{resource.service}/{resource.name}". The differences between a resource
         * name and a URI are:
         *
         *  *   Resource name is a logical identifier, independent of network     protocol and API
         * version. For example,     `//pubsub.googleapis.com/projects/123/topics/news-feed`. *   URI
         * often includes protocol and version information, so it can     be used directly by
         * applications. For example,
         * `https://pubsub.googleapis.com/v1/projects/123/topics/news-feed`.
         *
         *  See https://cloud.google.com/apis/design/resource_names for details.
         */
        val name: String,
        /**
         * The type of the resource. The syntax is platform-specific because different platforms
         * define their resources differently.
         *
         *  For Google APIs, the type format must be "{service}/{kind}".
         */
        val type: String,
        /**
         * The labels or tags on the resource, such as AWS resource tags and Kubernetes resource
         * labels.
         */
        val labels: Map<String, String>,
        /**
         * The unique identifier of the resource. UID is unique in the time and space for this
         * resource within the scope of the service. It is typically generated by the server on
         * successful creation of a resource and must not be changed. UID is used to uniquely identify
         * resources with resource name reuses. This should be a UUID4.
         */
        val uid: String,
        /**
         * Annotations is an unstructured key-value map stored with a resource that may be set by
         * external tools to store and retrieve arbitrary metadata. They are not queryable and should
         * be preserved when modifying objects.
         *
         *  More info: https://kubernetes.io/docs/user-guide/annotations
         */
        val annotations: Map<String, String>,
        /**
         * Mutable. The display name set by clients. Must be <= 63 characters.
         */
        val displayName: String,
        /**
         * Output only. The timestamp when the resource was created. This may be either the time
         * creation was initiated or when it was completed.
         */
        val createTime: Timestamp?,
        /**
         * Output only. The timestamp when the resource was last updated. Any change to the resource
         * made by users must refresh this value. Changes to a resource made by the service should
         * refresh this value.
         */
        val updateTime: Timestamp?,
        /**
         * Output only. The timestamp when the resource was deleted. If the resource is not deleted,
         * this must be empty.
         */
        val deleteTime: Timestamp?,
        /**
         * Output only. An opaque value that uniquely identifies a version or generation of a
         * resource. It can be used to confirm that the client and server agree on the ordering of a
         * resource being written.
         */
        val etag: String,
        /**
         * Immutable. The location of the resource. The location encoding is specific to the service
         * provider, and new encoding may be introduced as the service evolves.
         *
         *  For Google Cloud products, the encoding is what is used by Google Cloud APIs, such as
         * `us-east1`, `aws-us-east-1`, and `azure-eastus2`. The semantics of `location` is identical
         * to the `cloud.googleapis.com/location` label used by some Google Cloud APIs.
         */
        val location: String,
        val unknownFields: UnknownFieldSet = UnknownFieldSet.empty(),
    ) : KtMessage {
        override val messageSize: Int by lazy { messageSize() }

        private fun messageSize(): Int {
            var result = 0
            if (service.isNotEmpty()) {
                result += sizeof(Tag(1)) + sizeof(service)
            }
            if (name.isNotEmpty()) {
                result += sizeof(Tag(2)) + sizeof(name)
            }
            if (type.isNotEmpty()) {
                result += sizeof(Tag(3)) + sizeof(type)
            }
            if (labels.isNotEmpty()) {
                result += sizeofMap(labels, Tag(4)) { k, v -> LabelsEntry.sizeof(k, v)}
            }
            if (uid.isNotEmpty()) {
                result += sizeof(Tag(5)) + sizeof(uid)
            }
            if (annotations.isNotEmpty()) {
                result += sizeofMap(annotations, Tag(6)) { k, v -> AnnotationsEntry.sizeof(k, v)}
            }
            if (displayName.isNotEmpty()) {
                result += sizeof(Tag(7)) + sizeof(displayName)
            }
            if (createTime  != null) {
                result += sizeof(Tag(8)) + sizeof(createTime)
            }
            if (updateTime  != null) {
                result += sizeof(Tag(9)) + sizeof(updateTime)
            }
            if (deleteTime  != null) {
                result += sizeof(Tag(10)) + sizeof(deleteTime)
            }
            if (etag.isNotEmpty()) {
                result += sizeof(Tag(11)) + sizeof(etag)
            }
            if (location.isNotEmpty()) {
                result += sizeof(Tag(12)) + sizeof(location)
            }
            result += unknownFields.size()
            return result
        }

        override fun serialize(serializer: KtMessageSerializer) {
            if (service.isNotEmpty()) {
                serializer.write(Tag(10)).write(service)
            }
            if (name.isNotEmpty()) {
                serializer.write(Tag(18)).write(name)
            }
            if (type.isNotEmpty()) {
                serializer.write(Tag(26)).write(type)
            }
            if (labels.isNotEmpty()) {
                labels.entries.forEach { serializer.write(Tag(34)).write(LabelsEntry(it.key,
                        it.value)) }
            }
            if (uid.isNotEmpty()) {
                serializer.write(Tag(42)).write(uid)
            }
            if (annotations.isNotEmpty()) {
                annotations.entries.forEach {
                        serializer.write(Tag(50)).write(AnnotationsEntry(it.key, it.value)) }
            }
            if (displayName.isNotEmpty()) {
                serializer.write(Tag(58)).write(displayName)
            }
            if (createTime  != null) {
                serializer.write(Tag(66)).write(createTime)
            }
            if (updateTime  != null) {
                serializer.write(Tag(74)).write(updateTime)
            }
            if (deleteTime  != null) {
                serializer.write(Tag(82)).write(deleteTime)
            }
            if (etag.isNotEmpty()) {
                serializer.write(Tag(90)).write(etag)
            }
            if (location.isNotEmpty()) {
                serializer.write(Tag(98)).write(location)
            }
            serializer.writeUnknown(unknownFields)
        }

        override fun equals(other: kotlin.Any?): Boolean = other is Resource &&
            other.service == service &&
            other.name == name &&
            other.type == type &&
            other.labels == labels &&
            other.uid == uid &&
            other.annotations == annotations &&
            other.displayName == displayName &&
            other.createTime == createTime &&
            other.updateTime == updateTime &&
            other.deleteTime == deleteTime &&
            other.etag == etag &&
            other.location == location &&
            other.unknownFields == unknownFields

        override fun hashCode(): Int {
            var result = unknownFields.hashCode()
            result = 31 * result + service.hashCode()
            result = 31 * result + name.hashCode()
            result = 31 * result + type.hashCode()
            result = 31 * result + labels.hashCode()
            result = 31 * result + uid.hashCode()
            result = 31 * result + annotations.hashCode()
            result = 31 * result + displayName.hashCode()
            result = 31 * result + createTime.hashCode()
            result = 31 * result + updateTime.hashCode()
            result = 31 * result + deleteTime.hashCode()
            result = 31 * result + etag.hashCode()
            result = 31 * result + location.hashCode()
            return result
        }

        override fun toString(): String = "Resource(" +
            "service=$service, " +
            "name=$name, " +
            "type=$type, " +
            "labels=$labels, " +
            "uid=$uid, " +
            "annotations=$annotations, " +
            "displayName=$displayName, " +
            "createTime=$createTime, " +
            "updateTime=$updateTime, " +
            "deleteTime=$deleteTime, " +
            "etag=$etag, " +
            "location=$location" +
            "${if (unknownFields.isEmpty()) "" else ", unknownFields=$unknownFields"})"

        fun copy(dsl: ResourceDsl.() -> Unit): Resource = Resource.Deserializer {
            service = this@Resource.service
            name = this@Resource.name
            type = this@Resource.type
            labels = this@Resource.labels
            uid = this@Resource.uid
            annotations = this@Resource.annotations
            displayName = this@Resource.displayName
            createTime = this@Resource.createTime
            updateTime = this@Resource.updateTime
            deleteTime = this@Resource.deleteTime
            etag = this@Resource.etag
            location = this@Resource.location
            unknownFields = this@Resource.unknownFields
            dsl()
        }

        class ResourceDsl {
            var service: String = ""

            var name: String = ""

            var type: String = ""

            var labels: Map<String, String> = emptyMap()
                set(newValue) {
                    field = copyMap(newValue)
                }

            var uid: String = ""

            var annotations: Map<String, String> = emptyMap()
                set(newValue) {
                    field = copyMap(newValue)
                }

            var displayName: String = ""

            var createTime: Timestamp? = null

            var updateTime: Timestamp? = null

            var deleteTime: Timestamp? = null

            var etag: String = ""

            var location: String = ""

            var unknownFields: UnknownFieldSet = UnknownFieldSet.empty()

            fun build(): Resource = Resource(service,
            name,
            type,
            finishMap(labels),
            uid,
            finishMap(annotations),
            displayName,
            createTime,
            updateTime,
            deleteTime,
            etag,
            location,
             unknownFields)
        }

        companion object Deserializer : KtDeserializer<Resource>,
                (ResourceDsl.() -> Unit) -> Resource {
            override fun deserialize(deserializer: KtMessageDeserializer): Resource {
                var service = ""
                var name = ""
                var type = ""
                var labels : MutableMap<String, String>? = null
                var uid = ""
                var annotations : MutableMap<String, String>? = null
                var displayName = ""
                var createTime : Timestamp? = null
                var updateTime : Timestamp? = null
                var deleteTime : Timestamp? = null
                var etag = ""
                var location = ""
                var unknownFields: UnknownFieldSet.Builder? = null
                while (true) {
                    when(deserializer.readTag()) {
                        0 -> return Resource(service,
                                name,
                                type,
                                finishMap(labels),
                                uid,
                                finishMap(annotations),
                                displayName,
                                createTime,
                                updateTime,
                                deleteTime,
                                etag,
                                location,
                                UnknownFieldSet.from(unknownFields))
                        10 -> service = deserializer.readString()
                        18 -> name = deserializer.readString()
                        26 -> type = deserializer.readString()
                        34 -> labels = (labels ?: mutableMapOf()).apply {
                                       deserializer.readRepeated(false) {

                                        deserializer.readMessage(com.google.rpc.context.AttributeContext.Resource.LabelsEntry)
                                           .let { put(
                                               it.key,
                                               it.value
                                           ) }
                                       }
                                   }
                        42 -> uid = deserializer.readString()
                        50 -> annotations = (annotations ?: mutableMapOf()).apply {
                                       deserializer.readRepeated(false) {

                                        deserializer.readMessage(com.google.rpc.context.AttributeContext.Resource.AnnotationsEntry)
                                           .let { put(
                                               it.key,
                                               it.value
                                           ) }
                                       }
                                   }
                        58 -> displayName = deserializer.readString()
                        66 -> createTime = deserializer.readMessage(com.toasttab.protokt.Timestamp)
                        74 -> updateTime = deserializer.readMessage(com.toasttab.protokt.Timestamp)
                        82 -> deleteTime = deserializer.readMessage(com.toasttab.protokt.Timestamp)
                        90 -> etag = deserializer.readString()
                        98 -> location = deserializer.readString()
                        else -> unknownFields = (unknownFields ?:
                                UnknownFieldSet.Builder()).also {it.add(deserializer.readUnknown())
                                }
                    }
                }
            }

            override fun invoke(dsl: ResourceDsl.() -> Unit): Resource =
                    ResourceDsl().apply(dsl).build()
        }

        private class LabelsEntry(
            val key: String,
            val `value`: String,
        ) : KtMessage {
            override val messageSize: Int
                get() = sizeof(key, value)

            override fun serialize(serializer: KtMessageSerializer) {
                serializer.write(Tag(10)).write(key)

                serializer.write(Tag(18)).write(value)
            }

            companion object Deserializer : KtDeserializer<LabelsEntry> {
                fun sizeof(key: String, `value`: String) =
                        com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(value)

                override fun deserialize(deserializer: KtMessageDeserializer): LabelsEntry {
                    var key = ""
                    var value = ""

                    while (true) {
                      when (deserializer.readTag()) {
                        0 -> return LabelsEntry(key, value)
                        10 -> key = deserializer.readString()
                        18 -> value = deserializer.readString()
                      }
                    }
                }
            }
        }

        private class AnnotationsEntry(
            val key: String,
            val `value`: String,
        ) : KtMessage {
            override val messageSize: Int
                get() = sizeof(key, value)

            override fun serialize(serializer: KtMessageSerializer) {
                serializer.write(Tag(10)).write(key)

                serializer.write(Tag(18)).write(value)
            }

            companion object Deserializer : KtDeserializer<AnnotationsEntry> {
                fun sizeof(key: String, `value`: String) =
                        com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(1)) + com.toasttab.protokt.rt.sizeof(key) + com.toasttab.protokt.rt.sizeof(com.toasttab.protokt.rt.Tag(2)) + com.toasttab.protokt.rt.sizeof(value)

                override fun deserialize(deserializer: KtMessageDeserializer):
                        AnnotationsEntry {
                    var key = ""
                    var value = ""

                    while (true) {
                      when (deserializer.readTag()) {
                        0 -> return AnnotationsEntry(key, value)
                        10 -> key = deserializer.readString()
                        18 -> value = deserializer.readString()
                      }
                    }
                }
            }
        }
    }
}
